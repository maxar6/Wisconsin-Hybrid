
/* MotoCoder_DataStore.c */
/* Generated by MotoCoder */
/* Version: 0.10.7 */
/* At: 2017-03-08 22:42:23 */
/* Copyright: 2017 Woodward. */


#include <MotoCoder_DataStore.h>

/* DataStore */
/*---- DEFINES --------------------------------------------------------------------------------------------*/
#define rtInf                           (100000000000000000.000000)
#define rtMinusInf                      (-100000000000000000.000000)
  
/*---- TYPEDEFN -------------------------------------------------------------------------------------------*/

/*---- CONSTANTS ------------------------------------------------------------------------------------------*/

        
     

#include <Pragma_Section_Start_romcals_rodata.h>
        
const NonVolatile_T NonVolatileDefault __SECTION_ROMCALS_RODATA__ =  
{
    
         (53549U), /* NonVolatileFormatID */
        0x0000,  /* crc */    
    0.75, /* AT_Start */ 
    { 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0 }, /* MAF_Cal_OrdIdxArr */ 
    { 10.0, 15.0, 20.0, 25.0, 30.0, 35.0, 40.0, 45.0, 50.0 }, /* RampInPt_SOC_OrdIdxArr */ 
    5.0, /* RegenSpdRampStart */ 
    2.0, /* RegenSpdRampStop */ 
    0.03, /* Regen_Start */ 
    0, /* MotoHawkModelSecondsInUse */ 
    11, /* CityID_CAN_1 */ 
    0, /* FaultCommand */ 
    1U, /* TCVersion */ 
    0U, /* inhibitRegen */ 
    1U, /* inhibitTC */ 
    { { 0, 0, 0} } , /* FaultMarquees */ 
    { { { 0.0, 0.0, 0.0, 0.0 }, { 0.0, 0.0, 0.0, 0.0 }, { 0.0, 0.0, 0.0, 0.0 }, 0, 0, 0, 0, 0} } , /* VolFaultManager */ 
    
};

#include <Pragma_Section_End_rodata.h>
    


#include <Pragma_Section_End_rodata.h>
Volatile_T VolatileWork
= 
{    200.0, /* Nav_Spd_Freq_100_new */ 
    { 9, 9, 9, 9, 9, 9, 9, 9, 9 }, /* FaultActionReason */ 
	
};
Volatile_BSS_T VolatileWork_BSS
; 


#include <Pragma_Section_Start_cals_rodata.h>
    
const Constant_T ConstantWork __SECTION_CALS_RODATA__ =
    {
    { 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0 }, /* AC_Cal_TblTbl */ 
    0.75, /* AT_Full */ 
    0.2, /* AT_Level */ 
    0.55, /* AT_Ramp */ 
    0.5, /* AT_Stop */ 
    430.0, /* Accel1_Full */ 
    94.0, /* Accel1_Zero */ 
    865.0, /* Accel2_Full */ 
    193.0, /* Accel2_Zero */ 
    0.5, /* Accel_Pedal_Pos */ 
    0.08, /* Acell_Max_Diff */ 
    5.0, /* Activation_Spd */ 
    0.0, /* Age_Count_Comparison */ 
    0.0, /* AmmoniaMinTemp */ 
    30.0, /* AssistMinSOC */ 
    5.0, /* AssistSOCRampWidth */ 
    0.0, /* Bat_Lvl_Offset */ 
    597.0, /* BrakeBackup_Full */ 
    678.0, /* BrakeBackup_Zero */ 
    37.0, /* Brake_Full */ 
    1.0, /* Brake_Redun_Err */ 
    925.0, /* Brake_Zero */ 
    0.75, /* ClutchBackup_Full */ 
    0.5, /* ClutchBackup_Zero */ 
    1015.0, /* Clutch_Full */ 
    0.75, /* Clutch_Mech_Engage_in_Accel_Through_Shifts */ 
    0.75, /* Clutch_Mech_Engage_in_ESS */ 
    1.0, /* Clutch_Redun_Err */ 
    0.6, /* Clutch_Thres_Shifts */ 
    0.76, /* Clutch_Thres_Take_Off */ 
    110.0, /* Clutch_Zero */ 
    115.0, /* Coolant_Temp_Warning_Thres */ 
    50.0, /* Cruise_Down_Tres */ 
    50.0, /* Cruise_Main_Tres */ 
    50.0, /* Cruise_Up_Tres */ 
    14.0, /* DCDC_Buck_V */ 
    { 0.0, 0.1, 0.2, 3.0000000000000004E-001, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0 }, /* Diesel_Accel_MapTbl */ 
    { 0.0, 0.1, 0.2, 3.0000000000000004E-001, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0 }, /* Diesel_Accel_OrdIdxArr */ 
    0.0, /* Diff_Ratio */ 
    1200.0, /* Disable_MCU_Delay */ 
    3000.0, /* Disable_Nav_Safety_Delay */ 
    5.0, /* Dose_Freq */ 
    200.0, /* Dosing_Time */ 
    0.23, /* Eng_Torq_Shifts */ 
    0.23, /* Eng_Torq_Take_Off */ 
    500.0, /* Engine_Start_RPM */ 
    50.0, /* Engine_Stop_RPM */ 
    1.0, /* F_Torque_Allowed */ 
    0.2, /* F_low_bound */ 
    3.0, /* F_rmp_in_rate */ 
    8.0, /* F_rmp_out_rate */ 
    416.0, /* FeulLevel_Zero */ 
    0.0005, /* Filt_Accel_K */ 
    0.02, /* Filt_Wheel_Derv_K */ 
    231.0, /* FuelLevel_Full */ 
    1.0, /* Fuel_Consumption_Adjustment */ 
    0.0001, /* Fuel_Filter_K */ 
    0.0, /* Gage_Delay */ 
    0.0, /* Gear_Ratio_1 */ 
    0.0, /* Gear_Ratio_2 */ 
    0.0, /* Gear_Ratio_3 */ 
    0.0, /* Gear_Ratio_4 */ 
    0.0, /* Gear_Ratio_5 */ 
    0.0, /* Gear_Ratio_6 */ 
    0.0, /* Ki */ 
    0.0, /* Kp */ 
    0.0, /* LeanMult */ 
    0.0, /* LeanTime */ 
    { 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0 }, /* MAF_Cal_TblTbl */ 
    4.0, /* Max_StartRetry */ 
    0.0, /* Min_Wheel_Vel */ 
    0.0, /* NOxThres */ 
    1.0F, /* Nav_Ft_per_Pulse */ 
    3.55, /* Out1_Full */ 
    1.0, /* Out1_Zero */ 
    1.75, /* Out2_Full */ 
    0.5, /* Out2_Zero */ 
    1.5E+005, /* PWM_Freq */ 
    0.3, /* Preload_Value */ 
    1.0, /* R_Torque_Allowed */ 
    0.2, /* R_low_bound */ 
    3.0, /* R_rmp_in_rate */ 
    6.0, /* R_rmp_out_rate */ 
    { 50.0, 45.0, 40.0, 35.0, 30.0, 25.0, 20.0, 15.0, 10.0 }, /* RampInPt_SOCTbl */ 
    90.0, /* RegenMaxSOC */ 
    5.0, /* RegenSOCRampWidth */ 
    0.3, /* Regen_Full */ 
    0.0, /* RichMult */ 
    0.0, /* RichTime */ 
    -0.1000000015F, /* SB_Level */ 
    80.0, /* SB_Off */ 
    60.0, /* SB_On */ 
    1000.0, /* SB_Ramp_Time */ 
    100.0, /* SOC_Lvl_Full */ 
    5.0, /* SOC_Lvl_Zero */ 
    1.0, /* Slip_Determine_Mode */ 
    5.0, /* Speed_Threshold */ 
    6.5, /* TC_Accel_Thres */ 
    2.0, /* TC_Rmp_Adjust_Rate */ 
    10.0, /* TC_Slip_Thres */ 
    26.0, /* Tire_Size */ 
    12.0, /* TransGoToPoint */ 
    0.0, /* UreaAccel_Mult */ 
    0.0, /* UreaMin_Temp */ 
    0.0, /* UreaNOx_Mult */ 
    { 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0 }, /* Urea_Accel_OrdIdxArr */ 
    { 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0 }, /* Urea_Accel_TblTbl */ 
    0.0, /* Urea_Dilution */ 
    { 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0 }, /* Urea_Injection_OrdIdxArr */ 
    { 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0 }, /* Urea_Injection_TblTbl */ 
    0.0, /* Urea_PurgeLevel */ 
    37.0, /* ZEVMinSOC */ 
    5.0, /* ZEVSOCRampWidth */ 
    { 0.0, 0.1, 0.2, 3.0000000000000004E-001, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0 }, /* ZEV_Accel_MapTbl */ 
    { 0.0, 0.1, 0.2, 3.0000000000000004E-001, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0 }, /* ZEV_Accel_OrdIdxArr */ 
    0.01, /* Zero_Threshold */ 
    3.25, /* cuurentPlusMinus */ 
    285.0, /* highV */ 
    195.0, /* lowV */ 
    10.0, /* off_Pres */ 
    10.0, /* on_Pres */ 
    0.0, /* volt_out_1 */ 
    0.0, /* volt_out_2 */ 
    1000, /* MAF_Input_MinFrequency */ 
    5000, /* Urea_PulseW */ 
    { 0U, 128U, 256U, 384U, 512U, 640U, 768U, 896U, 1024U }, /* AC_Cal_OrdIdxArr */ 
    5U, /* Crank_to_Idle_Delay */ 
    0U, /* DCDC_Boost_V */ 
    0U, /* Enable_AC */ 
    5U, /* Idle_to_Crank_Delay */ 
    1000U, /* KillDelay */ 
    200U, /* Kill_Time */ 
    400U, /* Max_Current */ 
    288U, /* Max_Voltage */ 
    195U, /* Min_Voltage */ 
    0U, /* NOx_Offset */ 
    400U, /* Regen_Current */ 
    400U, /* StartRetry_Delay */ 
    40U, /* Start_Delay */ 
    400U, /* Start_Time */ 
    10U, /* min_Press_Thres */ 
    RES_INJ4D, /* AC_Clutch */ 
    RES_INJ9D, /* AC_Fan */ 
    RES_NONE, /* AC_Pres */ 
    RES_AN1M, /* Accel1 */ 
    RES_AN2M, /* Accel2 */ 
    RES_AN10M, /* Brake */ 
    RES_AN7M, /* BrakeBackUp */ 
    RES_AN8M, /* Clutch */ 
    RES_NONE, /* ClutchBackup */ 
    RES_AN5M, /* CruiseButtons */ 
    RES_STOP, /* ESTOP */ 
    RES_AN13M, /* FuelLevel */ 
    RES_H1, /* IPT_EPO */ 
    RES_DG4M, /* MAF_Input */ 
    RES_DG1M, /* Neutral */ 
    RES_AN3M, /* Reverse */ 
    RES_HSOL1, /* Urea_Injector */ 
    RES_INJ7D, /* Urea_Power */ 
    0, /* AC_Pres_ref */ 
    1U, /* AT_Enable */ 
    0, /* Accel1_ref */ 
    0, /* Accel2_ref */ 
    0, /* BrakeBackUp_ref */ 
    0, /* Brake_ref */ 
    1U, /* CheckEngineLights */ 
    0, /* ClutchBackup_ref */ 
    0, /* Clutch_ref */ 
    0, /* CruiseButtons_ref */ 
    1U, /* DCDC_En */ 
    0U, /* DCDC_Mode */ 
    0U, /* DisableAntiShudder */ 
    1U, /* ESTOP_Invert */ 
    1U, /* EnableSport */ 
    1U, /* Enable_IPT */ 
    1U, /* EngineKill_Enable */ 
    0U, /* EngineKill_Invert */ 
    1U, /* EngineStart_Enable */ 
    0U, /* EngineStart_Invert */ 
    0, /* FuelLevel_ref */ 
    0U, /* ISO_Enable */ 
    0U, /* InhibitAssist */ 
    0U, /* InhibitZEV */ 
    1U, /* Inhibit_MCU_Management */ 
    0U, /* LeanRichEnable */ 
    1, /* MAF_Input_AliasProtect */ 
    0, /* MAF_Input_EdgeDetect */ 
    0, /* MAF_Input_Interface */ 
    0U, /* MCU_Manage_Source */ 
    15U, /* SOC_Off_DCDC */ 
    20U, /* SOC_On_DCDC */ 
    0U, /* VCUOff */ 
    0U, /* Wheel_Speed_Validities */ 
    0, /* Batt_Fan_Circuit */ 
    1, /* EngineStopStartAlg */ 
    69, /* H2_Tank_Pres_Cal */ 
    0, /* Nav_DVD_Safety */ 
    1, /* Nav_DVD_Unsafe_Value */ 
    1.0, /* Neutral_Invert */ 
    0.0, /* Reverse_Invert */ 
    0, /* Urea_Enable */ 
    0, /* Urea_Purge */ 
    { { 25, 9} } , /* ConstFaultManager */ 
    { { 3, 0, 0, 10, 20, 3, 2, 9, 0, 9, 0, 9, 0} , { 3, 0, 0, 10, 20, 3, 2, 9, 0, 9, 0, 9, 0} , { 0, 0, 0, 10, 20, 5, 2, 6, 2, 9, 0, 9, 0} , { 0, 0, 0, 10, 20, 9, 0, 9, 0, 9, 0, 9, 0} , { 0, 0, 0, 10, 20, 9, 0, 9, 0, 9, 0, 9, 0} , { 0, 0, 0, 10, 20, 8, 2, 9, 0, 9, 0, 9, 0} , { 0, 0, 0, 10, 20, 8, 2, 9, 0, 9, 0, 9, 0} , { 0, 0, 0, 10, 20, 8, 2, 9, 0, 9, 0, 9, 0} , { 3, 0, 0, 10, 11, 5, 2, 9, 0, 9, 0, 9, 0} , { 3, 0, 0, 10, 11, 5, 2, 9, 0, 9, 0, 9, 0} , { 0, 0, 0, 10, 20, 7, 2, 4, 2, 0, 2, 9, 0} , { 0, 0, 0, 10, 20, 7, 2, 4, 2, 0, 2, 9, 0} , { 2, 0, 0, 10, 20, 7, 2, 4, 0, 0, 0, 9, 0} , { 0, 0, 0, 10, 20, 9, 0, 9, 0, 9, 0, 9, 0} , { 3, 0, 0, 10, 11, 9, 0, 9, 0, 9, 0, 9, 0} , { 3, 0, 0, 10, 11, 9, 0, 9, 0, 9, 0, 9, 0} , { 3, 0, 0, 10, 11, 9, 2, 6, 2, 9, 0, 9, 0} , { 3, 0, 0, 10, 11, 9, 2, 6, 2, 9, 0, 9, 0} , { 3, 0, 0, 29, 30, 9, 2, 9, 0, 9, 0, 9, 0} , { 3, 0, 0, 10, 11, 6, 2, 9, 0, 9, 0, 9, 0} , { 3, 0, 0, 10, 11, 9, 0, 9, 0, 9, 0, 9, 0} , { 3, 0, 0, 10, 11, 9, 0, 9, 0, 9, 0, 9, 0} , { 3, 0, 0, 10, 11, 2, 2, 9, 0, 9, 0, 9, 0} , { 3, 0, 0, 10, 11, 2, 2, 9, 0, 9, 0, 9, 0} , { 3, 0, 0, 10, 11, 9, 0, 9, 0, 9, 0, 9, 0} } , /* FaultManager */ 
    
};    
#include <Pragma_Section_End_rodata.h>
    
    
  
/*---- SERIAL EEPROM VARIABLES ----------------------------------------------------------------------------*/


/* Uninitialised EE Variables */
#include <Pragma_Section_Start_bss_ee_bss_engcode.h>
NonVolatile_T NonVolatileStorage __SECTION_BSS_EEBSSENGCODE__;
#include <Pragma_Section_End_bss.h>
    

/* Initialised EE Variables */
#include <Pragma_Section_Start_data_ee_data_engcode.h>
    
uint8_T IsFirstApplicationBoot __SECTION_DATA_EEDATAENGCODE__= 0xFF;
    
/* Name: NonVolatileRestoreOnStartup ClassID:ENUMVAR StorageID:FLASH Access:RW4+RW3+RW2+RW1 TypeID:UINT1 CType:uint8_T
Struct:NonVolatileRestoreOnStartup  Mask:FFFFFFFF Gain:1.0 Offset:0.0 Exp:1.0 Min:0 Max:1 Format:1.0
EnumDec:E_NVRestore UpdateID:BACKGND Group:"System | NonVolatile Storage | NonVolatile Storage Config"
Help:"Selects whether to restore from factory defaults on next startup" */
uint8_T NonVolatileRestoreOnStartup __SECTION_DATA_EEDATAENGCODE__ = 0; /* defaults to restore from eeprom */

/* Name: NonVolatileRestoreOnFirstStartup ClassID:ENUMVAR StorageID:FLASH Access:RW4+RW3+RW2+RW1 TypeID:UINT1 CType:uint8_T
Struct:NonVolatileRestoreOnFirstStartup  Mask:FFFFFFFF Gain:1.0 Offset:0.0 Exp:1.0 Min:0 Max:1 Format:1.0
EnumDec:E_NVRestore UpdateID:BACKGND Group:"System | NonVolatile Storage | NonVolatile Storage Config"
Help:"Selects whether to restore from factory defaults the first time an application boots" */
uint8_T NonVolatileRestoreOnFirstStartup __SECTION_DATA_EEDATAENGCODE__ = 1;

#include <Pragma_Section_End_data.h>
        

    
/*---- RAM VARIABLES --------------------------------------------------------------------------------------*/
#include <Pragma_Section_End_data.h>
#include <Pragma_Section_End_bss.h>


        
/*---- RAM VARIABLES --------------------------------------------------------------------------------------*/
#include <Pragma_Section_Start_ramcals_bss.h>

NonVolatile_T NonVolatileWork __SECTION_RAMCALS_BSS__;

#include <Pragma_Section_End_bss.h>


/*---- CODE SPACE -----------------------------------------------------------------------------------------*/
#include <Pragma_Section_Start_text_code.h>
#include <Pragma_Section_End_data.h>
#include <Pragma_Section_End_bss.h>
            
/* Name: NonVolatileFormatID ClassID:VAR StorageID:RAM Access:RO4+RO3+RO2+RO1 TypeID:UINT4 CType:NonVolatile_T Struct:NonVolatileWork.NonVolatileFormatID
Mask:FFFFFFFF Gain:1.0 Offset:0.0 Exp:1.0 Min:0 Max:4294967295 Format:8.0 UpdateID:BACKGND Group:"System | NonVolatile Storage"
Help:"Unique identifier of the NonVolatile memory format.  Used to validate whether stored variables are in the correct form for the program" */

/* Name: NonVolatileStatus ClassID:ENUMVAR StorageID:RAM Access:RO4+RO3+RO2+RO1 TypeID:UINT1 CType:uint8_T Struct:NonVolatile_NonVolatileStatus 
Mask:FFFFFFFF Gain:1.0 Offset:0.0 Exp:1.0 Min:0 Max:6 Format:1.0 UpdateID:BACKGND
Group:"System | NonVolatile Storage" Help:"Indicates how NonVolatile memory was loaded"  EnumDec:E_NVStatus */
uint8_T NonVolatile_NonVolatileStatus
= 0;
void NonVolatile_NonVolatileStatus_Reset(void)
{
    NonVolatile_NonVolatileStatus_DataStore()=NV_LOADED_FACTORY_USER_CMD;
}
    
/* Name: NonVolatileCRC ClassID:VAR StorageID:RAM Access:RO4+RO3+RO2+RO1 TypeID:UINT4 CType:uint32_T Struct:NonVolatile_NonVolatileCRC  
Mask:FFFFFFFF Gain:1.0 Offset:0.0 Exp:1.0 Min:0 Max:65535 Format:1.0 UpdateID:BACKGND 
Group:"System | NonVolatile Storage" Help:"Calculated NonVolatile CRC" */
uint32_T NonVolatile_NonVolatileCRC = 0;



/*---- CODE SPACE -----------------------------------------------------------------------------------------*/
#include <Pragma_Section_End_data.h>
#include <Pragma_Section_End_bss.h>

     
    
uint16_T calculate_crc(void *pointer, uint32_T number_bytes, uint16_T icrc)
{
    uint32_T bitmask;
    uint32_T mdx;
    uint8_T *pointer1 = (uint8_T *) pointer;
    
    for(mdx=0; mdx < number_bytes; mdx++) 
    {
        bitmask = 1 << 7;
        do 
        {
            if ( !(icrc & 0x8000) ^ !(*pointer1 & bitmask)) 
            {
                icrc <<= 1;
                icrc ^= 0x8005;
            }
            else 
            {
                icrc <<= 1;
            }
        } while ( bitmask >>= 1);
        pointer1++;
    }
    return icrc;
}
void NonVolatile_RestoreDefaultNonVolatile(void)
{
    uint16_T crc = 0xFFFF;
    DISABLE();

    MemReadSynch(&NonVolatileWork, &NonVolatileDefault, sizeof(NonVolatile_T));

    
    
    crc = calculate_crc((uint8_T *)&NonVolatileWork + NON_VOLATILE_OVERHEAD_BYTES, sizeof(NonVolatile_T) - NON_VOLATILE_OVERHEAD_BYTES, crc);
    
    
        
    NonVolatileWork.crc = crc;
    NonVolatile_NonVolatileCRC = NonVolatileWork.crc;
    
    UNDISABLE();
}
void NonVolatile_StoreNonVolatile(void)
{
    extern uint16_T calculate_crc(void *pointer1, uint32_T number_bytes, uint16_T icrc);
    uint16_T icrc = 0xFFFFu;
    uint32_T *work_ptr = (uint32_T *) &NonVolatileWork;
    uint32_T * storage_ptr = (uint32_T *) &NonVolatileStorage;
    uint32_T word_count = sizeof(NonVolatile_T) / 4 - NON_VOLATILE_OVERHEAD_BYTES / 4;
    uint32_T final_byte_count = sizeof(NonVolatile_T) % 4;
    uint32_T tmp_word;
    static uint32_T tmp_word2;
    uint8_T oldStatus = NonVolatile_NonVolatileStatus;
    uint32_T i;
    
    NonVolatile_NonVolatileStatus = NV_STORING_EEPROM;
    
    work_ptr += NON_VOLATILE_OVERHEAD_BYTES / 4;
    storage_ptr += NON_VOLATILE_OVERHEAD_BYTES / 4;
    for (i=0; i < word_count; i++)
    {
        DISABLE();
        tmp_word = *work_ptr;
        UNDISABLE();
        MemReadSynch(&tmp_word2, storage_ptr, sizeof(tmp_word2));
        if (tmp_word != tmp_word2) {
            MemWriteSynch(storage_ptr, &tmp_word, sizeof(tmp_word));
        }
        icrc = calculate_crc(&tmp_word, sizeof(tmp_word), icrc);
        work_ptr++;
        storage_ptr++;
    }
    if (final_byte_count > 0)
    {
        DISABLE();
        tmp_word = *work_ptr;
        UNDISABLE();
        MemReadSynch(&tmp_word2, storage_ptr, final_byte_count);
        if (tmp_word != tmp_word2) {
            MemWriteSynch(storage_ptr, &tmp_word, final_byte_count);
        }
        icrc = calculate_crc(&tmp_word, final_byte_count, icrc);
    }
    
    NonVolatile_NonVolatileCRC = icrc;
    
    MemWriteSynch(&NonVolatileStorage.NonVolatileFormatID, &NonVolatileDefault.NonVolatileFormatID, sizeof(NonVolatileWork.NonVolatileFormatID));
    MemWriteSynch(&NonVolatileStorage.crc, &NonVolatile_NonVolatileCRC, sizeof(NonVolatile_NonVolatileCRC));
    
    NonVolatile_NonVolatileStatus = oldStatus;
    
}
void NonVolatile_OpenNonVolatile(void)
{
    uint32_T storedNonVolatileFormatID = 0;
    uint8_T firstApplicationBoot = 0;
    uint8_T restoreFactoryDefaults = 0;
    uint8_T restoreFactoryDefaultsFirstBoot = 0;
    
    MemReadSynch(&firstApplicationBoot, &IsFirstApplicationBoot, sizeof(IsFirstApplicationBoot));
    MemReadSynch(&restoreFactoryDefaults, &NonVolatileRestoreOnStartup, sizeof(NonVolatileRestoreOnStartup));
    MemReadSynch(&restoreFactoryDefaultsFirstBoot,&NonVolatileRestoreOnFirstStartup, sizeof(NonVolatileRestoreOnFirstStartup));
    MemReadSynch(&storedNonVolatileFormatID,&(NonVolatileStorage.NonVolatileFormatID),sizeof(NonVolatileStorage.NonVolatileFormatID));
    
    if ((firstApplicationBoot && restoreFactoryDefaultsFirstBoot) || restoreFactoryDefaults)
    {
        NonVolatile_NonVolatileStatus = NV_LOADING_FACTORY;
        NonVolatile_RestoreDefaultNonVolatile();
        
        restoreFactoryDefaults = 0;
        MemWriteSynch(&NonVolatileRestoreOnStartup, &restoreFactoryDefaults,sizeof(NonVolatileRestoreOnStartup));
        
        NonVolatile_NonVolatileStatus = NV_LOADED_FACTORY_USER_CMD;
    }
    else if (storedNonVolatileFormatID != NonVolatileDefault.NonVolatileFormatID)
    {
        NonVolatile_NonVolatileStatus = NV_LOADING_FACTORY;
        NonVolatile_RestoreDefaultNonVolatile();
        NonVolatile_NonVolatileStatus = NV_LOADED_FACTORY_BAD_MAGIC;
    }
    else
    {
        extern uint16_T calculate_crc(void *pointer1, uint32_T number_bytes,
        uint16_T icrc);
        uint16_T icrc = 0xFFFFu;
        uint32_T *work_ptr = (uint32_T *) &NonVolatileWork;
        uint32_T * storage_ptr = (uint32_T *) &NonVolatileStorage;
        uint32_T word_count = sizeof(NonVolatile_T) / 4 - NON_VOLATILE_OVERHEAD_BYTES / 4;
        uint32_T final_byte_count = sizeof(NonVolatile_T) % 4;
        uint32_T tmp_word;
        uint32_T i;
        
        NonVolatile_NonVolatileStatus = NV_LOADING_EEPROM;
    
        work_ptr += NON_VOLATILE_OVERHEAD_BYTES / 4;
        storage_ptr += NON_VOLATILE_OVERHEAD_BYTES / 4;
        for (i=0; i < word_count; i++)
        {
            MemReadSynch(&tmp_word, storage_ptr, sizeof(tmp_word));
            DISABLE();
            *work_ptr = tmp_word;
            UNDISABLE();
            icrc = calculate_crc(&tmp_word, sizeof(tmp_word), icrc);
            work_ptr++;
            storage_ptr++;
        }
        if (final_byte_count > 0)
        {
            MemReadSynch(&tmp_word, storage_ptr, final_byte_count);
            DISABLE();
            *work_ptr = tmp_word;
            UNDISABLE();
            icrc = calculate_crc(&tmp_word, final_byte_count, icrc);
        }
    
        
        NonVolatile_NonVolatileCRC = icrc;
    
        MemReadSynch(&NonVolatileWork.crc, &(NonVolatileStorage.crc), sizeof(NonVolatileStorage.crc));
    
        if(NonVolatile_NonVolatileCRC != NonVolatileWork.crc)
        {
            NonVolatile_NonVolatileStatus = NV_LOADING_FACTORY;
            NonVolatile_RestoreDefaultNonVolatile();
            NonVolatile_NonVolatileStatus = NV_LOADED_FACTORY_BAD_CRC;
        }
        else
        {
            NonVolatileWork.NonVolatileFormatID = storedNonVolatileFormatID;
            NonVolatile_NonVolatileStatus = NV_LOADED_EEPROM;
        }
    }
    
    if (firstApplicationBoot)
    {
        firstApplicationBoot = 0;
        MemWriteSynch(&IsFirstApplicationBoot, &firstApplicationBoot, sizeof(IsFirstApplicationBoot));
    }
}

