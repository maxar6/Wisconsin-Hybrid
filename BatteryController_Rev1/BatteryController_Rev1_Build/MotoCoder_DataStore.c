
/* MotoCoder_DataStore.c */
/* Generated by MotoCoder */
/* Version: 0.12.4 */
/* At: 2018-08-25 20:25:22 */
/* Copyright: 2018 Woodward. */


#include <MotoCoder_DataStore.h>

/* DataStore */
/*---- DEFINES --------------------------------------------------------------------------------------------*/
#define rtInf                           (100000000000000000.000000)
#define rtMinusInf                      (-100000000000000000.000000)
  
/*---- TYPEDEFN -------------------------------------------------------------------------------------------*/

/*---- CONSTANTS ------------------------------------------------------------------------------------------*/

        
     

#include <Pragma_Section_Start_romcals_rodata.h>
        
const NonVolatile_T NonVolatileDefault __SECTION_ROMCALS_RODATA__ =  
{
    
         (30624U), /* NonVolatileFormatID */
        0x0000,  /* crc */    
    0.0, /* AmpIn */ 
    0.0, /* AmpOut */ 
    0.001, /* Amp_Clamp_K */ 
    2.15, /* Amp_Offset */ 
    25.0, /* CoolantTemperature */ 
    819.2, /* Current_Div2 */ 
    0.0, /* DPI_RollingCounter */ 
    2056.0, /* DutyCycle */ 
    300.0, /* FreqEnd */ 
    400.0, /* FreqStart */ 
    0.00615, /* G_Sensativity */ 
    1.0, /* HVIL_Status */ 
    10.0, /* IsolationLevel */ 
    0.0, /* IsolationStatus */ 
    0.0, /* MILState */ 
    100000.0, /* Max_AmphoursIn */ 
    100000.0, /* Max_AmphoursOut */ 
    0.0, /* PPL10S_RollingCounter */ 
    0.0, /* PPL_RollingCounter */ 
    0.0, /* PS_RollingCounter */ 
    0.0, /* PVC_RollingCounter */ 
    69.0, /* PackIdentifier */ 
    0.75, /* Precharge_Current_Threshold */ 
    0.0, /* Reset_AmpHoursIn */ 
    0.0, /* Reset_AmpHoursOut */ 
    { 100.0, 99.0, 8.0, 0.0 }, /* SOCMapTbl */ 
    0.001, /* SOC_K */ 
    { 385.95, 378.51, 319.92, 279.0 }, /* SOC_TableIdxArr */ 
    0.0, /* SleepInhibited */ 
    100.0, /* StateOfChargeMax */ 
    0.0, /* StateOfChargeMin */ 
    0.0, /* TAH_RollingCounter */ 
    { 0.9, 0.5, 0.2, 0.1, 0.1 }, /* Temp_IR_MapTbl */ 
    { -40.0, -20.0, 0.0, 20.0, 40.0 }, /* Temp_IR_TableIdxArr */ 
    409.6, /* V5V_Ref2 */ 
    1.0, /* WakeSignal */ 
    25.0, /* highAmperage */ 
    20.0, /* lowAmperage */ 
    0, /* MotoHawkModelSecondsInUse */ 
    50, /* Wait_time */ 
    13, /* CityID_CAN_1 */ 
     {7, {{ 50.0, 50.0, 50.0, 50.0, 50.0, 20.0, 0.0 },{ 100.0, 100.0, 100.0, 100.0, 100.0, 50.0, 0.0 },{ 200.0, 200.0, 200.0, 200.0, 150.0, 50.0, 0.0 },{ 300.0, 300.0, 300.0, 300.0, 200.0, 50.0, 0.0 },{ 300.0, 300.0, 300.0, 300.0, 200.0, 80.0, 0.0 },{ 300.0, 300.0, 300.0, 300.0, 200.0, 100.0, 0.0 },{ 300.0, 300.0, 300.0, 300.0, 200.0, 100.0, 0.0 },{ 300.0, 300.0, 300.0, 300.0, 200.0, 100.0, 0.0 },{ 300.0, 300.0, 300.0, 300.0, 200.0, 100.0, 0.0 },{ 300.0, 300.0, 300.0, 300.0, 200.0, 100.0, 0.0 },{ 300.0, 300.0, 300.0, 300.0, 200.0, 100.0, 0.0 },}, }, /* MaxDisPwr_Cont_TableMap */ 
    
};

#include <Pragma_Section_End_rodata.h>
    


#include <Pragma_Section_End_rodata.h>
Volatile_BSS_T VolatileWork_BSS
; 


#include <Pragma_Section_Start_cals_rodata.h>
    
const Constant_T ConstantWork __SECTION_CALS_RODATA__ =
    {
    2.15, /* AmpV_Offset */ 
    { -40.0, -20.0, 0.0, 20.0, 40.0, 60.0, 80.0 }, /* CellTemp_PreLookupIdxArr */ 
    60.0, /* Delay_3_Cal */ 
    100.0, /* Delay_5_Cal */ 
    0.0, /* FaultsDTC */ 
    25.0, /* MaxCellTemp */ 
    25.0, /* MinCellTemp */ 
    { 0.0, 10.0, 20.0, 30.0, 40.0, 50.0, 60.0, 70.0, 80.0, 90.0, 100.0 }, /* SOC_PreLookupIdxArr */ 
    100U, /* ECUP_Threshold */ 
     {7, {{ 62.5, 62.5, 62.5, 62.5, 62.5, 25.0, 0.0 },{ 125.0, 125.0, 125.0, 125.0, 125.0, 62.5, 0.0 },{ 250.0, 250.0, 250.0, 250.0, 187.5, 62.5, 0.0 },{ 375.0, 375.0, 375.0, 375.0, 250.0, 62.5, 0.0 },{ 375.0, 375.0, 375.0, 375.0, 250.0, 100.0, 0.0 },{ 375.0, 375.0, 375.0, 375.0, 250.0, 125.0, 0.0 },{ 375.0, 375.0, 375.0, 375.0, 250.0, 125.0, 0.0 },{ 375.0, 375.0, 375.0, 375.0, 250.0, 125.0, 0.0 },{ 375.0, 375.0, 375.0, 375.0, 250.0, 125.0, 0.0 },{ 375.0, 375.0, 375.0, 375.0, 250.0, 125.0, 0.0 },{ 375.0, 375.0, 375.0, 375.0, 250.0, 125.0, 0.0 },}, }, /* MaxDisPwr_10s_TableMap */ 
     {7, {{ 62.5, 62.5, 62.5, 62.5, 62.5, 25.0, 0.0 },{ 125.0, 125.0, 125.0, 125.0, 125.0, 62.5, 0.0 },{ 250.0, 250.0, 250.0, 250.0, 187.5, 62.5, 0.0 },{ 375.0, 375.0, 375.0, 375.0, 250.0, 62.5, 0.0 },{ 375.0, 375.0, 375.0, 375.0, 250.0, 100.0, 0.0 },{ 375.0, 375.0, 375.0, 375.0, 250.0, 125.0, 0.0 },{ 375.0, 375.0, 375.0, 375.0, 250.0, 125.0, 0.0 },{ 375.0, 375.0, 375.0, 375.0, 250.0, 125.0, 0.0 },{ 375.0, 375.0, 375.0, 375.0, 250.0, 125.0, 0.0 },{ 375.0, 375.0, 375.0, 375.0, 250.0, 125.0, 0.0 },{ 375.0, 375.0, 375.0, 375.0, 250.0, 125.0, 0.0 },}, }, /* MaxRegenPwr_10s_TableMap */ 
     {7, {{ 50.0, 50.0, 50.0, 50.0, 50.0, 20.0, 0.0 },{ 100.0, 100.0, 100.0, 100.0, 100.0, 50.0, 0.0 },{ 200.0, 200.0, 200.0, 200.0, 150.0, 50.0, 0.0 },{ 300.0, 300.0, 300.0, 300.0, 200.0, 50.0, 0.0 },{ 300.0, 300.0, 300.0, 300.0, 200.0, 80.0, 0.0 },{ 300.0, 300.0, 300.0, 300.0, 200.0, 100.0, 0.0 },{ 300.0, 300.0, 300.0, 300.0, 200.0, 100.0, 0.0 },{ 300.0, 300.0, 300.0, 300.0, 200.0, 100.0, 0.0 },{ 300.0, 300.0, 300.0, 300.0, 200.0, 100.0, 0.0 },{ 300.0, 300.0, 300.0, 300.0, 200.0, 100.0, 0.0 },{ 300.0, 300.0, 300.0, 300.0, 200.0, 100.0, 0.0 },}, }, /* MaxRegenPwr_Cont_TableMap */ 
    
};    
#include <Pragma_Section_End_rodata.h>
    
    
  
/*---- SERIAL EEPROM VARIABLES ----------------------------------------------------------------------------*/


/* Uninitialised EE Variables */
#include <Pragma_Section_Start_bss_ee_bss_engcode.h>
NonVolatile_T NonVolatileStorage __SECTION_BSS_EEBSSENGCODE__;
#include <Pragma_Section_End_bss.h>
    

/* Initialised EE Variables */
#include <Pragma_Section_Start_data_ee_data_engcode.h>
    
uint8_T IsFirstApplicationBoot __SECTION_DATA_EEDATAENGCODE__= 0xFF;
    
/* Name: NonVolatileRestoreOnStartup ClassID:ENUMVAR StorageID:FLASH Access:RW4+RW3+RW2+RW1 TypeID:UINT1 CType:uint8_T
Struct:NonVolatileRestoreOnStartup  Mask:FFFFFFFF Gain:1.0 Offset:0.0 Exp:1.0 Min:0 Max:1 Format:1.0
EnumDec:E_NVRestore UpdateID:BACKGND Group:"System | NonVolatile Storage | NonVolatile Storage Config"
Help:"Selects whether to restore from factory defaults on next startup" */
uint8_T NonVolatileRestoreOnStartup __SECTION_DATA_EEDATAENGCODE__ = 0; /* defaults to restore from eeprom */

/* Name: NonVolatileRestoreOnFirstStartup ClassID:ENUMVAR StorageID:FLASH Access:RW4+RW3+RW2+RW1 TypeID:UINT1 CType:uint8_T
Struct:NonVolatileRestoreOnFirstStartup  Mask:FFFFFFFF Gain:1.0 Offset:0.0 Exp:1.0 Min:0 Max:1 Format:1.0
EnumDec:E_NVRestore UpdateID:BACKGND Group:"System | NonVolatile Storage | NonVolatile Storage Config"
Help:"Selects whether to restore from factory defaults the first time an application boots" */
uint8_T NonVolatileRestoreOnFirstStartup __SECTION_DATA_EEDATAENGCODE__ = 1;

#include <Pragma_Section_End_data.h>
        

    
/*---- RAM VARIABLES --------------------------------------------------------------------------------------*/
#include <Pragma_Section_End_data.h>
#include <Pragma_Section_End_bss.h>


        
/*---- RAM VARIABLES --------------------------------------------------------------------------------------*/
#include <Pragma_Section_Start_ramcals_bss.h>

NonVolatile_T NonVolatileWork __SECTION_RAMCALS_BSS__;

#include <Pragma_Section_End_bss.h>


/*---- CODE SPACE -----------------------------------------------------------------------------------------*/
#include <Pragma_Section_Start_text_code.h>
#include <Pragma_Section_End_data.h>
#include <Pragma_Section_End_bss.h>
            
/* Name: NonVolatileFormatID ClassID:VAR StorageID:RAM Access:RO4+RO3+RO2+RO1 TypeID:UINT4 CType:NonVolatile_T Struct:NonVolatileWork.NonVolatileFormatID
Mask:FFFFFFFF Gain:1.0 Offset:0.0 Exp:1.0 Min:0 Max:4294967295 Format:8.0 UpdateID:BACKGND Group:"System | NonVolatile Storage"
Help:"Unique identifier of the NonVolatile memory format.  Used to validate whether stored variables are in the correct form for the program" */

/* Name: NonVolatileStatus ClassID:ENUMVAR StorageID:RAM Access:RO4+RO3+RO2+RO1 TypeID:UINT1 CType:uint8_T Struct:NonVolatile_NonVolatileStatus 
Mask:FFFFFFFF Gain:1.0 Offset:0.0 Exp:1.0 Min:0 Max:6 Format:1.0 UpdateID:BACKGND
Group:"System | NonVolatile Storage" Help:"Indicates how NonVolatile memory was loaded"  EnumDec:E_NVStatus */
uint8_T NonVolatile_NonVolatileStatus
= 0;
void NonVolatile_NonVolatileStatus_Reset(void)
{
    NonVolatile_NonVolatileStatus_DataStore()=NV_LOADED_FACTORY_USER_CMD;
}
    
/* Name: NonVolatileCRC ClassID:VAR StorageID:RAM Access:RO4+RO3+RO2+RO1 TypeID:UINT4 CType:uint32_T Struct:NonVolatile_NonVolatileCRC  
Mask:FFFFFFFF Gain:1.0 Offset:0.0 Exp:1.0 Min:0 Max:65535 Format:1.0 UpdateID:BACKGND 
Group:"System | NonVolatile Storage" Help:"Calculated NonVolatile CRC" */
uint32_T NonVolatile_NonVolatileCRC = 0;



/*---- CODE SPACE -----------------------------------------------------------------------------------------*/
#include <Pragma_Section_End_data.h>
#include <Pragma_Section_End_bss.h>

     
    
uint16_T calculate_crc(void *pointer, uint32_T number_bytes, uint16_T icrc)
{
    uint32_T bitmask;
    uint32_T mdx;
    uint8_T *pointer1 = (uint8_T *) pointer;
    
    for(mdx=0; mdx < number_bytes; mdx++) 
    {
        bitmask = 1 << 7;
        do 
        {
            if ( !(icrc & 0x8000) ^ !(*pointer1 & bitmask)) 
            {
                icrc <<= 1;
                icrc ^= 0x8005;
            }
            else 
            {
                icrc <<= 1;
            }
        } while ( bitmask >>= 1);
        pointer1++;
    }
    return icrc;
}
void NonVolatile_RestoreDefaultNonVolatile(void)
{
    uint16_T crc = 0xFFFF;
    DISABLE();

    MemReadSynch(&NonVolatileWork, &NonVolatileDefault, sizeof(NonVolatile_T));

    
    
    crc = calculate_crc((uint8_T *)&NonVolatileWork + NON_VOLATILE_OVERHEAD_BYTES, sizeof(NonVolatile_T) - NON_VOLATILE_OVERHEAD_BYTES, crc);
    
    
        
    NonVolatileWork.crc = crc;
    NonVolatile_NonVolatileCRC = NonVolatileWork.crc;
    
    UNDISABLE();
}
void NonVolatile_StoreNonVolatile(void)
{
    extern uint16_T calculate_crc(void *pointer1, uint32_T number_bytes, uint16_T icrc);
    uint16_T icrc = 0xFFFFu;
    uint32_T *work_ptr = (uint32_T *) &NonVolatileWork;
    uint32_T * storage_ptr = (uint32_T *) &NonVolatileStorage;
    uint32_T word_count = sizeof(NonVolatile_T) / 4 - NON_VOLATILE_OVERHEAD_BYTES / 4;
    uint32_T final_byte_count = sizeof(NonVolatile_T) % 4;
    uint32_T tmp_word;
    static uint32_T tmp_word2;
    uint8_T oldStatus = NonVolatile_NonVolatileStatus;
    uint32_T i;
    
    NonVolatile_NonVolatileStatus = NV_STORING_EEPROM;
    
    work_ptr += NON_VOLATILE_OVERHEAD_BYTES / 4;
    storage_ptr += NON_VOLATILE_OVERHEAD_BYTES / 4;
    for (i=0; i < word_count; i++)
    {
        DISABLE();
        tmp_word = *work_ptr;
        UNDISABLE();
        MemReadSynch(&tmp_word2, storage_ptr, sizeof(tmp_word2));
        if (tmp_word != tmp_word2) {
            MemWriteSynch(storage_ptr, &tmp_word, sizeof(tmp_word));
        }
        icrc = calculate_crc(&tmp_word, sizeof(tmp_word), icrc);
        work_ptr++;
        storage_ptr++;
    }
    if (final_byte_count > 0)
    {
        DISABLE();
        tmp_word = *work_ptr;
        UNDISABLE();
        MemReadSynch(&tmp_word2, storage_ptr, final_byte_count);
        if (tmp_word != tmp_word2) {
            MemWriteSynch(storage_ptr, &tmp_word, final_byte_count);
        }
        icrc = calculate_crc(&tmp_word, final_byte_count, icrc);
    }
    
    NonVolatile_NonVolatileCRC = icrc;
    
    MemWriteSynch(&NonVolatileStorage.NonVolatileFormatID, &NonVolatileDefault.NonVolatileFormatID, sizeof(NonVolatileWork.NonVolatileFormatID));
    MemWriteSynch(&NonVolatileStorage.crc, &NonVolatile_NonVolatileCRC, sizeof(NonVolatile_NonVolatileCRC));
    
    NonVolatile_NonVolatileStatus = oldStatus;
    
}
void NonVolatile_OpenNonVolatile(void)
{
    uint32_T storedNonVolatileFormatID = 0;
    uint8_T firstApplicationBoot = 0;
    uint8_T restoreFactoryDefaults = 0;
    uint8_T restoreFactoryDefaultsFirstBoot = 0;
    
    MemReadSynch(&firstApplicationBoot, &IsFirstApplicationBoot, sizeof(IsFirstApplicationBoot));
    MemReadSynch(&restoreFactoryDefaults, &NonVolatileRestoreOnStartup, sizeof(NonVolatileRestoreOnStartup));
    MemReadSynch(&restoreFactoryDefaultsFirstBoot,&NonVolatileRestoreOnFirstStartup, sizeof(NonVolatileRestoreOnFirstStartup));
    MemReadSynch(&storedNonVolatileFormatID,&(NonVolatileStorage.NonVolatileFormatID),sizeof(NonVolatileStorage.NonVolatileFormatID));
    
    if ((firstApplicationBoot && restoreFactoryDefaultsFirstBoot) || restoreFactoryDefaults)
    {
        NonVolatile_NonVolatileStatus = NV_LOADING_FACTORY;
        NonVolatile_RestoreDefaultNonVolatile();
        
        restoreFactoryDefaults = 0;
        MemWriteSynch(&NonVolatileRestoreOnStartup, &restoreFactoryDefaults,sizeof(NonVolatileRestoreOnStartup));
        
        NonVolatile_NonVolatileStatus = NV_LOADED_FACTORY_USER_CMD;
    }
    else if (storedNonVolatileFormatID != NonVolatileDefault.NonVolatileFormatID)
    {
        NonVolatile_NonVolatileStatus = NV_LOADING_FACTORY;
        NonVolatile_RestoreDefaultNonVolatile();
        NonVolatile_NonVolatileStatus = NV_LOADED_FACTORY_BAD_MAGIC;
    }
    else
    {
        extern uint16_T calculate_crc(void *pointer1, uint32_T number_bytes,
        uint16_T icrc);
        uint16_T icrc = 0xFFFFu;
        uint32_T *work_ptr = (uint32_T *) &NonVolatileWork;
        uint32_T * storage_ptr = (uint32_T *) &NonVolatileStorage;
        uint32_T word_count = sizeof(NonVolatile_T) / 4 - NON_VOLATILE_OVERHEAD_BYTES / 4;
        uint32_T final_byte_count = sizeof(NonVolatile_T) % 4;
        uint32_T tmp_word;
        uint32_T i;
        
        NonVolatile_NonVolatileStatus = NV_LOADING_EEPROM;
    
        work_ptr += NON_VOLATILE_OVERHEAD_BYTES / 4;
        storage_ptr += NON_VOLATILE_OVERHEAD_BYTES / 4;
        for (i=0; i < word_count; i++)
        {
            MemReadSynch(&tmp_word, storage_ptr, sizeof(tmp_word));
            DISABLE();
            *work_ptr = tmp_word;
            UNDISABLE();
            icrc = calculate_crc(&tmp_word, sizeof(tmp_word), icrc);
            work_ptr++;
            storage_ptr++;
        }
        if (final_byte_count > 0)
        {
            MemReadSynch(&tmp_word, storage_ptr, final_byte_count);
            DISABLE();
            *work_ptr = tmp_word;
            UNDISABLE();
            icrc = calculate_crc(&tmp_word, final_byte_count, icrc);
        }
    
        
        NonVolatile_NonVolatileCRC = icrc;
    
        MemReadSynch(&NonVolatileWork.crc, &(NonVolatileStorage.crc), sizeof(NonVolatileStorage.crc));
    
        if(NonVolatile_NonVolatileCRC != NonVolatileWork.crc)
        {
            NonVolatile_NonVolatileStatus = NV_LOADING_FACTORY;
            NonVolatile_RestoreDefaultNonVolatile();
            NonVolatile_NonVolatileStatus = NV_LOADED_FACTORY_BAD_CRC;
        }
        else
        {
            NonVolatileWork.NonVolatileFormatID = storedNonVolatileFormatID;
            NonVolatile_NonVolatileStatus = NV_LOADED_EEPROM;
        }
    }
    
    if (firstApplicationBoot)
    {
        firstApplicationBoot = 0;
        MemWriteSynch(&IsFirstApplicationBoot, &firstApplicationBoot, sizeof(IsFirstApplicationBoot));
    }
}

