
/* MotoCoder_DataStore.c */
/* Generated by MotoCoder */
/* Version: 0.12.4 */
/* At: 2019-02-28 16:20:22 */
/* Copyright: 2019 Woodward. */


#include <MotoCoder_DataStore.h>

/* DataStore */
/*---- DEFINES --------------------------------------------------------------------------------------------*/
#define rtInf                           (100000000000000000.000000)
#define rtMinusInf                      (-100000000000000000.000000)
  
/*---- TYPEDEFN -------------------------------------------------------------------------------------------*/

/*---- CONSTANTS ------------------------------------------------------------------------------------------*/

        
     

#include <Pragma_Section_Start_romcals_rodata.h>
        
const NonVolatile_T NonVolatileDefault __SECTION_ROMCALS_RODATA__ =  
{
    
         (42578U), /* NonVolatileFormatID */
        0x0000,  /* crc */    
    0.0, /* Auto_Battery_Startup */ 
    1.0, /* Batt_Ign_Cal */ 
    1.0, /* Batt_Isolation_det_Cal */ 
    1.0, /* Battery_Connect_Val */ 
    1.0, /* SOC_Load_Dump */ 
    0, /* MotoHawkModelSecondsInUse */ 
    5U, /* VDO_Gauge_Brightness */ 
    12, /* CityID_CAN_1 */ 
    1, /* Automatic_Battery_Bootup */ 
    
};

#include <Pragma_Section_End_rodata.h>
    


#include <Pragma_Section_End_rodata.h>
Volatile_BSS_T VolatileWork_BSS
; 


#include <Pragma_Section_Start_cals_rodata.h>
    
const Constant_T ConstantWork __SECTION_CALS_RODATA__ =
    {
    0.5, /* Contactor_Disable_Delay */ 
    2.0, /* Load_Enable_Delay */ 
    80.0, /* SOC_Off_Pt */ 
    2.0, /* VDO_Gauge_StartupDelay */ 
    0.0, /* Vehicle_Speed */ 
    100U, /* ECUP_Threshold */ 
    RES_AN5M, /* ACC1 */ 
    8, /* ACC1_Out */ 
    RES_AN9M, /* ACC2 */ 
    7, /* ACC2_Out */ 
    RES_AN1M, /* BatteryEnable */ 
    14, /* Battery_Enable */ 
    13, /* COIL_Neg */ 
    12, /* COIL_Pos */ 
    RES_AN3M, /* GensetEnable */ 
    RES_AN4M, /* GensetLoad */ 
    9, /* Genset_Enable */ 
    0, /* Genset_Load */ 
    RES_AN2M, /* LoadDumpEnable */ 
    15, /* Load_Dump_Enable */ 
    
};    
#include <Pragma_Section_End_rodata.h>
    
    
  
/*---- SERIAL EEPROM VARIABLES ----------------------------------------------------------------------------*/


/* Uninitialised EE Variables */
#include <Pragma_Section_Start_bss_ee_bss_engcode.h>
NonVolatile_T NonVolatileStorage __SECTION_BSS_EEBSSENGCODE__;
#include <Pragma_Section_End_bss.h>
    

/* Initialised EE Variables */
#include <Pragma_Section_Start_data_ee_data_engcode.h>
    
uint8_T IsFirstApplicationBoot __SECTION_DATA_EEDATAENGCODE__= 0xFF;
    
/* Name: NonVolatileRestoreOnStartup ClassID:ENUMVAR StorageID:FLASH Access:RW4+RW3+RW2+RW1 TypeID:UINT1 CType:uint8_T
Struct:NonVolatileRestoreOnStartup  Mask:FFFFFFFF Gain:1.0 Offset:0.0 Exp:1.0 Min:0 Max:1 Format:1.0
EnumDec:E_NVRestore UpdateID:BACKGND Group:"System | NonVolatile Storage | NonVolatile Storage Config"
Help:"Selects whether to restore from factory defaults on next startup" */
uint8_T NonVolatileRestoreOnStartup __SECTION_DATA_EEDATAENGCODE__ = 0; /* defaults to restore from eeprom */

/* Name: NonVolatileRestoreOnFirstStartup ClassID:ENUMVAR StorageID:FLASH Access:RW4+RW3+RW2+RW1 TypeID:UINT1 CType:uint8_T
Struct:NonVolatileRestoreOnFirstStartup  Mask:FFFFFFFF Gain:1.0 Offset:0.0 Exp:1.0 Min:0 Max:1 Format:1.0
EnumDec:E_NVRestore UpdateID:BACKGND Group:"System | NonVolatile Storage | NonVolatile Storage Config"
Help:"Selects whether to restore from factory defaults the first time an application boots" */
uint8_T NonVolatileRestoreOnFirstStartup __SECTION_DATA_EEDATAENGCODE__ = 1;

#include <Pragma_Section_End_data.h>
        

    
/*---- RAM VARIABLES --------------------------------------------------------------------------------------*/
#include <Pragma_Section_End_data.h>
#include <Pragma_Section_End_bss.h>


        
/*---- RAM VARIABLES --------------------------------------------------------------------------------------*/
#include <Pragma_Section_Start_ramcals_bss.h>

NonVolatile_T NonVolatileWork __SECTION_RAMCALS_BSS__;

#include <Pragma_Section_End_bss.h>


/*---- CODE SPACE -----------------------------------------------------------------------------------------*/
#include <Pragma_Section_Start_text_code.h>
#include <Pragma_Section_End_data.h>
#include <Pragma_Section_End_bss.h>
            
/* Name: NonVolatileFormatID ClassID:VAR StorageID:RAM Access:RO4+RO3+RO2+RO1 TypeID:UINT4 CType:NonVolatile_T Struct:NonVolatileWork.NonVolatileFormatID
Mask:FFFFFFFF Gain:1.0 Offset:0.0 Exp:1.0 Min:0 Max:4294967295 Format:8.0 UpdateID:BACKGND Group:"System | NonVolatile Storage"
Help:"Unique identifier of the NonVolatile memory format.  Used to validate whether stored variables are in the correct form for the program" */

/* Name: NonVolatileStatus ClassID:ENUMVAR StorageID:RAM Access:RO4+RO3+RO2+RO1 TypeID:UINT1 CType:uint8_T Struct:NonVolatile_NonVolatileStatus 
Mask:FFFFFFFF Gain:1.0 Offset:0.0 Exp:1.0 Min:0 Max:6 Format:1.0 UpdateID:BACKGND
Group:"System | NonVolatile Storage" Help:"Indicates how NonVolatile memory was loaded"  EnumDec:E_NVStatus */
uint8_T NonVolatile_NonVolatileStatus
= 0;
void NonVolatile_NonVolatileStatus_Reset(void)
{
    NonVolatile_NonVolatileStatus_DataStore()=NV_LOADED_FACTORY_USER_CMD;
}
    
/* Name: NonVolatileCRC ClassID:VAR StorageID:RAM Access:RO4+RO3+RO2+RO1 TypeID:UINT4 CType:uint32_T Struct:NonVolatile_NonVolatileCRC  
Mask:FFFFFFFF Gain:1.0 Offset:0.0 Exp:1.0 Min:0 Max:65535 Format:1.0 UpdateID:BACKGND 
Group:"System | NonVolatile Storage" Help:"Calculated NonVolatile CRC" */
uint32_T NonVolatile_NonVolatileCRC = 0;



/*---- CODE SPACE -----------------------------------------------------------------------------------------*/
#include <Pragma_Section_End_data.h>
#include <Pragma_Section_End_bss.h>

     
    
uint16_T calculate_crc(void *pointer, uint32_T number_bytes, uint16_T icrc)
{
    uint32_T bitmask;
    uint32_T mdx;
    uint8_T *pointer1 = (uint8_T *) pointer;
    
    for(mdx=0; mdx < number_bytes; mdx++) 
    {
        bitmask = 1 << 7;
        do 
        {
            if ( !(icrc & 0x8000) ^ !(*pointer1 & bitmask)) 
            {
                icrc <<= 1;
                icrc ^= 0x8005;
            }
            else 
            {
                icrc <<= 1;
            }
        } while ( bitmask >>= 1);
        pointer1++;
    }
    return icrc;
}
void NonVolatile_RestoreDefaultNonVolatile(void)
{
    uint16_T crc = 0xFFFF;
    DISABLE();

    MemReadSynch(&NonVolatileWork, &NonVolatileDefault, sizeof(NonVolatile_T));

    
    
    crc = calculate_crc((uint8_T *)&NonVolatileWork + NON_VOLATILE_OVERHEAD_BYTES, sizeof(NonVolatile_T) - NON_VOLATILE_OVERHEAD_BYTES, crc);
    
    
        
    NonVolatileWork.crc = crc;
    NonVolatile_NonVolatileCRC = NonVolatileWork.crc;
    
    UNDISABLE();
}
void NonVolatile_StoreNonVolatile(void)
{
    extern uint16_T calculate_crc(void *pointer1, uint32_T number_bytes, uint16_T icrc);
    uint16_T icrc = 0xFFFFu;
    uint32_T *work_ptr = (uint32_T *) &NonVolatileWork;
    uint32_T * storage_ptr = (uint32_T *) &NonVolatileStorage;
    uint32_T word_count = sizeof(NonVolatile_T) / 4 - NON_VOLATILE_OVERHEAD_BYTES / 4;
    uint32_T final_byte_count = sizeof(NonVolatile_T) % 4;
    uint32_T tmp_word;
    static uint32_T tmp_word2;
    uint8_T oldStatus = NonVolatile_NonVolatileStatus;
    uint32_T i;
    
    NonVolatile_NonVolatileStatus = NV_STORING_EEPROM;
    
    work_ptr += NON_VOLATILE_OVERHEAD_BYTES / 4;
    storage_ptr += NON_VOLATILE_OVERHEAD_BYTES / 4;
    for (i=0; i < word_count; i++)
    {
        DISABLE();
        tmp_word = *work_ptr;
        UNDISABLE();
        MemReadSynch(&tmp_word2, storage_ptr, sizeof(tmp_word2));
        if (tmp_word != tmp_word2) {
            MemWriteSynch(storage_ptr, &tmp_word, sizeof(tmp_word));
        }
        icrc = calculate_crc(&tmp_word, sizeof(tmp_word), icrc);
        work_ptr++;
        storage_ptr++;
    }
    if (final_byte_count > 0)
    {
        DISABLE();
        tmp_word = *work_ptr;
        UNDISABLE();
        MemReadSynch(&tmp_word2, storage_ptr, final_byte_count);
        if (tmp_word != tmp_word2) {
            MemWriteSynch(storage_ptr, &tmp_word, final_byte_count);
        }
        icrc = calculate_crc(&tmp_word, final_byte_count, icrc);
    }
    
    NonVolatile_NonVolatileCRC = icrc;
    
    MemWriteSynch(&NonVolatileStorage.NonVolatileFormatID, &NonVolatileDefault.NonVolatileFormatID, sizeof(NonVolatileWork.NonVolatileFormatID));
    MemWriteSynch(&NonVolatileStorage.crc, &NonVolatile_NonVolatileCRC, sizeof(NonVolatile_NonVolatileCRC));
    
    NonVolatile_NonVolatileStatus = oldStatus;
    
}
void NonVolatile_OpenNonVolatile(void)
{
    uint32_T storedNonVolatileFormatID = 0;
    uint8_T firstApplicationBoot = 0;
    uint8_T restoreFactoryDefaults = 0;
    uint8_T restoreFactoryDefaultsFirstBoot = 0;
    
    MemReadSynch(&firstApplicationBoot, &IsFirstApplicationBoot, sizeof(IsFirstApplicationBoot));
    MemReadSynch(&restoreFactoryDefaults, &NonVolatileRestoreOnStartup, sizeof(NonVolatileRestoreOnStartup));
    MemReadSynch(&restoreFactoryDefaultsFirstBoot,&NonVolatileRestoreOnFirstStartup, sizeof(NonVolatileRestoreOnFirstStartup));
    MemReadSynch(&storedNonVolatileFormatID,&(NonVolatileStorage.NonVolatileFormatID),sizeof(NonVolatileStorage.NonVolatileFormatID));
    
    if ((firstApplicationBoot && restoreFactoryDefaultsFirstBoot) || restoreFactoryDefaults)
    {
        NonVolatile_NonVolatileStatus = NV_LOADING_FACTORY;
        NonVolatile_RestoreDefaultNonVolatile();
        
        restoreFactoryDefaults = 0;
        MemWriteSynch(&NonVolatileRestoreOnStartup, &restoreFactoryDefaults,sizeof(NonVolatileRestoreOnStartup));
        
        NonVolatile_NonVolatileStatus = NV_LOADED_FACTORY_USER_CMD;
    }
    else if (storedNonVolatileFormatID != NonVolatileDefault.NonVolatileFormatID)
    {
        NonVolatile_NonVolatileStatus = NV_LOADING_FACTORY;
        NonVolatile_RestoreDefaultNonVolatile();
        NonVolatile_NonVolatileStatus = NV_LOADED_FACTORY_BAD_MAGIC;
    }
    else
    {
        extern uint16_T calculate_crc(void *pointer1, uint32_T number_bytes,
        uint16_T icrc);
        uint16_T icrc = 0xFFFFu;
        uint32_T *work_ptr = (uint32_T *) &NonVolatileWork;
        uint32_T * storage_ptr = (uint32_T *) &NonVolatileStorage;
        uint32_T word_count = sizeof(NonVolatile_T) / 4 - NON_VOLATILE_OVERHEAD_BYTES / 4;
        uint32_T final_byte_count = sizeof(NonVolatile_T) % 4;
        uint32_T tmp_word;
        uint32_T i;
        
        NonVolatile_NonVolatileStatus = NV_LOADING_EEPROM;
    
        work_ptr += NON_VOLATILE_OVERHEAD_BYTES / 4;
        storage_ptr += NON_VOLATILE_OVERHEAD_BYTES / 4;
        for (i=0; i < word_count; i++)
        {
            MemReadSynch(&tmp_word, storage_ptr, sizeof(tmp_word));
            DISABLE();
            *work_ptr = tmp_word;
            UNDISABLE();
            icrc = calculate_crc(&tmp_word, sizeof(tmp_word), icrc);
            work_ptr++;
            storage_ptr++;
        }
        if (final_byte_count > 0)
        {
            MemReadSynch(&tmp_word, storage_ptr, final_byte_count);
            DISABLE();
            *work_ptr = tmp_word;
            UNDISABLE();
            icrc = calculate_crc(&tmp_word, final_byte_count, icrc);
        }
    
        
        NonVolatile_NonVolatileCRC = icrc;
    
        MemReadSynch(&NonVolatileWork.crc, &(NonVolatileStorage.crc), sizeof(NonVolatileStorage.crc));
    
        if(NonVolatile_NonVolatileCRC != NonVolatileWork.crc)
        {
            NonVolatile_NonVolatileStatus = NV_LOADING_FACTORY;
            NonVolatile_RestoreDefaultNonVolatile();
            NonVolatile_NonVolatileStatus = NV_LOADED_FACTORY_BAD_CRC;
        }
        else
        {
            NonVolatileWork.NonVolatileFormatID = storedNonVolatileFormatID;
            NonVolatile_NonVolatileStatus = NV_LOADED_EEPROM;
        }
    }
    
    if (firstApplicationBoot)
    {
        firstApplicationBoot = 0;
        MemWriteSynch(&IsFirstApplicationBoot, &firstApplicationBoot, sizeof(IsFirstApplicationBoot));
    }
}

