
/* MotoCoder_CAN.c */
/* Generated by MotoCoder */
/* Version: 0.12.4 */
/* At: 2017-11-29 16:59:11 */
/* Copyright: 2017 Woodward. */


#include <MotoCoder_Types.h>
#include <FlexCAN2_API.h>
#include <FlexCAN2_Reg.h>
#include <Interrupt_API.h>
#include <TaskKernel_API.h>
#include <TaskKernel_GenAPI.h>
#include <BootMailbox_API.h>
#include <string.h>
#include <MotoCoder_CAN.h>

/* Processor Level CAN Interface and CAN Queue Source Code */
/*---- CAN SETUP --------------------------------------------------------------------------------*/

/* Buffer config object for each distinct buffer callback */

extern void CAN_Tx_Buffer_ISR(S_FlexCAN2ISRInfo const*);
S_FlexCAN2BufferRuntime const g_FlexCANBufferConfig_CAN_Tx_Buffer_ISR = 
{
	(CriticalFlexCAN2ISRFuncPtr) CAN_Tx_Buffer_ISR,
};

extern void CAN_Rx_Buffer_ISR(S_FlexCAN2ISRInfo const*);
S_FlexCAN2BufferRuntime const g_FlexCANBufferConfig_CAN_Rx_Buffer_ISR = 
{
	(CriticalFlexCAN2ISRFuncPtr) CAN_Rx_Buffer_ISR,
};


/* Module config object for each used FlexCAN2 module */

S_FlexCAN2ModuleRuntimeConfig const g_FLEXCAN2_A_ConfigObj =
{
	{
		(S_FlexCAN2BufferRuntime *) &g_FlexCANBufferConfig_CAN_Tx_Buffer_ISR,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		(S_FlexCAN2BufferRuntime *) &g_FlexCANBufferConfig_CAN_Rx_Buffer_ISR,
		(S_FlexCAN2BufferRuntime *) &g_FlexCANBufferConfig_CAN_Rx_Buffer_ISR,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
	},
	NULL,
	NULL,
};


S_FlexCAN2ModuleRuntimeConfig const g_FLEXCAN2_B_ConfigObj =
{
	{
		(S_FlexCAN2BufferRuntime *) &g_FlexCANBufferConfig_CAN_Tx_Buffer_ISR,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		(S_FlexCAN2BufferRuntime *) &g_FlexCANBufferConfig_CAN_Rx_Buffer_ISR,
		(S_FlexCAN2BufferRuntime *) &g_FlexCANBufferConfig_CAN_Rx_Buffer_ISR,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
	},
	NULL,
	NULL,
};


S_FlexCAN2ModuleRuntimeConfig const g_FLEXCAN2_C_ConfigObj =
{
	{
		(S_FlexCAN2BufferRuntime *) &g_FlexCANBufferConfig_CAN_Tx_Buffer_ISR,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		(S_FlexCAN2BufferRuntime *) &g_FlexCANBufferConfig_CAN_Rx_Buffer_ISR,
		(S_FlexCAN2BufferRuntime *) &g_FlexCANBufferConfig_CAN_Rx_Buffer_ISR,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
	},
	NULL,
	NULL,
};



/* Top-level instantiation of FlexCAN2 config object */
S_FlexCAN2RuntimeConfig const g_FlexCAN2RuntimeConfigObj =
{
	{
		&g_FLEXCAN2_A_ConfigObj,
		&g_FLEXCAN2_B_ConfigObj,
		&g_FLEXCAN2_C_ConfigObj,
	},
};

/* Code to setup each FlexCAN2 module at startup */

void FLEXCAN2_A_Create(void)
{	
	S_CreateFlexCAN2Module FlexCAN2CreateObj;
	S_CreateFlexCAN2Buffer BufferCreateObj;
	S_LoadFlexCAN2RXBuffer LoadBufferRXObj;
	
	/* FLEXCAN2_A - 500000 bps */
	FlexCAN2CreateObj.u32RXGMASK = 0x1FFFFFFF;
	FlexCAN2CreateObj.u32RX14MASK = 0x0;
	FlexCAN2CreateObj.u32RX15MASK = 0x0;
	FlexCAN2CreateObj.u8PRESDIV = 1;
	FlexCAN2CreateObj.u8PROPSEG = 2;
	FlexCAN2CreateObj.u8PSEG1 = 1;
	FlexCAN2CreateObj.u8PSEG2 = 1;
	FlexCAN2CreateObj.u8RJW = 0;
	FlexCAN2CreateObj.u8MAXMB = 15;
	FlexCAN2CreateObj.eBusOffIRQPriority = (E_INTCPriority) 11;
	FlexCAN2CreateObj.eErrorIRQPriority = (E_INTCPriority) 12;
	FlexCAN2CreateObj.eBusOffISRState = CR_BOFFMSK_BUS_OFF_IRQ_DISABLED;
	FlexCAN2CreateObj.eErrorISRState = CR_ERRMSK_ERROR_IRQ_DISABLED;
	FlexCAN2CreateObj.eFlexCAN2Module = FLEXCAN2_A;

	Create_FlexCAN2Module(&FlexCAN2CreateObj);
	
	/* Buffer 0 - transmit */
	BufferCreateObj.eFlexCAN2Module = FLEXCAN2_A;
	BufferCreateObj.eFlexCAN2Buffer = (E_FlexCAN2Buffer) 0;
	BufferCreateObj.eBufferIRQPriority = (E_INTCPriority) 4;
	BufferCreateObj.eBufferIRQState = IMR_BUF_BUFFER_IRQ_ENABLED;
	
	Create_FlexCAN2Buffer(&BufferCreateObj);
	
	/* Buffer 14 - receive */
	BufferCreateObj.eFlexCAN2Module = FLEXCAN2_A;
	BufferCreateObj.eFlexCAN2Buffer = (E_FlexCAN2Buffer) 14;
	BufferCreateObj.eBufferIRQPriority = (E_INTCPriority) 5;
	BufferCreateObj.eBufferIRQState = IMR_BUF_BUFFER_IRQ_ENABLED;
	
	Create_FlexCAN2Buffer(&BufferCreateObj);
	
	LoadBufferRXObj.eFlexCAN2Module = FLEXCAN2_A;
	LoadBufferRXObj.eFlexCAN2Buffer = (E_FlexCAN2Buffer) 14;
	LoadBufferRXObj.u32MessageID = 0;
	LoadBufferRXObj.uFlags = CAN_MESSAGE_STANDARD;
	
	Load_FlexCAN2_RXBuffer(&LoadBufferRXObj);
	
	/* Buffer 15 - receive */
	BufferCreateObj.eFlexCAN2Module = FLEXCAN2_A;
	BufferCreateObj.eFlexCAN2Buffer = (E_FlexCAN2Buffer) 15;
	BufferCreateObj.eBufferIRQPriority = (E_INTCPriority) 6;
	BufferCreateObj.eBufferIRQState = IMR_BUF_BUFFER_IRQ_ENABLED;
	
	Create_FlexCAN2Buffer(&BufferCreateObj);
	
	LoadBufferRXObj.eFlexCAN2Module = FLEXCAN2_A;
	LoadBufferRXObj.eFlexCAN2Buffer = (E_FlexCAN2Buffer) 15;
	LoadBufferRXObj.u32MessageID = 0;
	LoadBufferRXObj.uFlags = CAN_MESSAGE_EXTENDED;
	
	Load_FlexCAN2_RXBuffer(&LoadBufferRXObj);
	
}


void FLEXCAN2_B_Create(void)
{	
	S_CreateFlexCAN2Module FlexCAN2CreateObj;
	S_CreateFlexCAN2Buffer BufferCreateObj;
	S_LoadFlexCAN2RXBuffer LoadBufferRXObj;
	
	/* FLEXCAN2_B - 125000 bps */
	FlexCAN2CreateObj.u32RXGMASK = 0x1FFFFFFF;
	FlexCAN2CreateObj.u32RX14MASK = 0x0;
	FlexCAN2CreateObj.u32RX15MASK = 0x0;
	FlexCAN2CreateObj.u8PRESDIV = 7;
	FlexCAN2CreateObj.u8PROPSEG = 2;
	FlexCAN2CreateObj.u8PSEG1 = 1;
	FlexCAN2CreateObj.u8PSEG2 = 1;
	FlexCAN2CreateObj.u8RJW = 1;
	FlexCAN2CreateObj.u8MAXMB = 15;
	FlexCAN2CreateObj.eBusOffIRQPriority = (E_INTCPriority) 11;
	FlexCAN2CreateObj.eErrorIRQPriority = (E_INTCPriority) 12;
	FlexCAN2CreateObj.eBusOffISRState = CR_BOFFMSK_BUS_OFF_IRQ_DISABLED;
	FlexCAN2CreateObj.eErrorISRState = CR_ERRMSK_ERROR_IRQ_DISABLED;
	FlexCAN2CreateObj.eFlexCAN2Module = FLEXCAN2_B;

	Create_FlexCAN2Module(&FlexCAN2CreateObj);
	
	/* Buffer 0 - transmit */
	BufferCreateObj.eFlexCAN2Module = FLEXCAN2_B;
	BufferCreateObj.eFlexCAN2Buffer = (E_FlexCAN2Buffer) 0;
	BufferCreateObj.eBufferIRQPriority = (E_INTCPriority) 4;
	BufferCreateObj.eBufferIRQState = IMR_BUF_BUFFER_IRQ_ENABLED;
	
	Create_FlexCAN2Buffer(&BufferCreateObj);
	
	/* Buffer 14 - receive */
	BufferCreateObj.eFlexCAN2Module = FLEXCAN2_B;
	BufferCreateObj.eFlexCAN2Buffer = (E_FlexCAN2Buffer) 14;
	BufferCreateObj.eBufferIRQPriority = (E_INTCPriority) 5;
	BufferCreateObj.eBufferIRQState = IMR_BUF_BUFFER_IRQ_ENABLED;
	
	Create_FlexCAN2Buffer(&BufferCreateObj);
	
	LoadBufferRXObj.eFlexCAN2Module = FLEXCAN2_B;
	LoadBufferRXObj.eFlexCAN2Buffer = (E_FlexCAN2Buffer) 14;
	LoadBufferRXObj.u32MessageID = 0;
	LoadBufferRXObj.uFlags = CAN_MESSAGE_STANDARD;
	
	Load_FlexCAN2_RXBuffer(&LoadBufferRXObj);
	
	/* Buffer 15 - receive */
	BufferCreateObj.eFlexCAN2Module = FLEXCAN2_B;
	BufferCreateObj.eFlexCAN2Buffer = (E_FlexCAN2Buffer) 15;
	BufferCreateObj.eBufferIRQPriority = (E_INTCPriority) 6;
	BufferCreateObj.eBufferIRQState = IMR_BUF_BUFFER_IRQ_ENABLED;
	
	Create_FlexCAN2Buffer(&BufferCreateObj);
	
	LoadBufferRXObj.eFlexCAN2Module = FLEXCAN2_B;
	LoadBufferRXObj.eFlexCAN2Buffer = (E_FlexCAN2Buffer) 15;
	LoadBufferRXObj.u32MessageID = 0;
	LoadBufferRXObj.uFlags = CAN_MESSAGE_EXTENDED;
	
	Load_FlexCAN2_RXBuffer(&LoadBufferRXObj);
	
}


void FLEXCAN2_C_Create(void)
{	
	S_CreateFlexCAN2Module FlexCAN2CreateObj;
	S_CreateFlexCAN2Buffer BufferCreateObj;
	S_LoadFlexCAN2RXBuffer LoadBufferRXObj;
	
	/* FLEXCAN2_C - 500000 bps */
	FlexCAN2CreateObj.u32RXGMASK = 0x1FFFFFFF;
	FlexCAN2CreateObj.u32RX14MASK = 0x0;
	FlexCAN2CreateObj.u32RX15MASK = 0x0;
	FlexCAN2CreateObj.u8PRESDIV = 1;
	FlexCAN2CreateObj.u8PROPSEG = 2;
	FlexCAN2CreateObj.u8PSEG1 = 1;
	FlexCAN2CreateObj.u8PSEG2 = 1;
	FlexCAN2CreateObj.u8RJW = 0;
	FlexCAN2CreateObj.u8MAXMB = 15;
	FlexCAN2CreateObj.eBusOffIRQPriority = (E_INTCPriority) 11;
	FlexCAN2CreateObj.eErrorIRQPriority = (E_INTCPriority) 12;
	FlexCAN2CreateObj.eBusOffISRState = CR_BOFFMSK_BUS_OFF_IRQ_DISABLED;
	FlexCAN2CreateObj.eErrorISRState = CR_ERRMSK_ERROR_IRQ_DISABLED;
	FlexCAN2CreateObj.eFlexCAN2Module = FLEXCAN2_C;

	Create_FlexCAN2Module(&FlexCAN2CreateObj);
	
	/* Buffer 0 - transmit */
	BufferCreateObj.eFlexCAN2Module = FLEXCAN2_C;
	BufferCreateObj.eFlexCAN2Buffer = (E_FlexCAN2Buffer) 0;
	BufferCreateObj.eBufferIRQPriority = (E_INTCPriority) 4;
	BufferCreateObj.eBufferIRQState = IMR_BUF_BUFFER_IRQ_ENABLED;
	
	Create_FlexCAN2Buffer(&BufferCreateObj);
	
	/* Buffer 14 - receive */
	BufferCreateObj.eFlexCAN2Module = FLEXCAN2_C;
	BufferCreateObj.eFlexCAN2Buffer = (E_FlexCAN2Buffer) 14;
	BufferCreateObj.eBufferIRQPriority = (E_INTCPriority) 5;
	BufferCreateObj.eBufferIRQState = IMR_BUF_BUFFER_IRQ_ENABLED;
	
	Create_FlexCAN2Buffer(&BufferCreateObj);
	
	LoadBufferRXObj.eFlexCAN2Module = FLEXCAN2_C;
	LoadBufferRXObj.eFlexCAN2Buffer = (E_FlexCAN2Buffer) 14;
	LoadBufferRXObj.u32MessageID = 0;
	LoadBufferRXObj.uFlags = CAN_MESSAGE_STANDARD;
	
	Load_FlexCAN2_RXBuffer(&LoadBufferRXObj);
	
	/* Buffer 15 - receive */
	BufferCreateObj.eFlexCAN2Module = FLEXCAN2_C;
	BufferCreateObj.eFlexCAN2Buffer = (E_FlexCAN2Buffer) 15;
	BufferCreateObj.eBufferIRQPriority = (E_INTCPriority) 6;
	BufferCreateObj.eBufferIRQState = IMR_BUF_BUFFER_IRQ_ENABLED;
	
	Create_FlexCAN2Buffer(&BufferCreateObj);
	
	LoadBufferRXObj.eFlexCAN2Module = FLEXCAN2_C;
	LoadBufferRXObj.eFlexCAN2Buffer = (E_FlexCAN2Buffer) 15;
	LoadBufferRXObj.u32MessageID = 0;
	LoadBufferRXObj.uFlags = CAN_MESSAGE_EXTENDED;
	
	Load_FlexCAN2_RXBuffer(&LoadBufferRXObj);
	
}




/* Code to setup CAN for jump to hard-boot */
void CAN_FillMotoTronBootObj(S_MotoTronBootObj_V3* const bootObj, uint8_T bus)
{
	switch (bus)
	{
	
		case FLEXCAN2_A:
            			bootObj->uAllowConnectOnCANMask = 1 << FLEXCAN2_A;
			bootObj->CANBusParams.u1PresDiv = 1;
			bootObj->CANBusParams.u1PropSeg = 2;
			bootObj->CANBusParams.u1PhaseSeg1 = 1;
			bootObj->CANBusParams.u1PhaseSeg2 = 1;
			bootObj->CANBusParams.u1RJW = 0;
		break;
		 
		case FLEXCAN2_B:
            			bootObj->uAllowConnectOnCANMask = 1 << FLEXCAN2_B;
			bootObj->CANBusParams.u1PresDiv = 7;
			bootObj->CANBusParams.u1PropSeg = 2;
			bootObj->CANBusParams.u1PhaseSeg1 = 1;
			bootObj->CANBusParams.u1PhaseSeg2 = 1;
			bootObj->CANBusParams.u1RJW = 1;
		break;
		 
		case FLEXCAN2_C:
            			bootObj->uAllowConnectOnCANMask = 1 << FLEXCAN2_C;
			bootObj->CANBusParams.u1PresDiv = 1;
			bootObj->CANBusParams.u1PropSeg = 2;
			bootObj->CANBusParams.u1PhaseSeg1 = 1;
			bootObj->CANBusParams.u1PhaseSeg2 = 1;
			bootObj->CANBusParams.u1RJW = 0;
		break;
		
	}
}







/* Load actual transmit hardware buffer */
boolean_T CAN_LoadTransmitBuffer(E_FlexCAN2Module module, boolean_T extended, uint32_T id, uint8_T length, const uint8_T data[])
{
	S_LoadFlexCAN2TXBuffer txBuffer;
	NativeError_S sError;
	int32_T i;
	
	if (length > 8)
		length = 8;

	txBuffer.u32MessageID = id;
	txBuffer.u8Length = length;
	txBuffer.uFlags = (extended) ? CAN_MESSAGE_EXTENDED : CAN_MESSAGE_STANDARD;

	for (i=0; i < length; i++) {
		txBuffer.u8DataArr[i] = data[i];
	}
	while (i < 8) {
		txBuffer.u8DataArr[i] = 0;
		i++;
	}

	txBuffer.eFlexCAN2Module = module;
	txBuffer.eFlexCAN2Buffer = (E_FlexCAN2Buffer) 0;

	sError = Load_FlexCAN2_TXBuffer(&txBuffer);
	return SUCCESS(sError);
}




/* Code to implement CANFrame queue */

typedef struct CANFrame_tag
{
	uint32_T id;
	boolean_T extended;
	uint8_T length;
	uint8_T data[8];
} CANFrame;

typedef struct CANFrame_Queue_tag
{
	CANFrame *data;
	uint32_T size;
	uint32_T head;
	uint32_T tail;
} CANFrame_Queue;

void CANFrame_Queue_Create(CANFrame_Queue *queue, CANFrame data[], uint32_T size)
{
	queue->data = data;
	queue->size = size;
	queue->head = 0;
	queue->tail = 0;
}

int32_T CANFrame_Queue_Depth(CANFrame_Queue *queue)
{
	int32_T depth;

	Interrupt_Disable();
	depth = queue->head - queue->tail;
	Interrupt_Enable();

	while (depth < 0) {
		depth += queue->size;
	}

	return depth;
}

boolean_T CANFrame_Queue_Enqueue(CANFrame_Queue *queue, CANFrame *frame)
{
	CANFrame *queuedFrame;
	int32_T depth;

	Interrupt_Disable();
	depth = CANFrame_Queue_Depth(queue);
	if ((depth + 1) >= queue->size) {
		Interrupt_Enable();
		return 0;
	}

	queuedFrame = &queue->data[queue->head];

	memcpy(queuedFrame, frame, sizeof(CANFrame));

	queue->head++;
	if (queue->head >= queue->size) {
		queue->head = 0;
	}

	Interrupt_Enable();
	return 1;
}

boolean_T CANFrame_Queue_Dequeue(CANFrame_Queue *queue, CANFrame *frame)
{
	CANFrame *queuedFrame;
	int32_T depth;

	Interrupt_Disable();

	depth = CANFrame_Queue_Depth(queue);
	if (depth <= 0) {
		Interrupt_Enable();
		return 0;
	}

	queuedFrame = &queue->data[queue->tail];

	memcpy(frame, queuedFrame, sizeof(CANFrame));

	queue->tail++;
	if (queue->tail >= queue->size) {
		queue->tail = 0;
	}

	Interrupt_Enable();
	return 1;
}




/* Code to transmit via a queue */

/* If an error occurs and prevents the TransmitComplete ISR callback from occurring,
   then this periodic function will restart the transmit process */
boolean_T CAN_Queued_PeriodicKick(E_FlexCAN2Module module, CANFrame_Queue *queue)
{
	CANFrame frame;
	boolean_T moreDataToSend;
	boolean_T bufferFree;
	boolean_T result;

	result = 0;

	Interrupt_Disable();
	bufferFree = FlexCAN2_TXBuffer_IsFree(module, (E_FlexCAN2Buffer) 0);
	if (bufferFree) {
		moreDataToSend = CANFrame_Queue_Dequeue(queue, &frame);
		if (moreDataToSend) {
			CAN_LoadTransmitBuffer(module, frame.extended, frame.id, frame.length, frame.data);
			result = 1;
		}
	}
	Interrupt_Enable();

	return result;
}

boolean_T CAN_Queued_Transmit(E_FlexCAN2Module module, CANFrame_Queue *queue, boolean_T extended, uint32_T id, uint8_T length, const uint8_T data[])
{
	CANFrame frame;
	int32_T i;
	int32_T depth;
	boolean_T bufferFree;
	boolean_T ok;

	/* Check whether transmit queue is empty */
	/*     If empty, check whether the hardware transmit buffer is free */
	/*           If free, load the buffer */
	/*           If not free, add to the queue */
	/*     If non-empty, add to the queue. */
	
	/* This whole process must be performed critically */
	Interrupt_Disable();

	depth = CANFrame_Queue_Depth(queue);
	if (depth <= 0) {
		bufferFree = FlexCAN2_TXBuffer_IsFree(module, (E_FlexCAN2Buffer) 0);
		if (bufferFree) {
			ok = CAN_LoadTransmitBuffer(module, extended, id, length, data);
			Interrupt_Enable();
			return ok;
		}
	}

	if (length > 8)
		length = 8;

	frame.extended = extended;
	frame.id = id;
	frame.length = length;
	for (i=0; i < length; i++) {
		frame.data[i] = data[i];
	}
	while (i < 8) {
		frame.data[i] = 0;
		i++;
	}

	ok = CANFrame_Queue_Enqueue(queue, &frame);

	Interrupt_Enable();
	
	if (!ok) {
		ok = CAN_Queued_PeriodicKick(module, queue);
		if (ok) {
			/* A message was dequeued, so try to enqueue this one */
			ok  = CANFrame_Queue_Enqueue(queue, &frame);
		}
	}
	
	return ok;
}

/* Hook to be called by ISR on transmit complete, to implement transmit queue */
void CAN_Queued_TransmitComplete(E_FlexCAN2Module module, CANFrame_Queue *queue)
{
	CANFrame frame;
	boolean_T moreDataToSend;

	moreDataToSend = CANFrame_Queue_Dequeue(queue, &frame);
	if (moreDataToSend) {
		CAN_LoadTransmitBuffer(module, frame.extended, frame.id, frame.length, frame.data);
	}
}	


void CAN_Tx_Buffer_ISR(S_FlexCAN2ISRInfo const* info)
{
	switch ((E_FlexCAN2Module) info->MBInfo.uFlexCAN2Module)
	{
	
		case FLEXCAN2_A:
		
		{
			extern CANFrame_Queue FLEXCAN2_A_TransmitQueue;
			CAN_Queued_TransmitComplete(FLEXCAN2_A, &FLEXCAN2_A_TransmitQueue);
		}
		
		break;
	
		case FLEXCAN2_B:
		
		{
			extern CANFrame_Queue FLEXCAN2_B_TransmitQueue;
			CAN_Queued_TransmitComplete(FLEXCAN2_B, &FLEXCAN2_B_TransmitQueue);
		}
		
		break;
	
		case FLEXCAN2_C:
		
		{
			extern CANFrame_Queue FLEXCAN2_C_TransmitQueue;
			CAN_Queued_TransmitComplete(FLEXCAN2_C, &FLEXCAN2_C_TransmitQueue);
		}
		
		break;
	
		default:
			break;

	}
}

void CAN_Rx_Buffer_ISR(S_FlexCAN2ISRInfo const* info)
{
	switch ((E_FlexCAN2Module) info->MBInfo.uFlexCAN2Module)
	{
	
		case FLEXCAN2_A:
		
		{
			extern CANFrame_Queue FLEXCAN2_A_ReceiveQueue;
			CANFrame frame;
			int32_T i;
			
			frame.extended = info->pBuffer->CS.Obj.IDE;
			if (frame.extended)
				frame.id = info->pBuffer->u32MessageID;
			else
				frame.id = info->pBuffer->u32MessageID >> 18;
			frame.length = info->pBuffer->CS.Obj.LENGTH;
			if (frame.length > 8) frame.length = 8;
			for (i=0; i < frame.length; i++) {
				frame.data[i] = info->pBuffer->u8DataArr[i];
			}
			while (i < 8) {
				frame.data[i] = 0;
				i++;
			}
			
			if (!CANFrame_Queue_Enqueue(&FLEXCAN2_A_ReceiveQueue, &frame)) {
				/* Overflow */
			}
		}
		{
    extern void MotoCoder_TaskEvent_Post(S_MessageBoxDefn const* const in_pMailBox, void (*FuncPtr)(void));
	extern void CAN_1_ReceiveDispatch(void);
	extern const S_MessageBoxDefn g_ApplicationInterruptTask_MailBox;
	MotoCoder_TaskEvent_Post(&g_ApplicationInterruptTask_MailBox, CAN_1_ReceiveDispatch);
}
		break;
	 
		case FLEXCAN2_B:
		
		{
			extern CANFrame_Queue FLEXCAN2_B_ReceiveQueue;
			CANFrame frame;
			int32_T i;
			
			frame.extended = info->pBuffer->CS.Obj.IDE;
			if (frame.extended)
				frame.id = info->pBuffer->u32MessageID;
			else
				frame.id = info->pBuffer->u32MessageID >> 18;
			frame.length = info->pBuffer->CS.Obj.LENGTH;
			if (frame.length > 8) frame.length = 8;
			for (i=0; i < frame.length; i++) {
				frame.data[i] = info->pBuffer->u8DataArr[i];
			}
			while (i < 8) {
				frame.data[i] = 0;
				i++;
			}
			
			if (!CANFrame_Queue_Enqueue(&FLEXCAN2_B_ReceiveQueue, &frame)) {
				/* Overflow */
			}
		}
		{
    extern void MotoCoder_TaskEvent_Post(S_MessageBoxDefn const* const in_pMailBox, void (*FuncPtr)(void));
	extern void CAN_2_ReceiveDispatch(void);
	extern const S_MessageBoxDefn g_ApplicationInterruptTask_MailBox;
	MotoCoder_TaskEvent_Post(&g_ApplicationInterruptTask_MailBox, CAN_2_ReceiveDispatch);
}
		break;
	 
		case FLEXCAN2_C:
		
		{
			extern CANFrame_Queue FLEXCAN2_C_ReceiveQueue;
			CANFrame frame;
			int32_T i;
			
			frame.extended = info->pBuffer->CS.Obj.IDE;
			if (frame.extended)
				frame.id = info->pBuffer->u32MessageID;
			else
				frame.id = info->pBuffer->u32MessageID >> 18;
			frame.length = info->pBuffer->CS.Obj.LENGTH;
			if (frame.length > 8) frame.length = 8;
			for (i=0; i < frame.length; i++) {
				frame.data[i] = info->pBuffer->u8DataArr[i];
			}
			while (i < 8) {
				frame.data[i] = 0;
				i++;
			}
			
			if (!CANFrame_Queue_Enqueue(&FLEXCAN2_C_ReceiveQueue, &frame)) {
				/* Overflow */
			}
		}
		{
    extern void MotoCoder_TaskEvent_Post(S_MessageBoxDefn const* const in_pMailBox, void (*FuncPtr)(void));
	extern void CAN_3_ReceiveDispatch(void);
	extern const S_MessageBoxDefn g_ApplicationInterruptTask_MailBox;
	MotoCoder_TaskEvent_Post(&g_ApplicationInterruptTask_MailBox, CAN_3_ReceiveDispatch);
}
		break;
	
	default:
		break;
	}
}

/* CAN Interface for CAN_1 */
/* CAN transmit queue */
CANFrame_Queue FLEXCAN2_A_TransmitQueue;
CANFrame FLEXCAN2_A_TransmitQueueFrames[20];

/* CAN receive queue between buffer and dispatcher */
CANFrame_Queue FLEXCAN2_A_ReceiveQueue;
CANFrame FLEXCAN2_A_ReceiveQueueFrames[22];


/* Accessor for CAN Bus Health */
void CAN_1_Error_Status_Get(boolean_T* inout_bBusPassivePtr, uint8_T* inout_uTXErrorCountPtr, uint8_T* inout_uRXErrorCountPtr)
{
    U_CAN_ECR sECR;

    /* Get Error Counter Register (CANx_ECR)*/    
    sECR = FlexCAN2_ECR_Get(FLEXCAN2_A);
    
    if(inout_bBusPassivePtr)
    {
        /* If the value of TXECTR or RXECTR increases to be greater than or equal to 128 */
        /* The bus is deemed to be in the 'error passive' state */
        if((sECR.Obj.TXECNT > 127) || (sECR.Obj.RXECNT > 127))
        {
            *inout_bBusPassivePtr = TRUE;
        }
        else
        {
            *inout_bBusPassivePtr = FALSE;
        }
    }

    if(inout_uTXErrorCountPtr)
    {
        *inout_uTXErrorCountPtr = sECR.Obj.TXECNT;
    }

    if(inout_uRXErrorCountPtr)
    {
        *inout_uRXErrorCountPtr = sECR.Obj.RXECNT;
    }
}
boolean_T CAN_1_Transmit(boolean_T extended, uint32_T id, uint8_T length, const uint8_T data[])
{
	boolean_T ok;

	ok = CAN_Queued_Transmit(FLEXCAN2_A, &FLEXCAN2_A_TransmitQueue, extended, id, length, data);

	if (!ok) {
		{
        extern uint16_T Debug_CAN_1_TransmitOverrun;
        Debug_CAN_1_TransmitOverrun = (uint16_T) (SW_OVERRUN & ERROR_CODE_MASK);
    }
	}
return ok;
}
uint32_T CAN_1_TransmitQueueDepth(void)
{

	return CANFrame_Queue_Depth(&FLEXCAN2_A_TransmitQueue);

}

/* Single CAN receive frame between dispatcher and application */
CANFrame RxSlot_3820p0005_ReceiveFrame;
boolean_T RxSlot_3820p0005_ReceiveFrameValid;
boolean_T RxSlot_3820p0005_Receive(boolean_T *extended, uint32_T *id, uint8_T *length, uint8_T data[])
{

	int32_T i;

	Interrupt_Disable();

	if (!RxSlot_3820p0005_ReceiveFrameValid) {
		Interrupt_Enable();
		return 0;
	}
	if (extended) *extended = RxSlot_3820p0005_ReceiveFrame.extended;
	if (id) *id = RxSlot_3820p0005_ReceiveFrame.id;
	if (length) *length = RxSlot_3820p0005_ReceiveFrame.length;
	if (data) {
		for (i=0; i < RxSlot_3820p0005_ReceiveFrame.length; i++) {
			data[i] = RxSlot_3820p0005_ReceiveFrame.data[i];
		}
	}
	RxSlot_3820p0005_ReceiveFrameValid = 0;

	Interrupt_Enable();
	return 1;

}

/* Single CAN receive frame between dispatcher and application */
CANFrame RxSlot_3821p0004_ReceiveFrame;
boolean_T RxSlot_3821p0004_ReceiveFrameValid;
boolean_T RxSlot_3821p0004_Receive(boolean_T *extended, uint32_T *id, uint8_T *length, uint8_T data[])
{

	int32_T i;

	Interrupt_Disable();

	if (!RxSlot_3821p0004_ReceiveFrameValid) {
		Interrupt_Enable();
		return 0;
	}
	if (extended) *extended = RxSlot_3821p0004_ReceiveFrame.extended;
	if (id) *id = RxSlot_3821p0004_ReceiveFrame.id;
	if (length) *length = RxSlot_3821p0004_ReceiveFrame.length;
	if (data) {
		for (i=0; i < RxSlot_3821p0004_ReceiveFrame.length; i++) {
			data[i] = RxSlot_3821p0004_ReceiveFrame.data[i];
		}
	}
	RxSlot_3821p0004_ReceiveFrameValid = 0;

	Interrupt_Enable();
	return 1;

}

/* Single CAN receive frame between dispatcher and application */
CANFrame RxSlot_3822p0004_ReceiveFrame;
boolean_T RxSlot_3822p0004_ReceiveFrameValid;
boolean_T RxSlot_3822p0004_Receive(boolean_T *extended, uint32_T *id, uint8_T *length, uint8_T data[])
{

	int32_T i;

	Interrupt_Disable();

	if (!RxSlot_3822p0004_ReceiveFrameValid) {
		Interrupt_Enable();
		return 0;
	}
	if (extended) *extended = RxSlot_3822p0004_ReceiveFrame.extended;
	if (id) *id = RxSlot_3822p0004_ReceiveFrame.id;
	if (length) *length = RxSlot_3822p0004_ReceiveFrame.length;
	if (data) {
		for (i=0; i < RxSlot_3822p0004_ReceiveFrame.length; i++) {
			data[i] = RxSlot_3822p0004_ReceiveFrame.data[i];
		}
	}
	RxSlot_3822p0004_ReceiveFrameValid = 0;

	Interrupt_Enable();
	return 1;

}

/* Single CAN receive frame between dispatcher and application */
CANFrame RxSlot_4495p0001_ReceiveFrame;
boolean_T RxSlot_4495p0001_ReceiveFrameValid;
boolean_T RxSlot_4495p0001_Receive(boolean_T *extended, uint32_T *id, uint8_T *length, uint8_T data[])
{

	int32_T i;

	Interrupt_Disable();

	if (!RxSlot_4495p0001_ReceiveFrameValid) {
		Interrupt_Enable();
		return 0;
	}
	if (extended) *extended = RxSlot_4495p0001_ReceiveFrame.extended;
	if (id) *id = RxSlot_4495p0001_ReceiveFrame.id;
	if (length) *length = RxSlot_4495p0001_ReceiveFrame.length;
	if (data) {
		for (i=0; i < RxSlot_4495p0001_ReceiveFrame.length; i++) {
			data[i] = RxSlot_4495p0001_ReceiveFrame.data[i];
		}
	}
	RxSlot_4495p0001_ReceiveFrameValid = 0;

	Interrupt_Enable();
	return 1;

}

/* Single CAN receive frame between dispatcher and application */
CANFrame RxSlot_4553p0001_ReceiveFrame;
boolean_T RxSlot_4553p0001_ReceiveFrameValid;
boolean_T RxSlot_4553p0001_Receive(boolean_T *extended, uint32_T *id, uint8_T *length, uint8_T data[])
{

	int32_T i;

	Interrupt_Disable();

	if (!RxSlot_4553p0001_ReceiveFrameValid) {
		Interrupt_Enable();
		return 0;
	}
	if (extended) *extended = RxSlot_4553p0001_ReceiveFrame.extended;
	if (id) *id = RxSlot_4553p0001_ReceiveFrame.id;
	if (length) *length = RxSlot_4553p0001_ReceiveFrame.length;
	if (data) {
		for (i=0; i < RxSlot_4553p0001_ReceiveFrame.length; i++) {
			data[i] = RxSlot_4553p0001_ReceiveFrame.data[i];
		}
	}
	RxSlot_4553p0001_ReceiveFrameValid = 0;

	Interrupt_Enable();
	return 1;

}

/* CAN receive slot queue between dispatcher and application */
CANFrame_Queue RxSlot_4635p0005_ReceiveQueue;
CANFrame RxSlot_4635p0005_ReceiveQueueFrames[2];
boolean_T RxSlot_4635p0005_Receive(boolean_T *extended, uint32_T *id, uint8_T *length, uint8_T data[])
{

	CANFrame rxFrame;
	int32_T i;
	if (!CANFrame_Queue_Dequeue(&RxSlot_4635p0005_ReceiveQueue, &rxFrame)) {
		return 0;
	}
	if (extended) *extended = rxFrame.extended;
	if (id) *id = rxFrame.id;
	if (length) *length = rxFrame.length;
	if (data) {
		for (i=0; i < rxFrame.length; i++) {
			data[i] = rxFrame.data[i];
		}
	}
	return 1;

}

/* Single CAN receive frame between dispatcher and application */
CANFrame RxSlot_4636p0005_ReceiveFrame;
boolean_T RxSlot_4636p0005_ReceiveFrameValid;
boolean_T RxSlot_4636p0005_Receive(boolean_T *extended, uint32_T *id, uint8_T *length, uint8_T data[])
{

	int32_T i;

	Interrupt_Disable();

	if (!RxSlot_4636p0005_ReceiveFrameValid) {
		Interrupt_Enable();
		return 0;
	}
	if (extended) *extended = RxSlot_4636p0005_ReceiveFrame.extended;
	if (id) *id = RxSlot_4636p0005_ReceiveFrame.id;
	if (length) *length = RxSlot_4636p0005_ReceiveFrame.length;
	if (data) {
		for (i=0; i < RxSlot_4636p0005_ReceiveFrame.length; i++) {
			data[i] = RxSlot_4636p0005_ReceiveFrame.data[i];
		}
	}
	RxSlot_4636p0005_ReceiveFrameValid = 0;

	Interrupt_Enable();
	return 1;

}

/* Single CAN receive frame between dispatcher and application */
CANFrame RxSlot_4637p0005_ReceiveFrame;
boolean_T RxSlot_4637p0005_ReceiveFrameValid;
boolean_T RxSlot_4637p0005_Receive(boolean_T *extended, uint32_T *id, uint8_T *length, uint8_T data[])
{

	int32_T i;

	Interrupt_Disable();

	if (!RxSlot_4637p0005_ReceiveFrameValid) {
		Interrupt_Enable();
		return 0;
	}
	if (extended) *extended = RxSlot_4637p0005_ReceiveFrame.extended;
	if (id) *id = RxSlot_4637p0005_ReceiveFrame.id;
	if (length) *length = RxSlot_4637p0005_ReceiveFrame.length;
	if (data) {
		for (i=0; i < RxSlot_4637p0005_ReceiveFrame.length; i++) {
			data[i] = RxSlot_4637p0005_ReceiveFrame.data[i];
		}
	}
	RxSlot_4637p0005_ReceiveFrameValid = 0;

	Interrupt_Enable();
	return 1;

}

/* Single CAN receive frame between dispatcher and application */
CANFrame RxSlot_4638p0005_ReceiveFrame;
boolean_T RxSlot_4638p0005_ReceiveFrameValid;
boolean_T RxSlot_4638p0005_Receive(boolean_T *extended, uint32_T *id, uint8_T *length, uint8_T data[])
{

	int32_T i;

	Interrupt_Disable();

	if (!RxSlot_4638p0005_ReceiveFrameValid) {
		Interrupt_Enable();
		return 0;
	}
	if (extended) *extended = RxSlot_4638p0005_ReceiveFrame.extended;
	if (id) *id = RxSlot_4638p0005_ReceiveFrame.id;
	if (length) *length = RxSlot_4638p0005_ReceiveFrame.length;
	if (data) {
		for (i=0; i < RxSlot_4638p0005_ReceiveFrame.length; i++) {
			data[i] = RxSlot_4638p0005_ReceiveFrame.data[i];
		}
	}
	RxSlot_4638p0005_ReceiveFrameValid = 0;

	Interrupt_Enable();
	return 1;

}

/* Single CAN receive frame between dispatcher and application */
CANFrame RxSlot_4796p0005_ReceiveFrame;
boolean_T RxSlot_4796p0005_ReceiveFrameValid;
boolean_T RxSlot_4796p0005_Receive(boolean_T *extended, uint32_T *id, uint8_T *length, uint8_T data[])
{

	int32_T i;

	Interrupt_Disable();

	if (!RxSlot_4796p0005_ReceiveFrameValid) {
		Interrupt_Enable();
		return 0;
	}
	if (extended) *extended = RxSlot_4796p0005_ReceiveFrame.extended;
	if (id) *id = RxSlot_4796p0005_ReceiveFrame.id;
	if (length) *length = RxSlot_4796p0005_ReceiveFrame.length;
	if (data) {
		for (i=0; i < RxSlot_4796p0005_ReceiveFrame.length; i++) {
			data[i] = RxSlot_4796p0005_ReceiveFrame.data[i];
		}
	}
	RxSlot_4796p0005_ReceiveFrameValid = 0;

	Interrupt_Enable();
	return 1;

}

/* Single CAN receive frame between dispatcher and application */
CANFrame RxSlot_4843p0005_ReceiveFrame;
boolean_T RxSlot_4843p0005_ReceiveFrameValid;
boolean_T RxSlot_4843p0005_Receive(boolean_T *extended, uint32_T *id, uint8_T *length, uint8_T data[])
{

	int32_T i;

	Interrupt_Disable();

	if (!RxSlot_4843p0005_ReceiveFrameValid) {
		Interrupt_Enable();
		return 0;
	}
	if (extended) *extended = RxSlot_4843p0005_ReceiveFrame.extended;
	if (id) *id = RxSlot_4843p0005_ReceiveFrame.id;
	if (length) *length = RxSlot_4843p0005_ReceiveFrame.length;
	if (data) {
		for (i=0; i < RxSlot_4843p0005_ReceiveFrame.length; i++) {
			data[i] = RxSlot_4843p0005_ReceiveFrame.data[i];
		}
	}
	RxSlot_4843p0005_ReceiveFrameValid = 0;

	Interrupt_Enable();
	return 1;

}

/* CAN receive slot queue between dispatcher and application */
CANFrame_Queue CAN_1_KeySuite_ReceiveQueue;
CANFrame CAN_1_KeySuite_ReceiveQueueFrames[4];

uint32_T CAN_1_KeySuite_DynamicID = 0x0;
uint32_T CAN_1_KeySuite_DynamicIDMask = 0x1FF00000;
void CAN_1_KeySuite_SetIDFilter(uint32_T id, uint32_T id_mask)
{
	CAN_1_KeySuite_DynamicID = id;
	CAN_1_KeySuite_DynamicIDMask = id_mask;
}
boolean_T CAN_1_KeySuite_Receive(boolean_T *extended, uint32_T *id, uint8_T *length, uint8_T data[])
{

	CANFrame rxFrame;
	int32_T i;
	if (!CANFrame_Queue_Dequeue(&CAN_1_KeySuite_ReceiveQueue, &rxFrame)) {
		return 0;
	}
	if (extended) *extended = rxFrame.extended;
	if (id) *id = rxFrame.id;
	if (length) *length = rxFrame.length;
	if (data) {
		for (i=0; i < rxFrame.length; i++) {
			data[i] = rxFrame.data[i];
		}
	}
	return 1;

}


void CAN_1_ReceiveDispatch(void)
{
	CANFrame *frame;
	while (1) {
		/* Get next received CAN frame */

		CANFrame rxFrame;
		if (!CANFrame_Queue_Dequeue(&FLEXCAN2_A_ReceiveQueue, &rxFrame)) {
			return;
		}
		frame = &rxFrame;

		/* RxSlot_3820p0005 */
		if (
			(frame->extended == 0) &&
			((frame->id & 0x7FF) == 0x217) &&
			(frame->length >= 8)
		)
		{
			memcpy(&RxSlot_3820p0005_ReceiveFrame, frame, sizeof(CANFrame));
			RxSlot_3820p0005_ReceiveFrameValid = 1;
		}
		/* RxSlot_3821p0004 */
		if (
			(frame->extended == 0) &&
			((frame->id & 0x7FF) == 0x4B0) &&
			(frame->length >= 8)
		)
		{
			memcpy(&RxSlot_3821p0004_ReceiveFrame, frame, sizeof(CANFrame));
			RxSlot_3821p0004_ReceiveFrameValid = 1;
		}
		/* RxSlot_3822p0004 */
		if (
			(frame->extended == 0) &&
			((frame->id & 0x7FF) == 0x417) &&
			(frame->length >= 8)
		)
		{
			memcpy(&RxSlot_3822p0004_ReceiveFrame, frame, sizeof(CANFrame));
			RxSlot_3822p0004_ReceiveFrameValid = 1;
		}
		/* RxSlot_4495p0001 */
		if (
			(frame->extended == 0) &&
			((frame->id & 0x7FF) == 0x312) &&
			(frame->length >= 8)
		)
		{
			memcpy(&RxSlot_4495p0001_ReceiveFrame, frame, sizeof(CANFrame));
			RxSlot_4495p0001_ReceiveFrameValid = 1;
		}
		/* RxSlot_4553p0001 */
		if (
			(frame->extended == 1) &&
			((frame->id & 0x1FFFFFFF) == 0x18FF4049) &&
			(frame->length >= 8)
		)
		{
			memcpy(&RxSlot_4553p0001_ReceiveFrame, frame, sizeof(CANFrame));
			RxSlot_4553p0001_ReceiveFrameValid = 1;
		}
		/* RxSlot_4635p0005 */
		if (
			(frame->extended == 0) &&
			((frame->id & 0x7FF) == 0x278) &&
			(frame->length >= 8)
		)
		{
			CANFrame_Queue_Enqueue(&RxSlot_4635p0005_ReceiveQueue, frame);
		}
		/* RxSlot_4636p0005 */
		if (
			(frame->extended == 0) &&
			((frame->id & 0x7FF) == 0x624) &&
			(frame->length >= 8)
		)
		{
			memcpy(&RxSlot_4636p0005_ReceiveFrame, frame, sizeof(CANFrame));
			RxSlot_4636p0005_ReceiveFrameValid = 1;
		}
		/* RxSlot_4637p0005 */
		if (
			(frame->extended == 0) &&
			((frame->id & 0x7FF) == 0x260) &&
			(frame->length >= 8)
		)
		{
			memcpy(&RxSlot_4637p0005_ReceiveFrame, frame, sizeof(CANFrame));
			RxSlot_4637p0005_ReceiveFrameValid = 1;
		}
		/* RxSlot_4638p0005 */
		if (
			(frame->extended == 0) &&
			((frame->id & 0x7FF) == 0x590) &&
			(frame->length >= 8)
		)
		{
			memcpy(&RxSlot_4638p0005_ReceiveFrame, frame, sizeof(CANFrame));
			RxSlot_4638p0005_ReceiveFrameValid = 1;
		}
		/* RxSlot_4796p0005 */
		if (
			(frame->extended == 0) &&
			((frame->id & 0x7FF) == 0x610) &&
			(frame->length >= 8)
		)
		{
			memcpy(&RxSlot_4796p0005_ReceiveFrame, frame, sizeof(CANFrame));
			RxSlot_4796p0005_ReceiveFrameValid = 1;
		}
		/* RxSlot_4843p0005 */
		if (
			(frame->extended == 0) &&
			((frame->id & 0x7FF) == 0x80) &&
			(frame->length >= 8)
		)
		{
			memcpy(&RxSlot_4843p0005_ReceiveFrame, frame, sizeof(CANFrame));
			RxSlot_4843p0005_ReceiveFrameValid = 1;
		}
		/* CAN_1_KeySuite */
		if (
			(frame->extended == 1) &&
			((frame->id & 0x1FF00000) == 0x0) &&
			((frame->id & CAN_1_KeySuite_DynamicIDMask) == (CAN_1_KeySuite_DynamicID & CAN_1_KeySuite_DynamicIDMask))
		)
		{
			CANFrame_Queue_Enqueue(&CAN_1_KeySuite_ReceiveQueue, frame);
		}
	}
}
void CAN_1_Create(void)
{
	extern void FLEXCAN2_A_Create(void);

	
	CANFrame_Queue_Create(&FLEXCAN2_A_TransmitQueue, FLEXCAN2_A_TransmitQueueFrames, sizeof(FLEXCAN2_A_TransmitQueueFrames)/sizeof(CANFrame));
	
	CANFrame_Queue_Create(&FLEXCAN2_A_ReceiveQueue, FLEXCAN2_A_ReceiveQueueFrames, sizeof(FLEXCAN2_A_ReceiveQueueFrames)/sizeof(CANFrame));
	RxSlot_3820p0005_ReceiveFrameValid = 0;
	RxSlot_3821p0004_ReceiveFrameValid = 0;
	RxSlot_3822p0004_ReceiveFrameValid = 0;
	RxSlot_4495p0001_ReceiveFrameValid = 0;
	RxSlot_4553p0001_ReceiveFrameValid = 0;
	
	CANFrame_Queue_Create(&RxSlot_4635p0005_ReceiveQueue, RxSlot_4635p0005_ReceiveQueueFrames, sizeof(RxSlot_4635p0005_ReceiveQueueFrames)/sizeof(CANFrame));
	RxSlot_4636p0005_ReceiveFrameValid = 0;
	RxSlot_4637p0005_ReceiveFrameValid = 0;
	RxSlot_4638p0005_ReceiveFrameValid = 0;
	RxSlot_4796p0005_ReceiveFrameValid = 0;
	RxSlot_4843p0005_ReceiveFrameValid = 0;
	
	CANFrame_Queue_Create(&CAN_1_KeySuite_ReceiveQueue, CAN_1_KeySuite_ReceiveQueueFrames, sizeof(CAN_1_KeySuite_ReceiveQueueFrames)/sizeof(CANFrame));
	
	FLEXCAN2_A_Create();
}

/* CAN Interface for CAN_2 */
/* CAN transmit queue */
CANFrame_Queue FLEXCAN2_B_TransmitQueue;
CANFrame FLEXCAN2_B_TransmitQueueFrames[16];

/* CAN receive queue between buffer and dispatcher */
CANFrame_Queue FLEXCAN2_B_ReceiveQueue;
CANFrame FLEXCAN2_B_ReceiveQueueFrames[16];


/* Accessor for CAN Bus Health */
void CAN_2_Error_Status_Get(boolean_T* inout_bBusPassivePtr, uint8_T* inout_uTXErrorCountPtr, uint8_T* inout_uRXErrorCountPtr)
{
    U_CAN_ECR sECR;

    /* Get Error Counter Register (CANx_ECR)*/    
    sECR = FlexCAN2_ECR_Get(FLEXCAN2_B);
    
    if(inout_bBusPassivePtr)
    {
        /* If the value of TXECTR or RXECTR increases to be greater than or equal to 128 */
        /* The bus is deemed to be in the 'error passive' state */
        if((sECR.Obj.TXECNT > 127) || (sECR.Obj.RXECNT > 127))
        {
            *inout_bBusPassivePtr = TRUE;
        }
        else
        {
            *inout_bBusPassivePtr = FALSE;
        }
    }

    if(inout_uTXErrorCountPtr)
    {
        *inout_uTXErrorCountPtr = sECR.Obj.TXECNT;
    }

    if(inout_uRXErrorCountPtr)
    {
        *inout_uRXErrorCountPtr = sECR.Obj.RXECNT;
    }
}
boolean_T CAN_2_Transmit(boolean_T extended, uint32_T id, uint8_T length, const uint8_T data[])
{
	boolean_T ok;

	ok = CAN_Queued_Transmit(FLEXCAN2_B, &FLEXCAN2_B_TransmitQueue, extended, id, length, data);

	if (!ok) {
		{
        extern uint16_T Debug_CAN_2_TransmitOverrun;
        Debug_CAN_2_TransmitOverrun = (uint16_T) (SW_OVERRUN & ERROR_CODE_MASK);
    }
	}
return ok;
}
uint32_T CAN_2_TransmitQueueDepth(void)
{

	return CANFrame_Queue_Depth(&FLEXCAN2_B_TransmitQueue);

}

/* Single CAN receive frame between dispatcher and application */
CANFrame RxSlot_4497p0001_ReceiveFrame;
boolean_T RxSlot_4497p0001_ReceiveFrameValid;
boolean_T RxSlot_4497p0001_Receive(boolean_T *extended, uint32_T *id, uint8_T *length, uint8_T data[])
{

	int32_T i;

	Interrupt_Disable();

	if (!RxSlot_4497p0001_ReceiveFrameValid) {
		Interrupt_Enable();
		return 0;
	}
	if (extended) *extended = RxSlot_4497p0001_ReceiveFrame.extended;
	if (id) *id = RxSlot_4497p0001_ReceiveFrame.id;
	if (length) *length = RxSlot_4497p0001_ReceiveFrame.length;
	if (data) {
		for (i=0; i < RxSlot_4497p0001_ReceiveFrame.length; i++) {
			data[i] = RxSlot_4497p0001_ReceiveFrame.data[i];
		}
	}
	RxSlot_4497p0001_ReceiveFrameValid = 0;

	Interrupt_Enable();
	return 1;

}

/* CAN receive slot queue between dispatcher and application */
CANFrame_Queue CAN_2_KeySuite_ReceiveQueue;
CANFrame CAN_2_KeySuite_ReceiveQueueFrames[4];

uint32_T CAN_2_KeySuite_DynamicID = 0x0;
uint32_T CAN_2_KeySuite_DynamicIDMask = 0x1FF00000;
void CAN_2_KeySuite_SetIDFilter(uint32_T id, uint32_T id_mask)
{
	CAN_2_KeySuite_DynamicID = id;
	CAN_2_KeySuite_DynamicIDMask = id_mask;
}
boolean_T CAN_2_KeySuite_Receive(boolean_T *extended, uint32_T *id, uint8_T *length, uint8_T data[])
{

	CANFrame rxFrame;
	int32_T i;
	if (!CANFrame_Queue_Dequeue(&CAN_2_KeySuite_ReceiveQueue, &rxFrame)) {
		return 0;
	}
	if (extended) *extended = rxFrame.extended;
	if (id) *id = rxFrame.id;
	if (length) *length = rxFrame.length;
	if (data) {
		for (i=0; i < rxFrame.length; i++) {
			data[i] = rxFrame.data[i];
		}
	}
	return 1;

}


void CAN_2_ReceiveDispatch(void)
{
	CANFrame *frame;
	while (1) {
		/* Get next received CAN frame */

		CANFrame rxFrame;
		if (!CANFrame_Queue_Dequeue(&FLEXCAN2_B_ReceiveQueue, &rxFrame)) {
			return;
		}
		frame = &rxFrame;

		/* RxSlot_4497p0001 */
		if (
			(frame->extended == 0) &&
			((frame->id & 0x7FF) == 0x3C8) &&
			(frame->length >= 8)
		)
		{
			memcpy(&RxSlot_4497p0001_ReceiveFrame, frame, sizeof(CANFrame));
			RxSlot_4497p0001_ReceiveFrameValid = 1;
		}
		/* CAN_2_KeySuite */
		if (
			(frame->extended == 1) &&
			((frame->id & 0x1FF00000) == 0x0) &&
			((frame->id & CAN_2_KeySuite_DynamicIDMask) == (CAN_2_KeySuite_DynamicID & CAN_2_KeySuite_DynamicIDMask))
		)
		{
			CANFrame_Queue_Enqueue(&CAN_2_KeySuite_ReceiveQueue, frame);
		}
	}
}
void CAN_2_Create(void)
{
	extern void FLEXCAN2_B_Create(void);

	
	CANFrame_Queue_Create(&FLEXCAN2_B_TransmitQueue, FLEXCAN2_B_TransmitQueueFrames, sizeof(FLEXCAN2_B_TransmitQueueFrames)/sizeof(CANFrame));
	
	CANFrame_Queue_Create(&FLEXCAN2_B_ReceiveQueue, FLEXCAN2_B_ReceiveQueueFrames, sizeof(FLEXCAN2_B_ReceiveQueueFrames)/sizeof(CANFrame));
	RxSlot_4497p0001_ReceiveFrameValid = 0;
	
	CANFrame_Queue_Create(&CAN_2_KeySuite_ReceiveQueue, CAN_2_KeySuite_ReceiveQueueFrames, sizeof(CAN_2_KeySuite_ReceiveQueueFrames)/sizeof(CANFrame));
	
	FLEXCAN2_B_Create();
}

/* CAN Interface for CAN_3 */
/* CAN transmit queue */
CANFrame_Queue FLEXCAN2_C_TransmitQueue;
CANFrame FLEXCAN2_C_TransmitQueueFrames[16];

/* CAN receive queue between buffer and dispatcher */
CANFrame_Queue FLEXCAN2_C_ReceiveQueue;
CANFrame FLEXCAN2_C_ReceiveQueueFrames[16];


/* Accessor for CAN Bus Health */
void CAN_3_Error_Status_Get(boolean_T* inout_bBusPassivePtr, uint8_T* inout_uTXErrorCountPtr, uint8_T* inout_uRXErrorCountPtr)
{
    U_CAN_ECR sECR;

    /* Get Error Counter Register (CANx_ECR)*/    
    sECR = FlexCAN2_ECR_Get(FLEXCAN2_C);
    
    if(inout_bBusPassivePtr)
    {
        /* If the value of TXECTR or RXECTR increases to be greater than or equal to 128 */
        /* The bus is deemed to be in the 'error passive' state */
        if((sECR.Obj.TXECNT > 127) || (sECR.Obj.RXECNT > 127))
        {
            *inout_bBusPassivePtr = TRUE;
        }
        else
        {
            *inout_bBusPassivePtr = FALSE;
        }
    }

    if(inout_uTXErrorCountPtr)
    {
        *inout_uTXErrorCountPtr = sECR.Obj.TXECNT;
    }

    if(inout_uRXErrorCountPtr)
    {
        *inout_uRXErrorCountPtr = sECR.Obj.RXECNT;
    }
}
boolean_T CAN_3_Transmit(boolean_T extended, uint32_T id, uint8_T length, const uint8_T data[])
{
	boolean_T ok;

	ok = CAN_Queued_Transmit(FLEXCAN2_C, &FLEXCAN2_C_TransmitQueue, extended, id, length, data);

	if (!ok) {
		{
        extern uint16_T Debug_CAN_3_TransmitOverrun;
        Debug_CAN_3_TransmitOverrun = (uint16_T) (SW_OVERRUN & ERROR_CODE_MASK);
    }
	}
return ok;
}
uint32_T CAN_3_TransmitQueueDepth(void)
{

	return CANFrame_Queue_Depth(&FLEXCAN2_C_TransmitQueue);

}

/* Single CAN receive frame between dispatcher and application */
CANFrame RxSlot_4018p0004_ReceiveFrame;
boolean_T RxSlot_4018p0004_ReceiveFrameValid;
boolean_T RxSlot_4018p0004_Receive(boolean_T *extended, uint32_T *id, uint8_T *length, uint8_T data[])
{

	int32_T i;

	Interrupt_Disable();

	if (!RxSlot_4018p0004_ReceiveFrameValid) {
		Interrupt_Enable();
		return 0;
	}
	if (extended) *extended = RxSlot_4018p0004_ReceiveFrame.extended;
	if (id) *id = RxSlot_4018p0004_ReceiveFrame.id;
	if (length) *length = RxSlot_4018p0004_ReceiveFrame.length;
	if (data) {
		for (i=0; i < RxSlot_4018p0004_ReceiveFrame.length; i++) {
			data[i] = RxSlot_4018p0004_ReceiveFrame.data[i];
		}
	}
	RxSlot_4018p0004_ReceiveFrameValid = 0;

	Interrupt_Enable();
	return 1;

}

/* Single CAN receive frame between dispatcher and application */
CANFrame RxSlot_4019p0004_ReceiveFrame;
boolean_T RxSlot_4019p0004_ReceiveFrameValid;
boolean_T RxSlot_4019p0004_Receive(boolean_T *extended, uint32_T *id, uint8_T *length, uint8_T data[])
{

	int32_T i;

	Interrupt_Disable();

	if (!RxSlot_4019p0004_ReceiveFrameValid) {
		Interrupt_Enable();
		return 0;
	}
	if (extended) *extended = RxSlot_4019p0004_ReceiveFrame.extended;
	if (id) *id = RxSlot_4019p0004_ReceiveFrame.id;
	if (length) *length = RxSlot_4019p0004_ReceiveFrame.length;
	if (data) {
		for (i=0; i < RxSlot_4019p0004_ReceiveFrame.length; i++) {
			data[i] = RxSlot_4019p0004_ReceiveFrame.data[i];
		}
	}
	RxSlot_4019p0004_ReceiveFrameValid = 0;

	Interrupt_Enable();
	return 1;

}

/* Single CAN receive frame between dispatcher and application */
CANFrame RxSlot_4020p0004_ReceiveFrame;
boolean_T RxSlot_4020p0004_ReceiveFrameValid;
boolean_T RxSlot_4020p0004_Receive(boolean_T *extended, uint32_T *id, uint8_T *length, uint8_T data[])
{

	int32_T i;

	Interrupt_Disable();

	if (!RxSlot_4020p0004_ReceiveFrameValid) {
		Interrupt_Enable();
		return 0;
	}
	if (extended) *extended = RxSlot_4020p0004_ReceiveFrame.extended;
	if (id) *id = RxSlot_4020p0004_ReceiveFrame.id;
	if (length) *length = RxSlot_4020p0004_ReceiveFrame.length;
	if (data) {
		for (i=0; i < RxSlot_4020p0004_ReceiveFrame.length; i++) {
			data[i] = RxSlot_4020p0004_ReceiveFrame.data[i];
		}
	}
	RxSlot_4020p0004_ReceiveFrameValid = 0;

	Interrupt_Enable();
	return 1;

}

/* Single CAN receive frame between dispatcher and application */
CANFrame RxSlot_4021p0004_ReceiveFrame;
boolean_T RxSlot_4021p0004_ReceiveFrameValid;
boolean_T RxSlot_4021p0004_Receive(boolean_T *extended, uint32_T *id, uint8_T *length, uint8_T data[])
{

	int32_T i;

	Interrupt_Disable();

	if (!RxSlot_4021p0004_ReceiveFrameValid) {
		Interrupt_Enable();
		return 0;
	}
	if (extended) *extended = RxSlot_4021p0004_ReceiveFrame.extended;
	if (id) *id = RxSlot_4021p0004_ReceiveFrame.id;
	if (length) *length = RxSlot_4021p0004_ReceiveFrame.length;
	if (data) {
		for (i=0; i < RxSlot_4021p0004_ReceiveFrame.length; i++) {
			data[i] = RxSlot_4021p0004_ReceiveFrame.data[i];
		}
	}
	RxSlot_4021p0004_ReceiveFrameValid = 0;

	Interrupt_Enable();
	return 1;

}

/* Single CAN receive frame between dispatcher and application */
CANFrame RxSlot_4022p0004_ReceiveFrame;
boolean_T RxSlot_4022p0004_ReceiveFrameValid;
boolean_T RxSlot_4022p0004_Receive(boolean_T *extended, uint32_T *id, uint8_T *length, uint8_T data[])
{

	int32_T i;

	Interrupt_Disable();

	if (!RxSlot_4022p0004_ReceiveFrameValid) {
		Interrupt_Enable();
		return 0;
	}
	if (extended) *extended = RxSlot_4022p0004_ReceiveFrame.extended;
	if (id) *id = RxSlot_4022p0004_ReceiveFrame.id;
	if (length) *length = RxSlot_4022p0004_ReceiveFrame.length;
	if (data) {
		for (i=0; i < RxSlot_4022p0004_ReceiveFrame.length; i++) {
			data[i] = RxSlot_4022p0004_ReceiveFrame.data[i];
		}
	}
	RxSlot_4022p0004_ReceiveFrameValid = 0;

	Interrupt_Enable();
	return 1;

}

/* Single CAN receive frame between dispatcher and application */
CANFrame RxSlot_4023p0004_ReceiveFrame;
boolean_T RxSlot_4023p0004_ReceiveFrameValid;
boolean_T RxSlot_4023p0004_Receive(boolean_T *extended, uint32_T *id, uint8_T *length, uint8_T data[])
{

	int32_T i;

	Interrupt_Disable();

	if (!RxSlot_4023p0004_ReceiveFrameValid) {
		Interrupt_Enable();
		return 0;
	}
	if (extended) *extended = RxSlot_4023p0004_ReceiveFrame.extended;
	if (id) *id = RxSlot_4023p0004_ReceiveFrame.id;
	if (length) *length = RxSlot_4023p0004_ReceiveFrame.length;
	if (data) {
		for (i=0; i < RxSlot_4023p0004_ReceiveFrame.length; i++) {
			data[i] = RxSlot_4023p0004_ReceiveFrame.data[i];
		}
	}
	RxSlot_4023p0004_ReceiveFrameValid = 0;

	Interrupt_Enable();
	return 1;

}

/* Single CAN receive frame between dispatcher and application */
CANFrame RxSlot_4024p0004_ReceiveFrame;
boolean_T RxSlot_4024p0004_ReceiveFrameValid;
boolean_T RxSlot_4024p0004_Receive(boolean_T *extended, uint32_T *id, uint8_T *length, uint8_T data[])
{

	int32_T i;

	Interrupt_Disable();

	if (!RxSlot_4024p0004_ReceiveFrameValid) {
		Interrupt_Enable();
		return 0;
	}
	if (extended) *extended = RxSlot_4024p0004_ReceiveFrame.extended;
	if (id) *id = RxSlot_4024p0004_ReceiveFrame.id;
	if (length) *length = RxSlot_4024p0004_ReceiveFrame.length;
	if (data) {
		for (i=0; i < RxSlot_4024p0004_ReceiveFrame.length; i++) {
			data[i] = RxSlot_4024p0004_ReceiveFrame.data[i];
		}
	}
	RxSlot_4024p0004_ReceiveFrameValid = 0;

	Interrupt_Enable();
	return 1;

}

/* Single CAN receive frame between dispatcher and application */
CANFrame RxSlot_4494p0004_ReceiveFrame;
boolean_T RxSlot_4494p0004_ReceiveFrameValid;
boolean_T RxSlot_4494p0004_Receive(boolean_T *extended, uint32_T *id, uint8_T *length, uint8_T data[])
{

	int32_T i;

	Interrupt_Disable();

	if (!RxSlot_4494p0004_ReceiveFrameValid) {
		Interrupt_Enable();
		return 0;
	}
	if (extended) *extended = RxSlot_4494p0004_ReceiveFrame.extended;
	if (id) *id = RxSlot_4494p0004_ReceiveFrame.id;
	if (length) *length = RxSlot_4494p0004_ReceiveFrame.length;
	if (data) {
		for (i=0; i < RxSlot_4494p0004_ReceiveFrame.length; i++) {
			data[i] = RxSlot_4494p0004_ReceiveFrame.data[i];
		}
	}
	RxSlot_4494p0004_ReceiveFrameValid = 0;

	Interrupt_Enable();
	return 1;

}

/* Single CAN receive frame between dispatcher and application */
CANFrame RxSlot_4496p0001_ReceiveFrame;
boolean_T RxSlot_4496p0001_ReceiveFrameValid;
boolean_T RxSlot_4496p0001_Receive(boolean_T *extended, uint32_T *id, uint8_T *length, uint8_T data[])
{

	int32_T i;

	Interrupt_Disable();

	if (!RxSlot_4496p0001_ReceiveFrameValid) {
		Interrupt_Enable();
		return 0;
	}
	if (extended) *extended = RxSlot_4496p0001_ReceiveFrame.extended;
	if (id) *id = RxSlot_4496p0001_ReceiveFrame.id;
	if (length) *length = RxSlot_4496p0001_ReceiveFrame.length;
	if (data) {
		for (i=0; i < RxSlot_4496p0001_ReceiveFrame.length; i++) {
			data[i] = RxSlot_4496p0001_ReceiveFrame.data[i];
		}
	}
	RxSlot_4496p0001_ReceiveFrameValid = 0;

	Interrupt_Enable();
	return 1;

}

/* CAN receive slot queue between dispatcher and application */
CANFrame_Queue CAN_3_KeySuite_ReceiveQueue;
CANFrame CAN_3_KeySuite_ReceiveQueueFrames[4];

uint32_T CAN_3_KeySuite_DynamicID = 0x0;
uint32_T CAN_3_KeySuite_DynamicIDMask = 0x1FF00000;
void CAN_3_KeySuite_SetIDFilter(uint32_T id, uint32_T id_mask)
{
	CAN_3_KeySuite_DynamicID = id;
	CAN_3_KeySuite_DynamicIDMask = id_mask;
}
boolean_T CAN_3_KeySuite_Receive(boolean_T *extended, uint32_T *id, uint8_T *length, uint8_T data[])
{

	CANFrame rxFrame;
	int32_T i;
	if (!CANFrame_Queue_Dequeue(&CAN_3_KeySuite_ReceiveQueue, &rxFrame)) {
		return 0;
	}
	if (extended) *extended = rxFrame.extended;
	if (id) *id = rxFrame.id;
	if (length) *length = rxFrame.length;
	if (data) {
		for (i=0; i < rxFrame.length; i++) {
			data[i] = rxFrame.data[i];
		}
	}
	return 1;

}


void CAN_3_ReceiveDispatch(void)
{
	CANFrame *frame;
	while (1) {
		/* Get next received CAN frame */

		CANFrame rxFrame;
		if (!CANFrame_Queue_Dequeue(&FLEXCAN2_C_ReceiveQueue, &rxFrame)) {
			return;
		}
		frame = &rxFrame;

		/* RxSlot_4018p0004 */
		if (
			(frame->extended == 0) &&
			((frame->id & 0x7FF) == 0x2FA) &&
			(frame->length >= 8)
		)
		{
			memcpy(&RxSlot_4018p0004_ReceiveFrame, frame, sizeof(CANFrame));
			RxSlot_4018p0004_ReceiveFrameValid = 1;
		}
		/* RxSlot_4019p0004 */
		if (
			(frame->extended == 0) &&
			((frame->id & 0x7FF) == 0x2FB) &&
			(frame->length >= 8)
		)
		{
			memcpy(&RxSlot_4019p0004_ReceiveFrame, frame, sizeof(CANFrame));
			RxSlot_4019p0004_ReceiveFrameValid = 1;
		}
		/* RxSlot_4020p0004 */
		if (
			(frame->extended == 0) &&
			((frame->id & 0x7FF) == 0x2FC) &&
			(frame->length >= 8)
		)
		{
			memcpy(&RxSlot_4020p0004_ReceiveFrame, frame, sizeof(CANFrame));
			RxSlot_4020p0004_ReceiveFrameValid = 1;
		}
		/* RxSlot_4021p0004 */
		if (
			(frame->extended == 0) &&
			((frame->id & 0x7FF) == 0x2FD) &&
			(frame->length >= 8)
		)
		{
			memcpy(&RxSlot_4021p0004_ReceiveFrame, frame, sizeof(CANFrame));
			RxSlot_4021p0004_ReceiveFrameValid = 1;
		}
		/* RxSlot_4022p0004 */
		if (
			(frame->extended == 0) &&
			((frame->id & 0x7FF) == 0x2FE) &&
			(frame->length >= 8)
		)
		{
			memcpy(&RxSlot_4022p0004_ReceiveFrame, frame, sizeof(CANFrame));
			RxSlot_4022p0004_ReceiveFrameValid = 1;
		}
		/* RxSlot_4023p0004 */
		if (
			(frame->extended == 0) &&
			((frame->id & 0x7FF) == 0x2FF) &&
			(frame->length >= 8)
		)
		{
			memcpy(&RxSlot_4023p0004_ReceiveFrame, frame, sizeof(CANFrame));
			RxSlot_4023p0004_ReceiveFrameValid = 1;
		}
		/* RxSlot_4024p0004 */
		if (
			(frame->extended == 0) &&
			((frame->id & 0x7FF) == 0x300) &&
			(frame->length >= 5)
		)
		{
			memcpy(&RxSlot_4024p0004_ReceiveFrame, frame, sizeof(CANFrame));
			RxSlot_4024p0004_ReceiveFrameValid = 1;
		}
		/* RxSlot_4494p0004 */
		if (
			(frame->extended == 0) &&
			((frame->id & 0x7FF) == 0x510) &&
			(frame->length >= 8)
		)
		{
			memcpy(&RxSlot_4494p0004_ReceiveFrame, frame, sizeof(CANFrame));
			RxSlot_4494p0004_ReceiveFrameValid = 1;
		}
		/* RxSlot_4496p0001 */
		if (
			(frame->extended == 0) &&
			((frame->id & 0x7FF) == 0x728) &&
			(frame->length >= 8)
		)
		{
			memcpy(&RxSlot_4496p0001_ReceiveFrame, frame, sizeof(CANFrame));
			RxSlot_4496p0001_ReceiveFrameValid = 1;
		}
		/* CAN_3_KeySuite */
		if (
			(frame->extended == 1) &&
			((frame->id & 0x1FF00000) == 0x0) &&
			((frame->id & CAN_3_KeySuite_DynamicIDMask) == (CAN_3_KeySuite_DynamicID & CAN_3_KeySuite_DynamicIDMask))
		)
		{
			CANFrame_Queue_Enqueue(&CAN_3_KeySuite_ReceiveQueue, frame);
		}
	}
}
void CAN_3_Create(void)
{
	extern void FLEXCAN2_C_Create(void);

	
	CANFrame_Queue_Create(&FLEXCAN2_C_TransmitQueue, FLEXCAN2_C_TransmitQueueFrames, sizeof(FLEXCAN2_C_TransmitQueueFrames)/sizeof(CANFrame));
	
	CANFrame_Queue_Create(&FLEXCAN2_C_ReceiveQueue, FLEXCAN2_C_ReceiveQueueFrames, sizeof(FLEXCAN2_C_ReceiveQueueFrames)/sizeof(CANFrame));
	RxSlot_4018p0004_ReceiveFrameValid = 0;
	RxSlot_4019p0004_ReceiveFrameValid = 0;
	RxSlot_4020p0004_ReceiveFrameValid = 0;
	RxSlot_4021p0004_ReceiveFrameValid = 0;
	RxSlot_4022p0004_ReceiveFrameValid = 0;
	RxSlot_4023p0004_ReceiveFrameValid = 0;
	RxSlot_4024p0004_ReceiveFrameValid = 0;
	RxSlot_4494p0004_ReceiveFrameValid = 0;
	RxSlot_4496p0001_ReceiveFrameValid = 0;
	
	CANFrame_Queue_Create(&CAN_3_KeySuite_ReceiveQueue, CAN_3_KeySuite_ReceiveQueueFrames, sizeof(CAN_3_KeySuite_ReceiveQueueFrames)/sizeof(CANFrame));
	
	FLEXCAN2_C_Create();
}

