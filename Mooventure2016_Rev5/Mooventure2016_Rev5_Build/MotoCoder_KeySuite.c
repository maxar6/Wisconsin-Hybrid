
/* MotoCoder_KeySuite.c */
/* Generated by MotoCoder */
/* Version: 0.12.4 */
/* At: 2018-09-04 13:38:00 */
/* Copyright: 2018 Woodward. */


#include <MotoCoder.h>
#include <MotoCoder_KeySuite.h>
#include <KeySuiteServer_GenAPI.h>
#include <KeyProtocol_API.h>
#include <ERIProtocol_API.h>
#include <CANKingProtocol_API.h>
#include <MotProgProtocol_API.h>
#include <CryptoProtocol_API.h>
#include <ComputeSecurity_API.h>
#include <BootMailbox_API.h>
#include <Endian.h>
#include <Module.h>
#include <Processor.h>
#include <Module_Generic.h>
#include <MotoCoder_CAN.h>



/*---- DEFINES --------------------------------------------------------------------------------------------*/
/*! \brief Configuration used by KeySuite to define the minimum number of concurrent ERI connections that
           it shall support (results in static RAM consumption) */
#define MIN_CONCURRENT_ERI_CONNECTIONS_SUPPORTED (3)
#define MAX_CONCURRENT_CONNECTIONS (3)
#define CRC_ENTIRE_MAP (0)


/* There are no serial methods so map the alias to NULL */
#define KeySuite_Manager_ChangeBaud  NULL
#define KeySuite_Manager_IsBaudSupported NULL




#define MAX_SUPPORTED_ERI_TABLES (8)
#define MAX_DATA_BYTES_PER_PACKET (8)

/* 0x00 is reserved to indicate a null connection */
#define NULL_CONNECTION    (0)
/* 0xFF is reserved as a marker to inidcate that a connection exists, but it is yet to be initialized */
#define UNINITIALISED_CITY (0xFF)
/* 0x01 is used on all serial connections */
#define SERIAL_CITY_ID     (0x01)

#define KeySuite_Manager_ChangePacketTimeout    NULL

/*---- TYPEDEF --------------------------------------------------------------------------------------------*/
/* Describes the data structures that will be used to house the security keys */
typedef struct
{
    uint32_T u32Seed;
    uint32_T u32Key;
} S_AccessLevelData;

/* Potential for different Seed/Key combination for each access level */
typedef struct
{
    S_AccessLevelData AccessLevelDataObjArr[NUM_ACCESS_LEVELS];
} S_AccessLevelInfo;

typedef void (*PFNTRANSMITREPLY)(S_KeySuiteCityState* const pConnection);

typedef struct
{
    S_KeySuiteMethod const* pMethod;
    PFNTRANSMITREPLY const  pfnTransmitFunction;
    S_EriReqTblList  const* pTableList;
    uint8_T                 u8TransportLayer;
    E_KeySuiteProtocols     ProtocolID;
} S_KeySuiteProtocolInstanceInfo;

/*---- FUNCTION PROTOTYPES --------------------------------------------------------------------------------*/
NativeError_S KeySuite_Manager_ChangeToProtocol(S_KeySuiteCityState* const inout_pConnection, 
                                                E_KeySuiteProtocols in_eNewProtocol);

NativeError_S KeySuite_Manager_GetTableItemPtr(S_EriRequestTable* const out_TableItem, S_KeySuiteCityState const* const pConnection, NativeVar_U uTableNum, uint16_T uItem);

void KeySuite_Manager_TransmitReply(S_KeySuiteCityState* const pConnection);

E_KeySuiteReplyCode KeySuite_Manager_Table_Read(S_KeySuiteCityState* const inout_pConnection, 
                                                S_KeySuiteTableAccessObject const* const pAccessObj);

E_KeySuiteReplyCode KeySuite_Manager_Table_Write(S_KeySuiteCityState* const inout_pConnection, 
                                                 S_KeySuiteTableAccessObject const* const pAccessObj,
                                                 void const* pDataToWrite);

NativeError_S KeySuite_Manager_SecurityChallenge(S_SecurityChallenge const* const in_pSecurityChallengeObj);

NativeBool KeySuite_Manager_ValidateProtocol(S_KeySuiteCityState* const inout_pConnection, 
                                             NativeVar_U eProtocol, 
                                             NativeVar_U eAccessLevel);

NativeError_S KeySuite_Manager_ValidateParameter(S_KeySuiteCityState* const pConnection, 
                                                 S_KeySuiteTableAccessObject const* const pAccessObj, 
                                                 E_KeySuiteAccessOperation in_eOperation);

void KeySuite_Manager_TransmitReplyOnCAN(S_KeySuiteCityState* const pConnection);

E_KeySuiteReplyCode KeySuite_Manager_Memory_Write(void* __FAR_POINTER MemoryAddress, 
                                                  void const* pDataToWrite, 
                                                  NativeVar_U uBytesToWrite,
                                                  S_KeySuiteCityState* const pConnection);

E_KeySuiteReplyCode KeySuite_Manager_Memory_Read(void* out_pFillBuffer,
                                                 void const* __FAR_POINTER MemoryAddress,
                                                 NativeVar_U uBytesToRead,
                                                 S_KeySuiteCityState* const pConnection); 

E_MotProgAck KeySuite_Manager_MemInit(void);
E_MotProgAck KeySuite_Manager_MemInitStatus(void);
E_MotProgAck KeySuite_Manager_MemClose(void (*pfnStartAddress)(void));
void KeySuite_Manager_OnProgComplete(E_MotProgAck eAck, void (*pfnStartAddress)(void)); 

void KeySuite_Manager_OnModuleSupportClose(uint32_T in_u32UserData);
void KeySuite_Manager_OnTimerTick(uint32_T uTimerTickPeriod_us);

/*---- CONSTANTS ------------------------------------------------------------------------------------------*/

extern const S_EriReqTblList EriRequestTableList[MAX_SUPPORTED_ERI_TABLES];


    

uint32_T const g_u32KeyProtocolPacketTimeout_ms = KEY_DEFAULT_PACKET_TIMEOUT;
uint32_T const g_u32ERIProtocolPacketTimeout_ms = ERI_DEFAULT_PACKET_TIMEOUT;

/* IDSHIFTRIGHTFORDD = Number of bits to shift right a message ID in order to obtain the Destination */
#define IDSHIFTRIGHTFORDD 8UL
/* IDSHIFTRIGHTFORSS = Number of bits to shift right a message ID in order to obtain the Destination */
#define IDSHIFTRIGHTFORSS 0UL

void KeySuiteSupport_CANLink_TransmitExtended(S_KeySuiteCANData *pCANFrame);
boolean_T KeySuiteSupport_CANLink_IsTXComplete(S_KeySuiteCANData *pCANFrame);
void KeySuite_Manager_TransmitReplyOnCAN(S_KeySuiteCityState* const pConnection);
uint32_T KeySuiteSupport_CANLink_TXId_Get(uint8_T uClientCity, uint8_T uMyCity);
uint32_T KeySuiteSupport_CANLink_RXId_Get(uint8_T uClientCity, uint8_T uMyCity);
uint8_T KeySuiteSupport_CANLink_GetMyCityID(uint32_T u32RXId);
uint8_T KeySuiteSupport_CANLink_GetClientCityID(uint32_T u32RXId);
InstantiateMethod_PROTOCOL_KEY_OnCAN(g_KeyProtocolOnCAN, &g_u32KeyProtocolPacketTimeout_ms);
InstantiateMethod_PROTOCOL_ERI_OnCAN(g_ERIProtocolOnCAN, &g_u32ERIProtocolPacketTimeout_ms, CRC_ENTIRE_MAP);


/* Define the Protocol Manager object.*/
INSTANTIATE_KeySuite_Manager_Defn(NULL,                                 /* pu32DefaultKeyBaudRate */
                                  MIN_CONCURRENT_ERI_CONNECTIONS_SUPPORTED,
                                  KeySuite_Manager_ChangeToProtocol,    /* pfnChangeToProtocol  */
                                  KeySuite_Manager_GetTableItemPtr,     /* pfnGetTableItem      */
                                  KeySuite_Manager_Table_Read,          /* pfnReadTable         */
                                  KeySuite_Manager_Table_Write,         /* pfnWriteTable        */
                                  KeySuite_Manager_ValidateProtocol,    /* pfnValidateProtocol  */
                                  RandomNumber_Get,                     /* pfnRandomNumber      */
                                  KeySuite_Manager_SecurityChallenge,   /* pfnSecurityChallenge */
                                  KeySuite_Manager_ValidateParameter,   /* pfnValidateParameter */
                                  KeySuite_Manager_Memory_Read,         /* pfnMemoryWrite       */
                                  KeySuite_Manager_Memory_Write,        /* pfnMemoryWrite       */
                                  KeySuite_Manager_TransmitReply,       /* pfnTransmitReply     */
                                  KeySuite_Manager_MemInit,             /* pfnMemInit           */
                                  KeySuite_Manager_MemInitStatus,       /* pfnMemInitStatus     */
                                  KeySuite_Manager_MemClose,
                                  KeySuite_Manager_OnProgComplete,
                                  KeySuite_Manager_IsBaudSupported,     /* pfnIsBaudSupported, Set to NULL if unsupported */
                                  KeySuite_Manager_ChangeBaud,          /* pfnChangeBaud, Set to NULL if unsupported */
                                  KeySuite_Manager_ChangePacketTimeout,
                                  NULL,       /* pfnDFMHandler        */
                                  ThreadSafeMalloc,
                                  ThreadSafeFree,

                                  NULL,                                 /* pfnOnCANKingRequestAuthority     */
                                  NULL,                                 /* pfnOnCANKingAuthorityIncreased   */
                                  NULL,                                 /* pfnOnCANKingAuthorityNegotiated  */
                                  NULL,                                 /* pfnOnCANKingDataRequest          */
                                  NULL);                                /* pfnOnCANKingControlRequest       */
    

/* Fill in each protocol needed by the application, and the associated transport mechanism */
S_KeySuiteProtocolInstanceInfo const g_KeySuiteProtocolInstanceInfo[] = 
{

    {&g_KeyProtocolOnCAN,     KeySuite_Manager_TransmitReplyOnCAN,       EriRequestTableList,     CAN_TRANSPORT_LAYER, PROTOCOL_KEY},
    {&g_ERIProtocolOnCAN,     KeySuite_Manager_TransmitReplyOnCAN,       EriRequestTableList,     CAN_TRANSPORT_LAYER, PROTOCOL_ERI},

};

/*---- RAM VARIABLES --------------------------------------------------------------------------------------*/
S_KeySuiteCityState g_ConnectionArr[MAX_CONCURRENT_CONNECTIONS];



static uint8_T s_u8MotoTronBootObjVersion;
static void* s_pMotoTronBootObj;



/*---- CODE -----------------------------------------------------------------------------------------------*/

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuite_Manager_ReceiptObj_Request
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \brief Request a receipt object of a given size
    \param pConnection The connection making the request
    \param uBytesRequired The size of the request object
*/
NativeVar_U KeySuite_Manager_ReceiptObj_Request(S_KeySuiteCityState* const pConnection, NativeVar_U uBytesRequired)
{
    void* pOldReceiptObjMemory;
    void* pNewReceiptObjMemory;

    pOldReceiptObjMemory = pConnection->PacketReceiptMemManage.pMemory;
    if (pOldReceiptObjMemory == NULL)
    {
        pConnection->PacketReceiptMemManage.uBytesAllocated = 0;
    }

    if (pConnection->PacketReceiptMemManage.uBytesAllocated < uBytesRequired)
    {   /* We have insufficient memory */
        pNewReceiptObjMemory = ThreadSafeMalloc(uBytesRequired);
        if (pNewReceiptObjMemory != NULL)
        {   /* Allocation successful */
            pConnection->PacketReceiptMemManage.pMemory = pNewReceiptObjMemory;
            if (pOldReceiptObjMemory != NULL)
            {   /* There was an old object */

                /* Copy its current contents byte for byte */
                memcpy(pNewReceiptObjMemory,
                       pOldReceiptObjMemory,
                       pConnection->PacketReceiptMemManage.uBytesAllocated);
                /* And then free it */
                ThreadSafeFree(pOldReceiptObjMemory);
            }
            pConnection->PacketReceiptMemManage.uBytesAllocated = uBytesRequired;
            pConnection->PacketReceiptMemManage.uAppSpecific = 0;
            pConnection->PacketReceiptMemManage.bObjInUse = FALSE;
        }
    }
    return(pConnection->PacketReceiptMemManage.uBytesAllocated);
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuite_Manager_MemInit
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \brief Called by the MotProg protocol when it wants the memory to be initialized for programming
    \retval MOTPROGACK_SUCCESS MPC5554 does not need to initialize its memory and so it always is ready for
                programming
*/
E_MotProgAck KeySuite_Manager_MemInit(void)
{
    return(MOTPROGACK_SUCCESS);
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuite_Manager_MemInitStatus
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \brief Called by the MotProg protocol when it wants to learn the status of a memory initialization request
    \retval MOTPROGACK_SUCCESS MPC5554 does not need to initialize its memory and so it always is ready for
                programming
*/
E_MotProgAck KeySuite_Manager_MemInitStatus(void)
{
    return(MOTPROGACK_SUCCESS);
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuite_Manager_OnProgComplete
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \brief Programming has completed successfully and the master that programmed us has been informed that
           programming was completed successfully. We now need to to vector to the start address of the newly
           loaded application.

           The BootMailBox has been loaded (as required) by the MemClose operation that will allow an
           appropriate restart to take place.

    \param eAck The acknowledge that was sent after KeySuite_Manager_MemClose() executed
    \param pfnStartAddress The start address of the application that we just loaded
*/
void KeySuite_Manager_OnProgComplete(E_MotProgAck eAck, void (*pfnStartAddress)(void))
{
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuite_Manager_MemClose
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \brief Function executes when programming completes, but before the "programmer" has been told that the
           programming process has completed

           This function will return control to the protocols on return so that an appropriate reply may be
           sent

    \param pfnStartAddress The start address of the application that is to execute upon programming completing
*/
E_MotProgAck KeySuite_Manager_MemClose(void (*pfnStartAddress)(void))
{
    return(EXCEPTION_UNDEFINED);
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuite_Manager_TransmitFunction_Get
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \brief Recover the transmit function associated with a connection
    \param inout_pConnection The connection request the function
*/
PFNTRANSMITREPLY KeySuite_Manager_TransmitFunction_Get(S_KeySuiteCityState* const inout_pConnection)
{
    NativeVar_U i;
    S_KeySuiteProtocolInstanceInfo const* pProtocolInstance =  g_KeySuiteProtocolInstanceInfo;

    for (i = 0; i < _countof(g_KeySuiteProtocolInstanceInfo); i++, pProtocolInstance++)
    {
        if (   (pProtocolInstance->pMethod == inout_pConnection->pMethod)
             &&(pProtocolInstance->u8TransportLayer == inout_pConnection->pMethod->u8TransportLayerID))
        {
            return (pProtocolInstance->pfnTransmitFunction);
        }
    }
    
    return (NULL); 
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuite_Manager_TransmitReply
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \brief KeySuite Manager hook function to transmit a reply
    \param inout_pConnection The connection request the function
*/
void KeySuite_Manager_TransmitReply(S_KeySuiteCityState* const inout_pConnection)
{
    PFNTRANSMITREPLY pfnTransmit;
    pfnTransmit = KeySuite_Manager_TransmitFunction_Get(inout_pConnection); 

    if (pfnTransmit)
    {
        pfnTransmit(inout_pConnection);
    }
}
 
/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuite_Manager_Protocol_Method_Get
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \brief Recover the Key Protocol Method assoicated with a transport layer.
    \param u8TransportLayer The transport
    \param eProtocol The protocol
*/
S_KeySuiteMethod const* KeySuite_Manager_Protocol_Method_Get(uint8_T u8TransportLayer, E_KeySuiteProtocols eProtocol)
{
    NativeVar_U i;
    S_KeySuiteProtocolInstanceInfo const* pProtocolInstance =  g_KeySuiteProtocolInstanceInfo;

    for (i = 0; i < _countof(g_KeySuiteProtocolInstanceInfo); i++, pProtocolInstance++)
    {
        if (   (pProtocolInstance->ProtocolID == eProtocol)
             &&(pProtocolInstance->u8TransportLayer == u8TransportLayer))
        {
            return (pProtocolInstance->pMethod);
        }
    }
    
    return (NULL); 
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuite_Manager_MethodsPtr_Get
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \brief Recover the method pointer associated with the supplied protocol
    \param eProtocol The protocol whose methods we are interested in
*/
static S_KeySuiteMethod const* KeySuite_Manager_MethodsPtr_Get(S_KeySuiteCityState* const inout_pConnection, 
                                                               NativeVar_U eProtocol)
{
    NativeVar_U i;
    S_KeySuiteProtocolInstanceInfo const* pProtocolInstance =  g_KeySuiteProtocolInstanceInfo;

    for (i = 0; i < _countof(g_KeySuiteProtocolInstanceInfo); i++, pProtocolInstance++)
    {
        if (   (pProtocolInstance->ProtocolID == eProtocol)
             &&(pProtocolInstance->u8TransportLayer == inout_pConnection->pMethod->u8TransportLayerID))
        {
            return (pProtocolInstance->pMethod);
        }
    }
    
    return (NULL); 
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuite_Manager_AllocateReplyObject
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \brief Allocates a protocol reply object 

           We chose the allocate the memory object on the heap if there is not an object sufficiently large
           enough.
    \retval SUCCESS_OK The object was allocated to the connection
    \retval ERROR_FAIL The object could not be allocated
    \param pConnection Pointer to a connection object that we are allocate the reply object to
*/
NativeError_S KeySuite_Manager_AllocateReplyObject(S_KeySuiteCityState* pConnection)
{
    S_KeySuiteReply* pReplyObj;
    NativeVar_U uMaxReplyPacketLength;

    uMaxReplyPacketLength = pConnection->pMethod->uMaxReplyPacketLength;
    /* Do we have an Object already ? */
    if (pConnection->pReplyObj != NULL)
    {   /* An object already exists */

        if (pConnection->pReplyObj->uAppSpecific != FALSE)
        {   /* This object has not been freed from use with communication so we can't use it */
            return(ERROR_FAIL);
        }
        else if (pConnection->pReplyObj->u16SizeOfReplyArr < uMaxReplyPacketLength)
        {   /* An object exists, but it is not large enough for our needs */
            
            /* Free the old object */
            ThreadSafeFree(pConnection->pReplyObj);
            /* And flag that the object has been freed */
            pConnection->pReplyObj = NULL;
        }
    }

    /* Do we need to allocate a new Object */
    if (pConnection->pReplyObj == NULL)
    {   /* Object has not been allocated yet */
        pReplyObj = ThreadSafeMalloc(sizeof(*pReplyObj) + uMaxReplyPacketLength);
        if (pReplyObj != NULL)
        {
            memset(pReplyObj, 0, sizeof(*pReplyObj));
            /* Fill the size of the object */
            pReplyObj->u16SizeOfReplyArr = uMaxReplyPacketLength;
            /* Align the pointer */
            pReplyObj->u8pReplyArr = (uint8_T*)((NativePtrSizedInt_U)pReplyObj + sizeof(*pReplyObj));
            /* And assign the object */
            pConnection->pReplyObj = pReplyObj;
        }
        else
        {   /* There was not sufficient memory */
            return(ERROR_FAIL);
        }
    }

    /* Flag that this reply object is now in use again. A subsequent KeySuite_Manager_AllocateReplyObject()
       call will fail until this object has been freed via KeySuite_Manager_FreeReplyObject() */
    pConnection->pReplyObj->uAppSpecific = TRUE;
    return(SUCCESS_OK);
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuite_Manager_FreeReplyObject
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \brief Frees an allocated protocol memory object
    \param pConnection The connection that contains the reply object that is no longer in use
 */
void KeySuite_Manager_FreeReplyObject(S_KeySuiteCityState* pConnection)
{
    pConnection->pReplyObj->uAppSpecific = FALSE;
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuite_Manager_ConnectionReplyObject_AllocateStatus_Get
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \brief Recover the allocation status of the reply object
    \param pConnection The connection that contains the reply object
    \remarks A reply object is said to be free if the object does not exist
*/
NativeBool KeySuite_Manager_ConnectionReplyObject_AllocateStatus_Get(S_KeySuiteCityState const* const pConnection)
{
    if (pConnection->pReplyObj == NULL)
    {
        return(FALSE);
    }
    else
    {
        return((NativeBool)pConnection->pReplyObj->uAppSpecific);
    }
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuite_Manager_GetTableListPtr
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \internal
    \brief Returns a pointer to the protocol table list.

           Each protocol can have its own seperate table list if desired.

    \param pConnection Pointer to the connection information.
    \return Pointer to a table list
*/
static S_EriReqTblList const* KeySuite_Manager_GetTableListPtr(S_KeySuiteCityState const* const pConnection)
{
    NativeVar_U i;
    S_KeySuiteProtocolInstanceInfo const* pProtocolInstance =  g_KeySuiteProtocolInstanceInfo;

    for (i = 0; i < _countof(g_KeySuiteProtocolInstanceInfo); i++, pProtocolInstance++)
    {
        if (pProtocolInstance->pMethod == pConnection->pMethod)
        {
            return (pProtocolInstance->pTableList);
        }
    }
    /* There is a problem because we are going to return in error. The expectation is that a list will be
       returned so we will return one rather than NULL */
    return (EriRequestTableList); 
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuite_Manager_GetTableItemPtr
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \internal
    \brief Returns a pointer to the protocol table item.

    \param pConnection Pointer to the connection information.
    \param uTableNum The table number
    \param uItem The item number
    \return Pointer to a table list
*/
NativeError_S KeySuite_Manager_GetTableItemPtr(S_EriRequestTable* const out_pTableItem,
                                               S_KeySuiteCityState const* const pConnection,
                                               NativeVar_U uTableNum,
                                               uint16_T uItem)
{
    S_EriReqTblList const* pTableList;
    NativeError_S sError = SUCCESS_OK;

    pTableList = KeySuite_Manager_GetTableListPtr(pConnection);
    
    if(&pTableList[uTableNum].TblAddr[uItem] == NULL)
    {
        sError = ERROR_FAIL;
    }
    else
    {
        /* Use memory access because the table address may be far. */
        sError = Memory_ReadSynch(out_pTableItem, &pTableList[uTableNum].TblAddr[uItem], sizeof(S_EriRequestTable));
    }
    
    return sError;
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuite_Manager_ValidateParameter
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \internal
    \brief Validates a parameter.

    \param inout_pConnection Pointer to the connection information.
    \param pAccessObj Pointer to an object to be validated.
    \param in_eOperation the type of operation (Read/Write) to validate for.
    \return NativeError Value
    \retval SUCCESS_OK when the validation is successful.
    \retval ERROR_FAIL when the validation has failed.
*/
NativeError_S KeySuite_Manager_ValidateParameter(S_KeySuiteCityState* const pConnection, 
                                                 S_KeySuiteTableAccessObject const* const pAccessObj, 
                                                 E_KeySuiteAccessOperation in_eOperation)
{
    NativeVar_U uTable = pAccessObj->u16TableNumber;
    NativeVar_U uAccessMask;
    
    if (uTable < MAX_SUPPORTED_ERI_TABLES)
    {
        S_EriReqTblList const* pTables = &KeySuite_Manager_GetTableListPtr(pConnection)[uTable];

        /* Check if the requested Table Item is within Range */
        if (pAccessObj->u16TableItemNumber < pTables->TblLength)
        {
            S_EriRequestTable TableItem;
            
            KeySuite_Manager_GetTableItemPtr(&TableItem,            
                                             pConnection,            
                                             uTable,            
                                             pAccessObj->u16TableItemNumber);
                                             
            /* Validate the Request Size */
            if (pAccessObj->u16ItemOffset < TableItem.Size)
            {
                uAccessMask = (1 << (2 * (pConnection->eCurrentAccessLevel-1)));
                if(in_eOperation == ACCESS_OPERATION_WRITE)
                {
                    uAccessMask = (2 << (2 * (pConnection->eCurrentAccessLevel-1)));
                }
                     
                if (uAccessMask & TableItem.Access)
                {
                    /* make sure that the request does not exceed the parameter space */
                    if (  (pAccessObj->u16NumberOfBytes + (pAccessObj->u16ItemOffset * TableItem.uElementSize))  
                         <= (TableItem.Size * TableItem.uElementSize))
                    {
                        return (SUCCESS_OK);
                    }
                }
            }
        } 
    }
     
    return (ERROR_FAIL);
}




/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuite_Manager_ChangeToProtocol
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \internal
    \brief Manages a connection when transitioning to a new protocol.

    \param inout_pConnection Pointer to the connection information.
    \param in_eNewProtocol The new protocol to change to.
    \retval SUCCESS_OK.
*/
NativeError_S KeySuite_Manager_ChangeToProtocol(S_KeySuiteCityState* const inout_pConnection, 
                                                E_KeySuiteProtocols in_eNewProtocol)
{

    if (in_eNewProtocol == PROTOCOL_MOTPROG)
    {
	   
	
        /* Shutdown module without turning off power supply */
        Module_Shutdown(0);
	
		/* Close Module Support */
        ModuleSupport_Close(KeySuite_Manager_OnModuleSupportClose, (uint32_T)inout_pConnection);
    }
    else
    {
        /* Determine whether we need to reply to this change of protocol request */
        if (KeySuite_Manager_ConnectionReplyObject_AllocateStatus_Get(inout_pConnection) != FALSE)
        {   /* There is a reply object associated with this change of protocol */

            /* Send the Reply before switching to the new Protocol. The current protocol may not have the same 
               Transmit function. */
            KeySuite_Manager_TransmitFunction_Get(inout_pConnection)(inout_pConnection);
        }

        /* Assumes that in_eNewProtocol has been validated and thus we are able to switch to it */ 
        inout_pConnection->pMethod = KeySuite_Manager_MethodsPtr_Get(inout_pConnection, in_eNewProtocol);
        inout_pConnection->pMethod->pfnInit(inout_pConnection);
    }
    return (SUCCESS_OK);

}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuite_Manager_TableItem_GetAddress
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \brief Recover the address of a table item
    \param pTableItem Pointer to the table item whose parameter we require the address of
*/
static void* __FAR_POINTER KeySuite_Manager_TableItem_GetAddress(S_EriRequestTable const* pTableItem, NativeVar_U uItemOffset)
{
    void* __FAR_POINTER Address;
    NativePtrSizedInt_U uAddress;

    /* It is safe to assume that ParamAddress is near */
    
    if (pTableItem->bIsPtr)
    {
        Address = *((void* *__FAR_POINTER)(NativePtrSizedInt_U)pTableItem->ParamAddress);
    }
    else
    {
        Address = (void* __FAR_POINTER)(NativePtrSizedInt_U)pTableItem->ParamAddress;
    }

    /* Index to the offset */
    uAddress = (NativePtrSizedInt_U)Address;
    uAddress += (uItemOffset * pTableItem->uElementSize);
    Address = (void* __FAR_POINTER)uAddress;
    
    return(Address);
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuite_Manager_Table_Read
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \internal
    \brief Function to read a parameter.

    This function reads a memory location and returns the results in the supplied buffer. The returned data
    MUST be in Big Endian format as well.

    \param pAccessObj Pointer to an Access object.
    \param u8pDataBuffer Pointer to a buffer that holds the result.

    \retval  KEYSUITE_REPLY_READY
    \retval  KEYSUITE_REPLY_PENDING
    \retval  KEYSUITE_REPLY_ERROR
*/
E_KeySuiteReplyCode KeySuite_Manager_Table_Read(S_KeySuiteCityState* const inout_pConnection, 
                                              S_KeySuiteTableAccessObject const* const pAccessObj)
{
    S_EriRequestTable TableItem;
    S_KeySuiteManagerDefn const* pKeySuiteManagerDefn;
    void* __FAR_POINTER Address;
    E_KeySuiteReplyCode eReplyCode;
    
    KeySuite_Manager_GetTableItemPtr(&TableItem,            
                                     inout_pConnection,            
                                     pAccessObj->u16TableNumber,            
                                     pAccessObj->u16TableItemNumber);    

    Address = KeySuite_Manager_TableItem_GetAddress(&TableItem,pAccessObj->u16ItemOffset);
    pKeySuiteManagerDefn = KeySuite_ManagerDefn_GetPtr();

    eReplyCode = pKeySuiteManagerDefn->pfnMemoryRead(inout_pConnection->pReplyObj->u8pReplyArr,
                                                     Address,
                                                     pAccessObj->u16NumberOfBytes,
                                                     inout_pConnection);
    return (eReplyCode);
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuite_Manager_Table_Write
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \internal
    \brief Function to write a parameter.

    This function write a buffer of data to a parameter. The incoming data is in Big Endian format. This function
    first writes the data to the specified location and then reads it back and return the data back in 
    the supplied buffer. The returned data MUST be in Big Endian format as well.

    \param pAccessObj Pointer to an Access object.
    \param u8pDataBuffer Pointer to a buffer that holds the data to be written.

    \retval  KEYSUITE_REPLY_READY  
    \retval  KEYSUITE_REPLY_PENDING
    \retval  KEYSUITE_REPLY_ERROR
*/
E_KeySuiteReplyCode KeySuite_Manager_Table_Write(S_KeySuiteCityState* const inout_pConnection, 
                                                 S_KeySuiteTableAccessObject const* const pAccessObj,
                                                 void const* pDataToWrite)
{
    /* Calculate the address to write */
    S_EriRequestTable TableItem;
    S_KeySuiteManagerDefn const* pKeySuiteManagerDefn;
    void* __FAR_POINTER Address;
    E_KeySuiteReplyCode eReplyCode;
    
    KeySuite_Manager_GetTableItemPtr(&TableItem,            
                                     inout_pConnection,            
                                     pAccessObj->u16TableNumber,            
                                     pAccessObj->u16TableItemNumber);        

    Address = KeySuite_Manager_TableItem_GetAddress(&TableItem,pAccessObj->u16ItemOffset);
    
    /* Not in the internal Flash so the write is allowed to proceed to the access function */
    pKeySuiteManagerDefn = KeySuite_ManagerDefn_GetPtr();

    eReplyCode = pKeySuiteManagerDefn->pfnMemoryWrite(Address,
                                                      pDataToWrite,
                                                      pAccessObj->u16NumberOfBytes,
                                                      inout_pConnection);
    return (eReplyCode);
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuite_Exception_GetFromNativeError
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \brief Converts a native error into an applicable KeySuite exception response
*/
E_KeySuiteException KeySuite_Exception_GetFromNativeError(NativeError_S sError)
{
    if (SUCCESS(sError))
    {
        return(EXCEPTION_NONE);
    }
    else if (sError == ERROR_RESOURCE_NOT_CREATED)
    {
        return(EXCEPTION_ACC_DENIED);
    }
    else if (sError == ERROR_ADDRESS_RANGE)
    {
        return(EXCEPTION_ADDR_ERROR);
    }
    else if (sError == ERROR_ADDRESS_ALIGNMENT)
    {
        return(EXCEPTION_MISALIGNED);
    }
    else if (sError == ERROR_MEMORY_VERIFY)
    {
        return(EXCEPTION_VERIFY_FAIL);
    }
    else if (ERROR_FLASH_PROGRAMMING_VOLTAGE == sError)
    {
        return(EXCEPTION_VPP_ERR);
    }
    else if (ERROR_FLASH_NOT_BLANK == sError)
    {
        return(EXCEPTION_ERASE_FAIL);
    }
    else
    {
        return(EXCEPTION_UNDEFINED);
    }
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuite_Manager_Memory_Write
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \internal
    \brief Function to write a buffer into memory.

    This function write a buffer of data to a location in memory. The incoming data is in Big Endian format. 
    This function first writes the data to the specified location and then reads it back and return the data back in 
    the supplied buffer. The returned data MUST be in Big Endian format as well.

    \param inout_pConnection Pointer to an connection instance.
    \param MemoryAddress Address to write to.
    \param pDataToWrite Pointer to a buffer that holds the data to be written.
    \param uBytesToWrite Number of bytes to write.

    \retval  KEYSUITE_REPLY_PENDING The access was processed and a callback shall resolve the reply
    \retval  KEYSUITE_REPLY_ERROR There was an error in attempting the access
*/
E_KeySuiteReplyCode KeySuite_Manager_Memory_Write(void* __FAR_POINTER MemoryAddress, 
                                                  void const* pDataToWrite, 
                                                  NativeVar_U uBytesToWrite, 
                                                  S_KeySuiteCityState* const pConnection) 
{
    NativeError_S sError;
    E_KeySuiteException eException;

    /* We access our memory synchronously so the callback shall be called directly after we have
       accessed the memory */
    sError = Memory_WriteSynch(MemoryAddress,pDataToWrite,uBytesToWrite);
    eException = KeySuite_Exception_GetFromNativeError(sError);
    if (pConnection->pReplyObj->pfnOnOperationCompleteCallBack != NULL)
    {
        pConnection->pReplyObj->pfnOnOperationCompleteCallBack(MemoryAddress,
                                                               uBytesToWrite,
                                                               eException,
                                                               pConnection);
        return(KEYSUITE_REPLY_PENDING);
    }
    /* Without a callback we have a problem as we don't have a means to communicate our response */
    return(KEYSUITE_REPLY_ERROR);
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuite_Manager_Memory_Read
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \internal
    \brief Function to read data from memory.

    This function reads data from a location in memory. 
    This function first reads the data to the specified location and return the data back in 
    the supplied buffer. The returned data MUST be in Big Endian format as well.

    \param pConnection Pointer to a connection instance.
    \param out_pFillBuffer Pointer to a buffer that shall hold the data that was read
    \param MemoryAddress Address to Read from.
    \param uBytesToRead Number of bytes to access.

    \retval  KEYSUITE_REPLY_PENDING The access was processed and a callback shall resolve the reply
    \retval  KEYSUITE_REPLY_ERROR There was an error in attempting the access
*/
E_KeySuiteReplyCode KeySuite_Manager_Memory_Read(void* out_pFillBuffer,
                                                 void const* __FAR_POINTER MemoryAddress,
                                                 NativeVar_U uBytesToRead, 
                                                 S_KeySuiteCityState* const pConnection) 
{
    NativeError_S sError;
    E_KeySuiteException eException;

    /* We access our memory synchronously so the callback shall be called directly after we have
       accessed the memory */
    sError = Memory_ReadSynch(out_pFillBuffer,MemoryAddress,uBytesToRead);
    eException = KeySuite_Exception_GetFromNativeError(sError);
    if (pConnection->pReplyObj->pfnOnOperationCompleteCallBack != NULL)
    {
        pConnection->pReplyObj->pfnOnOperationCompleteCallBack(MemoryAddress,
                                                               uBytesToRead,
                                                               eException,
                                                               pConnection);
        return(KEYSUITE_REPLY_PENDING);
    }
    return(KEYSUITE_REPLY_ERROR);
}

ProtocolMask_U KeySuite_Manager_ProtocolMask_Translate(E_KeySuiteProtocols in_eProtocol)
{
    ProtocolMask_U Mask;

    switch(in_eProtocol)
    {
        case PROTOCOL_KEY:     
            Mask = PROTOCOL_MASK_KEY;
            break;
        case PROTOCOL_ERI:     
            Mask = PROTOCOL_MASK_ERI;
            break;
        case PROTOCOL_MOTPROG: 
            Mask = PROTOCOL_MASK_MOTPROG;
            break;
        case PROTOCOL_CANKING: 
            Mask = PROTOCOL_MASK_CANKING;
            break;
        case PROTOCOL_BLACKBOX:
            Mask = PROTOCOL_MASK_BLACKBOX;
            break;
        case PROTOCOL_CRYPTO:  
            Mask = PROTOCOL_MASK_CRYPTO;
            break;
        default:
            Mask = 0;
            break;
    }

    return Mask;
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuite_Manager_SecurityChallenge
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \internal
    \brief Performs the security challenge.

    \return Native Error value.
    \retval SUCCESS_OK
    \param in_pSecurityChallengeObj Pointer to the object defining the security challenge
 */
NativeError_S KeySuite_Manager_SecurityChallenge(S_SecurityChallenge const* const in_pSecurityChallengeObj)
{    
    extern const uint8_T g_eProjectID;
    extern const uint32_T g_u4ProductID;

    return Security_ComputeSecurity(in_pSecurityChallengeObj->pu32SeedAndResult,
                                    g_eProjectID,
                                    g_u4ProductID,
                                    in_pSecurityChallengeObj->eSwitchToAccessLevel,
                                    in_pSecurityChallengeObj->uAuthenticationSizeBits,
                                    KeySuite_Manager_ProtocolMask_Translate(in_pSecurityChallengeObj->eSwitchToProtocol),
                                    USE_SECURITY_CHALLENGE_DESIRED_PROTOCOL);
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuite_Manager_ValidateProtocol
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \internal
    \brief Determine if the supplied protocol is supported at the supplied access level.
    \retval TRUE The protocol is supported
    \retval FALSE The protocol is NOT supported
    \param protocol The protocol being requested.
    \param access_level The access level the protocol is being requested at
*/
NativeBool KeySuite_Manager_ValidateProtocol(S_KeySuiteCityState* const inout_pConnection,
                                             NativeVar_U eProtocol, 
                                             NativeVar_U eAccessLevel)
{

    

    if (eProtocol == PROTOCOL_MOTPROG)
    {   /* We want to switch to MotProg. To do this we will switch to the HardBoot executable */
	
        
        /* So prep for a switch by acquiring mail box space so that we can get to the hardboot
           provided security is properly passed */			
        if (inout_pConnection->pMethod->u8TransportLayerID == SCI_TRANSPORT_LAYER)
        {   
            s_u8MotoTronBootObjVersion = 4;
            
            
                

            /* We have a serial connection so V3 is not sufficient, we need a V4 object */
            s_pMotoTronBootObj = MotoTronBootObj_V4Buffer_GetFromHardBoot();                

                
        }
        else
        {   /* We may assume a CAN connection */
            s_u8MotoTronBootObjVersion = 3;
            
            
                
            
            s_pMotoTronBootObj = MotoTronBootObj_V3Buffer_GetFromHardBoot();
                
                
        }
		
        return (s_pMotoTronBootObj != NULL);
		
    }
    else
    {   /* Otherwise the connection is handled by this application */
        S_KeySuiteMethod const* pMethod;

        pMethod = KeySuite_Manager_MethodsPtr_Get(inout_pConnection, eProtocol);
        if (pMethod != NULL)
        {   /* Protocol is supported */
            /* pMethod->eMinAllowableAccessLevel and pMethod->eMaxAllowableAccessLevel are both of type
               E_AccessLevel (even though they are defined as a uint8_T equivalent).  The enum defines
			   the access levels 1-4 as values 1-4 respectively, so we can compare directly */
            if (  (eAccessLevel >= pMethod->eMinAllowableAccessLevel)
                &&(eAccessLevel <= pMethod->eMaxAllowableAccessLevel))
            {
                NativeVar_U uBytesAllocated;

                uBytesAllocated = KeySuite_Manager_ReceiptObj_Request(inout_pConnection,
                                                                      pMethod->uMaxIncommingPacketLength);
                if (uBytesAllocated >= pMethod->uMaxIncommingPacketLength)
                {   /* Our buffer is sufficiently large enough to support this new protocol */
                    return(TRUE);
                }
            }
        }
    }
    return (FALSE);

}    

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuite_Manager_Connection_Find
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \brief Find an existing connection or allocate a connection if required.
    \param uDesiredConnection The connection CityID we are trying to find
           (or NULL_CONNECTION to find the first available with the desired transport and module)
    \param eTransportLayerID The transport
    \param uModuleID The module implementing the transport
    \param bAddOnMiss Attempt to add the connection to the list (if possible) should the connection not be found
           (never added if uDesiredConnection is NULL_CONNECTION)
    \param out_pbFoundConnection Pointer to a boolean that this method shall fill, to indicate whether a new connection was created
    \remarks Threadsafe
*/
S_KeySuiteCityState* KeySuite_Manager_Connection_Find(NativeVar_U uDesiredConnection,
                                                      NativeVar_U eTransportLayerID,
                                                      NativeVar_U uModuleID,
                                                      NativeBool bAddOnMiss,
                                                      NativeBool* out_pbIsNewConnection)
{
    NativeVar_U uIndex;
    S_KeySuiteCityState* pConnection;

    if (out_pbIsNewConnection)
        *out_pbIsNewConnection = FALSE;

    /* It is illegal to ask for the UNINITIALISED_CITY */
    if (uDesiredConnection == UNINITIALISED_CITY)
    {
        return(NULL);
    }

    for(uIndex = 0, pConnection = g_ConnectionArr; uIndex < MAX_CONCURRENT_CONNECTIONS; uIndex++, pConnection++)
    {
        if (pConnection->u8City != NULL_CONNECTION)
        {
            /* If uDesiredConnection is NULL_CONNECTION, then return the first that matches the other criteria */
            if ( ((uDesiredConnection == NULL_CONNECTION) || (pConnection->u8City == uDesiredConnection))
               &&(pConnection->pMethod->u8TransportLayerID == eTransportLayerID)
               &&(pConnection->u8AppSpecific == uModuleID) )
            {
                /* We found our connection. Return the pointer to its information */
                return (pConnection);
            }
        }
    }

    if ((bAddOnMiss == FALSE) || (uDesiredConnection == NULL_CONNECTION))
    {   /* A new connection should not be created */
        return(NULL);
    }

    /* A new allocation is not a common occurrence. So we have elected to repeat the search, but
       this time we do it in a critical section because we will to allocate the item that we find */
    Interrupt_Disable();
    for(uIndex = 0, pConnection = g_ConnectionArr; uIndex < MAX_CONCURRENT_CONNECTIONS; uIndex++, pConnection++)
    {
        if (pConnection->u8City == NULL_CONNECTION)
        {   /* Free connection found */

            /* Take possession of this city, but the connection is not yet ready */
            pConnection->u8City = UNINITIALISED_CITY;
            Interrupt_Enable();
            if (out_pbIsNewConnection)
                *out_pbIsNewConnection = TRUE;
            return(pConnection);
        }
    }

    Interrupt_Enable();
    return(NULL);
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuite_Manager_Connection_Get
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \internal
    \brief Returns the connection information

           If this is a new connections, it allocates a new connection to the requesting client.
    \return pointer to S_KeySuiteCityState is memory allocation was successful, NULL otherwise.
    \param uDesiredConnection The connection to get
    \param eTransportLayerID The Transport that the connection uses
    \param uModuleID The Module that implements the transport
*/
S_KeySuiteCityState* KeySuite_Manager_Connection_Get(NativeVar_U uDesiredConnection, NativeVar_U eTransportLayerID, uint8_T uModuleID)
{
    S_KeySuiteCityState* pConnection;
    NativeBool bIsNewConnection;

    pConnection = KeySuite_Manager_Connection_Find(uDesiredConnection,
                                                   eTransportLayerID,
                                                   uModuleID,
                                                   TRUE,   /* Allocate a new connection if we don't find it */
                                                   &bIsNewConnection);
    if ((bIsNewConnection == FALSE) || (pConnection == NULL))
    {   /* Existing connection was found OR a connection could not be allocated */

    }
    else
    {   /* Is a new connection */

        /* This is a newly created connection so call the stack to initialize the memory for a new connection */
        KeySuite_NewConnection_Open(pConnection);

        /* Setup the App specific data */
        pConnection->u8AppSpecific = uModuleID;

        /* Set the desired access to level 1 */
        pConnection->eRequestedAccessLevel = 1;

        /* Fill in the Conection information. Setup the initial Protocol method */
        pConnection->pMethod = KeySuite_Manager_Protocol_Method_Get((uint8_T)eTransportLayerID, PROTOCOL_KEY);

        {
            NativeVar_U uBytesAllocated;
            /* Get an object to recieve packets from this connection */
            uBytesAllocated = KeySuite_Manager_ReceiptObj_Request(pConnection,
                                                                  pConnection->pMethod->uMaxIncommingPacketLength);
            if (uBytesAllocated >= pConnection->pMethod->uMaxIncommingPacketLength)
            {   /* We got a receipt object that will work for us */

                /* Call the init function */
                pConnection->pMethod->pfnInit(pConnection);

                /* Capture the client City described by this connection
                   Writing this will make the city ready for use. It must be written once the city is operational */
                pConnection->u8City = (uint8_T)uDesiredConnection;
            }
            else
            {   /* We are unable to initialize this city because we were unable to obtain a suitably sized receipt object */
                pConnection = NULL;
            }
        }
    }
    return(pConnection);
}



/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuite_Manager_Connection_GetFromCAN
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \internal
    \brief Returns the connection information for a CAN transport.

    \return pointer to S_KeySuiteCityState is memory allocation was successful, NULL otherwise.
    \param pCANDataObj Pointer to a KeySuite CAN object
*/
S_KeySuiteCityState* KeySuite_Manager_Connection_GetFromCAN(S_KeySuiteCANData* const pCANDataObj) 
{
    NativeVar_U uDesiredConnection;

    uDesiredConnection = KeySuiteSupport_CANLink_GetClientCityID(pCANDataObj->ProtocolSpecific.u32MessageID);

    /* It is illegal to use the NULL_CONNECTION and UNITIAIALISED_CITY CityIDs */
    if ((uDesiredConnection == NULL_CONNECTION) || (uDesiredConnection == UNINITIALISED_CITY))
    {
        return(NULL);
    }

    return(KeySuite_Manager_Connection_Get(uDesiredConnection,
                                           CAN_TRANSPORT_LAYER,
                                           pCANDataObj->ProtocolSpecific.u8CANModule));
}


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuite_Manager_OnModuleSupportClose
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void KeySuite_Manager_OnModuleSupportClose(uint32_T in_u32UserData)
{

    S_KeySuiteCityState* const pConnection = (S_KeySuiteCityState*)in_u32UserData;

    Interrupt_Disable();

    if (s_u8MotoTronBootObjVersion == PV0)
    {
	    S_MotoTronBootObj_V0* pMotoTronBootObjV0 = s_pMotoTronBootObj;

		pMotoTronBootObjV0->bUseInitialProtocol = TRUE;
		pMotoTronBootObjV0->u8BootProtocol = PROTOCOL_MOTPROG;
		pMotoTronBootObjV0->u8BootAccessLevel = pConnection->eRequestedAccessLevel;
		pMotoTronBootObjV0->u8BootCityID = pConnection->pReplyObj->u8MyCity;
		pMotoTronBootObjV0->u32BootDefaultKeySerialBaudRate = KeySuite_DefaultBaud_Get();
		
	    {
			/* CAN on a version 0 boot object is not capable of much configuration other than the baud rate
			   Pull that from the app descriptor */
			pMotoTronBootObjV0->u32BootCANBitRate = 250000;
	    }
		
        BootMailBox_MotoTronBootObj_Post(pMotoTronBootObjV0, PV0);
	}
	else
	{
	    S_MotoTronBootObj_V3* pMotoTronBootObjV3;
	    S_MotoTronBootObj_V4* pMotoTronBootObjV4;
		uint8_T u8CANChannelsUtilizedToProgramMask;

	    /* Initialize the mask to zero, which assumes that no CAN channels will be used to reprogram the box.
		   This would imply a serial programming session. If CAN channels are being used, change the value
           of the mask variable from the boot object information, which is dependent on the boot object version
           through the use of CAN_FillMotoTronBootObj() */
        u8CANChannelsUtilizedToProgramMask = 0;
		
		if (s_u8MotoTronBootObjVersion == PV4)
	    {   /* A version 4 object implies a serial connection */

	        pMotoTronBootObjV4 = s_pMotoTronBootObj;
	        pMotoTronBootObjV3 = &pMotoTronBootObjV4->V3;
		
	    }
	    else
	    {   /* Assume a version 3 object */
	        pMotoTronBootObjV3 = s_pMotoTronBootObj;
	        pMotoTronBootObjV4 = NULL;

			
	        /* Fill the object before the reply object is freed because of the transmit */
		    pMotoTronBootObjV3->u32BootTXMessageID = KeySuiteSupport_CANLink_TXId_Get(pConnection->pReplyObj->u8ClientCity, pConnection->pReplyObj->u8MyCity);
		    pMotoTronBootObjV3->u32BootRXMessageID = KeySuiteSupport_CANLink_RXId_Get(pConnection->pReplyObj->u8ClientCity, pConnection->pReplyObj->u8MyCity);
		    pMotoTronBootObjV3->u32BootRXAcceptMask = 0x1FF0FFFF;
		    pMotoTronBootObjV3->u32BootTXAcceptMask = 0x0000FFFF;
		    pMotoTronBootObjV3->uConnectedCityID = pConnection->pReplyObj->u8ClientCity;
		    pMotoTronBootObjV3->uIDShiftRightForSS = IDSHIFTRIGHTFORSS;
		    pMotoTronBootObjV3->uIDShiftRightForDD = IDSHIFTRIGHTFORDD;
		    {
		        /* Setup CAN for jump to hard-boot */
		        extern void CAN_FillMotoTronBootObj(S_MotoTronBootObj_V3* const bootObj, uint8_T bus);
		        CAN_FillMotoTronBootObj(pMotoTronBootObjV3, (uint8_T)pConnection->u8AppSpecific);
		    
                /* Now that we know which CAN channels are to be used to reprogram, indicate that through
                   the stack variable so that all of the unneeded CAN channels may be closed prior to the
                   reprogramming session. */
                u8CANChannelsUtilizedToProgramMask = pMotoTronBootObjV3->uAllowConnectOnCANMask;
			}

			
	    }

		{
			/* Close any unnecessary CAN channels, as we are about to jump to hardboot. When doing this,
			we only need the CAN channels that will be used for programming. This is a module-specific
			call, allowing each platform the ability to close any channels that are deemed appropriate. */
			
			extern void ModuleSupport_KeySuiteSupport_CloseNonProgrammingCANLinks(uint8_T in_u8AllowConnectOnCANMask);
			ModuleSupport_KeySuiteSupport_CloseNonProgrammingCANLinks(u8CANChannelsUtilizedToProgramMask);
		}

	    pMotoTronBootObjV3->bUseInitialProtocol = TRUE;
	    pMotoTronBootObjV3->u8BootAccessLevel = pConnection->eRequestedAccessLevel;
	    pMotoTronBootObjV3->u8BootProtocol = PROTOCOL_MOTPROG;
	    pMotoTronBootObjV3->bExternalWatchdogEnabled = ModuleSupport_ExternalWatchdog_IsEnabled();

	    if (pMotoTronBootObjV4 == NULL)
	    {
	        BootMailBox_MotoTronBootObj_Post(pMotoTronBootObjV3, PV3);
	    }
	    else
	    {
	        BootMailBox_MotoTronBootObj_Post(pMotoTronBootObjV4, PV4);
	    }
	}
    
    
    /* Want to vector to HardBoot so use the NULL to employ the default behaviour of the Reboot_ControlCore() call */
    Reboot_ControlCore(NULL);
	
    /* NOTE: If this routine ever returns to the running application, consideration needs to be made to save and restore
             the RAM pointed to by s_pMotoTronBootObj as it may have overwritten application RAM! */
	
}


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuite_Manager_OnTimerTick
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \brief Executes on each timer tick so that the protocol engine can implement any timeouts
    \param uTimerTickPeriod_us The period of execution of this function
*/
void KeySuite_Manager_OnTimerTick(uint32_T uTimerTickPeriod_us)
{
    NativeVar_U uTimerTickPeriod_ms;
    NativeVar_U uIndex;
    S_KeySuiteCityState* pConnection;

    /* The protocols want the timeout to be specified in milliseconds */
    uTimerTickPeriod_ms = (NativeVar_U)(uTimerTickPeriod_us / 1000UL);

    for(uIndex = 0, pConnection = g_ConnectionArr; uIndex < MAX_CONCURRENT_CONNECTIONS; uIndex++, pConnection++)
    {
        /* City will be a NULL_CONNECTION until such time as a connection has been built.
           Connections, once built, don't get destroyed so the first NULL_CONNECTION implies the end of the list */
        if (pConnection->u8City == NULL_CONNECTION)
        {   /* Found 1st NULL_CONNECTION entry */
            break;
        }
        else if (pConnection->u8City == UNINITIALISED_CITY)
        {   /* Is a real connection, but it is not ready for us yet */
            continue;
        }
        else
        {   /* There is a connection */
            if (pConnection->pMethod->pfnOnTick != NULL)
            {
                E_KeySuiteException eExcept;

                eExcept = pConnection->pMethod->pfnOnTick(pConnection, uTimerTickPeriod_ms);
                if (eExcept != EXCEPTION_NONE)
                {
                    KeySuite_ForceDefaultKey(pConnection);
                    /* We have timed out and placed it back into Default KEY. We may now deallocate this
                       city so that it is available for use by another connection. */ 
                    pConnection->u8City = NULL_CONNECTION;
                }
            }
        }
    }
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuite_Manager_MessageHandler_Execute
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \internal
    \brief Handles a incoming protocol message.

    \param pConnection The connection that received the message
    \param pProtocolIncomingData Data object that describes the received message
*/
void KeySuite_Manager_MessageHandler_Execute(S_KeySuiteCityState* const pConnection,
                                             S_ProtocolIncomingData const* const pProtocolIncomingData)
{
    E_KeySuiteReplyCode eReplyCode;

    eReplyCode = pConnection->pMethod->pfnMsgHandler(pConnection, pProtocolIncomingData);
    if (eReplyCode == KEYSUITE_REPLY_READY)
    {
        /* We can Send the reply */
        KeySuite_Manager_TransmitFunction_Get(pConnection)(pConnection);
    }
    else if(eReplyCode == KEYSUITE_REPLY_FREEOBJECT)
    {
        /* We were told that the Reply object can be freed. */
        KeySuite_Manager_FreeReplyObject(pConnection);
    }
    else if(eReplyCode == KEYSUITE_REPLY_ERROR)
    {
        /* We were told that the Reply object can be freed, but that there was also an error */
        KeySuite_Manager_FreeReplyObject(pConnection);

        /* We have an exception so call KeySuite to manager to enforce KEY, which is the expected operation */
        KeySuite_ForceDefaultKey(pConnection);
        pConnection->u8City = NULL_CONNECTION;
    }
}



/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuite_Manager_OnCANReceipt
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \internal
    \brief Handles a incoming protocol message.

        Dispatches the CAN frame to the protocol method the client is connected to. If the message is properly handled,
        a reply is sent to the client. Otherwise, no reply is sent.

    \retval SUCCESS_OK The frame was handled
    \retval ERROR_FAIL The frame was not handled
    \param pCANDataObj Pointer to a CAN data onject.
*/
NativeError_S KeySuite_Manager_OnCANReceipt(S_KeySuiteCANData* const pCANDataObj)
{
    S_KeySuiteCityState* pConnection;

    pConnection = KeySuite_Manager_Connection_GetFromCAN(pCANDataObj);

    if(pConnection != NULL)
    {
        /* Does the connection have an allocation object allocated to it yet */
        if (KeySuite_Manager_ConnectionReplyObject_AllocateStatus_Get(pConnection) == FALSE)
        {   /* Need to get a reply object for use with this data stream */
            NativeError_S sError;

            sError = KeySuite_Manager_AllocateReplyObject(pConnection);
            if (FAILED(sError))
            {
                return(sError);
            }
        }

        /* We have a connection and some data */
        {
            S_ProtocolIncomingData ProtocolIncomingData;

            /* Construct the incoming data for protocol use */
            ProtocolIncomingData.pDataPayload = pCANDataObj->u8DataArr;
            ProtocolIncomingData.pTransportLayerSpecific = (void*)&pCANDataObj->ProtocolSpecific;
            /* This information is extracted for later TX assembly */
            pConnection->pReplyObj->u8ClientCity = KeySuiteSupport_CANLink_GetClientCityID(pCANDataObj->ProtocolSpecific.u32MessageID);
            pConnection->pReplyObj->u8MyCity = KeySuiteSupport_CANLink_GetMyCityID(pCANDataObj->ProtocolSpecific.u32MessageID);
            pConnection->u8TransportInUse = pCANDataObj->ProtocolSpecific.u8CANModule;

            KeySuite_Manager_MessageHandler_Execute(pConnection, &ProtocolIncomingData);
            return (SUCCESS_OK);
        }
    }
    return(ERROR_FAIL);
}

    	

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuite_Manager_ResetTransport
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \internal
    \brief Reset a transport, which will place the protocol back into KEY

        Dispatches the CAN frame to the protocol method the client is connected to. If the message is properly handled,
        a reply is sent to the client. Otherwise, no reply is sent.

    \retval SUCCESS_OK The frame was handled
    \retval ERROR_FAIL The frame was not handled
    \param pCANDataObj Pointer to a CAN data onject.
*/
void KeySuite_Manager_ResetTransport(NativeVar_U uModuleID, NativeVar_U uTransportLayerID)
{
    if (uTransportLayerID == SCI_TRANSPORT_LAYER)
    {
        S_KeySuiteCityState* pConnection;

        /* Clear all connections with the given uTransportLayerID and uModuleID */
        while (1)
        {
            pConnection = KeySuite_Manager_Connection_Find(NULL_CONNECTION,
                                                           uTransportLayerID,
                                                           uModuleID,
                                                           FALSE, /* Don't allocate a new connection if we can't find one */
                                                           NULL);
            
            if (pConnection == NULL)
            {
                return;
            }

            KeySuite_ForceDefaultKey(pConnection);
            pConnection->u8City = NULL_CONNECTION;
        }
    }
}






/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuite_Manager_TransmitReplyOnCAN
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \brief Transmits a Reply on CAN.
    \param The connection making the transmit request
*/
void KeySuite_Manager_TransmitReplyOnCAN(S_KeySuiteCityState* const pConnection)
{
    S_KeySuiteCANData CANFrame;
    S_KeySuiteReply* pReply = pConnection->pReplyObj;
    NativeVar_U uNumBytes;

    uNumBytes = pReply->u8ReplyLength;
    if (uNumBytes != 0)
    {
        /* We can Send the reply */
        CANFrame.ProtocolSpecific.u32MessageID = KeySuiteSupport_CANLink_TXId_Get(pReply->u8ClientCity, pReply->u8MyCity);
        CANFrame.ProtocolSpecific.u8CANModule = (uint8_T)pConnection->uAppSpecific;
        CANFrame.ProtocolSpecific.u8Length = (uint8_T)uNumBytes;
        /* This is not needed by App_CANLink_TransmitExtended()
        CANFrame.ProtocolSpecific.u8MessageBuffer = 0; */

        /* Copy the data */
        InlineMemCopy(CANFrame.u8DataArr, pReply->u8pReplyArr, uNumBytes);

        KeySuiteSupport_CANLink_TransmitExtended(&CANFrame);
        if (pReply->pfnPostReplyCallBack != NULL)
        {   /* As there is a callback we need to ensure that the transmission is actually done before we
                continue */
            while(KeySuiteSupport_CANLink_IsTXComplete(&CANFrame) == FALSE);
        }
    }

    /* Check if the protocol needs to be called back after the reply has been sent */
    if(pReply->pfnPostReplyCallBack != NULL)
    {
        /* Call the function. */
        pReply->pfnPostReplyCallBack(pConnection);
    }

    /* We can free the Reply object since we have sent the request */
    KeySuite_Manager_FreeReplyObject(pConnection);
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuiteSupport_CANLink_GetMyCityID
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \brief Recovers My City ID from a received message using the rules defined by the S_MotoTronBootObj_V3
           object
    \param u32RXId The message ID that met the receiption conditions
*/
uint8_T KeySuiteSupport_CANLink_GetMyCityID(uint32_T u32RXId)
{
    return (uint8_T)(u32RXId >> IDSHIFTRIGHTFORDD);
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuiteSupport_CANLink_GetClientCityID
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \brief Recovers the client city ID from a received message using the rules defined by the 
           S_MotoTronBootObj_V3 object
    \param u32RXId The message ID that met the receiption conditions
*/
uint8_T KeySuiteSupport_CANLink_GetClientCityID(uint32_T u32RXId)
{
    return (uint8_T)(u32RXId >> IDSHIFTRIGHTFORSS);
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuiteSupport_CANLink_TXId_Get
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \brief Recover the TXId that should be used given MyCity and the ClientCity (which should've been 
           extracted from the received Message ID
    \param uClientCity The client city (DD)
    \param uMyCity My city ID (SS)
*/
uint32_T KeySuiteSupport_CANLink_TXId_Get(uint8_T uClientCity, uint8_T uMyCity)
{
    uint32_T TxID;

    TxID = ((0UL) | ((uint32_T)uMyCity << IDSHIFTRIGHTFORSS) | ((uint32_T)uClientCity << IDSHIFTRIGHTFORDD));

    return(TxID);
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuiteSupport_CANLink_RXId_Get
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \brief Recover the RXId that should be used given MyCity and the ClientCity (which should've been 
           extracted from the received Message ID
    \param uClientCity The client city (DD)
    \param uMyCity My city ID (SS)
*/
uint32_T KeySuiteSupport_CANLink_RXId_Get(uint8_T uClientCity, uint8_T uMyCity)
{
    uint32_T RxID;
   
    RxID = ((0UL) | ((uint32_T)uMyCity << IDSHIFTRIGHTFORDD) | ((uint32_T)uClientCity << IDSHIFTRIGHTFORSS));

    return(RxID);
}



/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuiteSupport_CANLink_TransmitExtended
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void KeySuiteSupport_CANLink_TransmitExtended(S_KeySuiteCANData *pCANFrame)
{
    switch (pCANFrame->ProtocolSpecific.u8CANModule)
    {
	
        case FLEXCAN2_A:
CAN_1_Transmit(1, pCANFrame->ProtocolSpecific.u32MessageID, pCANFrame->ProtocolSpecific.u8Length, pCANFrame->u8DataArr);
	break;
	
        case FLEXCAN2_B:
CAN_2_Transmit(1, pCANFrame->ProtocolSpecific.u32MessageID, pCANFrame->ProtocolSpecific.u8Length, pCANFrame->u8DataArr);
	break;
	
        case FLEXCAN2_C:
CAN_3_Transmit(1, pCANFrame->ProtocolSpecific.u32MessageID, pCANFrame->ProtocolSpecific.u8Length, pCANFrame->u8DataArr);
	break;

    }
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuiteSupport_CANLink_IsTXComplete
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
boolean_T KeySuiteSupport_CANLink_IsTXComplete(S_KeySuiteCANData *pCANFrame)
{

    return(1);
        

    
}



/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuite_RefreshPeriodicTimer
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void KeySuite_RefreshPeriodicTimer(void)
{
    extern void KeySuite_Manager_OnTimerTick(uint32_T interval_us);
    static uint32_T KeySuite_LastTickVaue = 0;
    uint32_T uTickValue = KeySuite_LastTickVaue;
    uint32_T uTime_us = Timer_FreeRunningCounter_GetDiffAndUpdate_us(&uTickValue);
    
	/* Protocols use ms, do nothing if 1ms has not accumulated yet */
    if (uTime_us >= 1000UL)
	{
		KeySuite_LastTickVaue = uTickValue;
		KeySuite_Manager_OnTimerTick(uTime_us);
	}
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuite_MessageHandler
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void KeySuite_MessageHandler(void)
{

    uint8_T msg_data[8];
    uint8_T msg_length;
    uint32_T msg_id;

    while (CAN_1_KeySuite_Receive(0, &msg_id, &msg_length, msg_data))
    {
        S_KeySuiteCANData CANFrame;
        
        memcpy(CANFrame.u8DataArr, msg_data, msg_length);
        CANFrame.ProtocolSpecific.u8Length = msg_length;
        CANFrame.ProtocolSpecific.u32MessageID = msg_id;
        CANFrame.ProtocolSpecific.u8MessageBuffer = 0;
        CANFrame.ProtocolSpecific.u8AppSpecific = 0;
        CANFrame.ProtocolSpecific.u8CANModule = FLEXCAN2_A;
    
        KeySuite_Manager_OnCANReceipt(&CANFrame);
    }

    while (CAN_2_KeySuite_Receive(0, &msg_id, &msg_length, msg_data))
    {
        S_KeySuiteCANData CANFrame;
        
        memcpy(CANFrame.u8DataArr, msg_data, msg_length);
        CANFrame.ProtocolSpecific.u8Length = msg_length;
        CANFrame.ProtocolSpecific.u32MessageID = msg_id;
        CANFrame.ProtocolSpecific.u8MessageBuffer = 0;
        CANFrame.ProtocolSpecific.u8AppSpecific = 0;
        CANFrame.ProtocolSpecific.u8CANModule = FLEXCAN2_B;
    
        KeySuite_Manager_OnCANReceipt(&CANFrame);
    }

    while (CAN_3_KeySuite_Receive(0, &msg_id, &msg_length, msg_data))
    {
        S_KeySuiteCANData CANFrame;
        
        memcpy(CANFrame.u8DataArr, msg_data, msg_length);
        CANFrame.ProtocolSpecific.u8Length = msg_length;
        CANFrame.ProtocolSpecific.u32MessageID = msg_id;
        CANFrame.ProtocolSpecific.u8MessageBuffer = 0;
        CANFrame.ProtocolSpecific.u8AppSpecific = 0;
        CANFrame.ProtocolSpecific.u8CANModule = FLEXCAN2_C;
    
        KeySuite_Manager_OnCANReceipt(&CANFrame);
    }

}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: KeySuite_Create
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void KeySuite_Create(void)
{

    uint8_T cityID;
    uint32_T id;
 cityID = 11;

mh_CAN_1_CityID_Update(&cityID);
	id = KeySuiteSupport_CANLink_RXId_Get(0, cityID);
    CAN_1_KeySuite_SetIDFilter(id, 0x1FFFFF00);
cityID = 11;

mh_CAN_2_CityID_Update(&cityID);
	id = KeySuiteSupport_CANLink_RXId_Get(0, cityID);
    CAN_2_KeySuite_SetIDFilter(id, 0x1FFFFF00);
cityID = 11;

mh_CAN_3_CityID_Update(&cityID);
	id = KeySuiteSupport_CANLink_RXId_Get(0, cityID);
    CAN_3_KeySuite_SetIDFilter(id, 0x1FFFFF00);

}


