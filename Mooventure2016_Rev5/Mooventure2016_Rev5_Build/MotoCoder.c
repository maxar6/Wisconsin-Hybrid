
/* MotoCoder.c */
/* Generated by MotoCoder */
/* Version: 0.12.4 */
/* At: 2018-04-08 00:47:54 */
/* Copyright: 2018 Woodward. */


#include <MotoCoder.h>
#include <AtomicTypes.h>
#include <Processor.h>
#include <Processor_Generic.h>
#include <Module_Generic.h>
#include <DeviceDrivers_Generic.h>
#include <TaskKernel_GenAPI.h>
#include <stdio.h>
#include <MPC55xxFlash_API.h>
#include <FMPLL_Reg.h>
#include <BootInterface.h>
#include <string.h>

extern const S_AnalogQueueDefn ContinuousScan_eQADCQueue;
	

/* Main Application */
const boolean_T g_bEnableControlledShutdown = 1;
const boolean_T g_bEnableWatchdog = 1;
    
/* Name: MotoCoderVersionTxt ClassID:TEXT StorageID:CODE Access:RO4+RO3+RO2+RO1 UpdateID:ONCE TextLen:7
Group:"System | Version" Help:"MotoCoder version used to build the application." */
const uint8_T MotoCoderVersionTxt[7] = "0.12.4";

    
/* Name: PeakHeapBytesUsed ClassID:VAR StorageID:RAM Access:RO4+RO3+RO2+RO1 TypeID:UINT4 CType:uint32_T Struct:g_u32PeakHeapBytesUsed
Mask:FFFFFFFF Gain:1.0 Offset:0.0 Exp:1.0 Min:0.000000 Max:4294967295.000000 Format:9.0 UpdateID:BACKGND
Group:"System | Memory" Help:"Maximum number of bytes used on the heap since startup" Unit:bytes */
void Module_Shutdown(boolean_T shutdownPower)
{
    {
        extern boolean_T g_bAppOpen;
        g_bAppOpen = 0;
    }
    
    
    {extern void CloseApplication(void);
        CloseApplication();
    }
    {extern void IO_Stop(void);
        IO_Stop();
    }
    {extern void SaveCalibration(void);
        SaveCalibration();
    }
    {extern void NonVolatile_CloseDataStore(void);
        NonVolatile_CloseDataStore();
    }

    /* When requested, shutdown power-supply on modules with an internal power-supply device.
       When reprogramming, for example, the power-supply should not be turned off,
       but the remaining shutdown procedure should still occur.
    */
    if (shutdownPower) {
		
        ModuleSupport_PowerSupply_Shutdown();
		

        Task_Sleep(5000);
			
        ModuleSupport_Reset();
		
    }
}

uint64_T g_Timer_FreeRunningCounter_TimeAtReset;
void Timer_FreeRunningCounter_ResetTime(void)
{
    Timer_FreeRunningCounter_Get64Bits(&g_Timer_FreeRunningCounter_TimeAtReset);
}
void Timer_FreeRunningCounter_GetTime(uint32_T *lower32Bits_us, uint32_T *upper32Bits_us)
{
	/* Timer_CurrentTime is static, so that it will be aligned */
	static uint64_T Timer_CurrentTime;

	Interrupt_Disable();

	/* Get the free running counter */
    Timer_FreeRunningCounter_Get64Bits(&Timer_CurrentTime);
	
    /* Update the current time since reset */
    Timer_CurrentTime = Timer_CurrentTime - g_Timer_FreeRunningCounter_TimeAtReset;
	
    /* Convert the current time since reset in ticks to uSec */
    Timer_CurrentTime = Timer_FreeRunningCounter_Get64BitTimeFromTicks(Timer_CurrentTime);
	
    
    if (upper32Bits_us) {
		*upper32Bits_us = (Timer_CurrentTime >> 32);
	}
	if (lower32Bits_us) {
		*lower32Bits_us = Timer_CurrentTime & 0x00000000FFFFFFFF;
	}
        
    
    Interrupt_Enable();
}
uint32_T Timer_FreeRunningCounter_GetRawTicksFromTime(uint32_T u32Time_us)
{
	return Timer_FreeRunningCounter_GetTicksFromTime(u32Time_us);
}
uint32_T Timer_FreeRunningCounter_GetDeltaUpdateReference_us(uint32_T * pReference_lower32Bits, uint32_T *pReference_upper32Bits)
{
    
		if (!pReference_upper32Bits)
		{
			return Timer_FreeRunningCounter_GetDiffAndUpdate_us(pReference_lower32Bits);
		}
		else if(pReference_upper32Bits && pReference_lower32Bits)
		{
			uint64_T u64Reference = (uint64_T)(((uint64_T)(*pReference_upper32Bits) << 32) | *pReference_lower32Bits);
			uint32_T u32Result = (uint32_T)Timer_FreeRunningCounter_Get64BitDiffAndUpdate_us(&u64Reference);
			*pReference_upper32Bits = (u64Reference >> 32);
			*pReference_lower32Bits = u64Reference & 0x00000000FFFFFFFF;
			return u32Result;
		}
		else
		{
			return 0;
		}
        
}

uint32_T u4LastRandomNumber = 0;
void RandomNumber_Get(uint32_T* out_pNumber)
{
 uint32_T FreeRunningCount;
 Timer_FreeRunningCounter_GetTime(&FreeRunningCount, NULL);
 u4LastRandomNumber = u4LastRandomNumber * 1103515245 + FreeRunningCount;
 
 *out_pNumber = u4LastRandomNumber;
}

/* Main Application */
/*---- RESET CONFIG HALFWORD ------------------------------------------------------------------------------*/
#include <Pragma_Section_Start_RCHW_rodata.h>

/* The Reset Configuration Halfword needs to be set to zero to flag that this block is invalidated against
being a valid boot block. Set to a special value in HardBoot to flag that the block is bootable */
uint32_T const RCHW __SECTION_RHCW_RODATA__ = 0x00000000;

#include <Pragma_Section_End_rodata.h>

/*---- FLASH MEMORY HANDLING ------------------------------------------------------------------------------*/

/* Flash and Calibration Memory */
#define FLASH_START_ADDRESS             (0x00000000UL)

#define FLASH_CALIBRATION_START_ADDRESS (0x001E0000UL)


#define FLASH_CALIBRATION_END_ADDRESS   (0x1FFFBFUL)


#define RAM_CALIBRATION_START_ADDRESS   (0x3ffe0000UL)
#define CALIBRATION_MEMORY_SIZE         (0x1FFC0UL)
    
S_MemoryDeviceDefn const Flash_Memory = S_MemoryDeviceDefn_CONSTRUCTOR(
    /* uFirstValidAddress */      FLASH_START_ADDRESS,
    /* uLastValidAddress  */      FLASH_CALIBRATION_END_ADDRESS,
    /* uFirstValidWriteAddress */ FLASH_CALIBRATION_START_ADDRESS,
    /* uLastValidWriteAddress  */ FLASH_CALIBRATION_END_ADDRESS,
                                  InternalFlash_Registered_ReadSynch,
                                  InternalFlash_Registered_WriteSynch,
                                  NULL,
                                  NULL,
                                  &Flash_Memory);

            

void LoadCalibration(void)
{

    NativeError_S readError = SUCCESS_OK; 
	
    /* Copy calibration section from from FLASH to RAM */
    readError = Memory_ReadSynch(
        (void *) RAM_CALIBRATION_START_ADDRESS, 
        (void *) FLASH_CALIBRATION_START_ADDRESS,
        CALIBRATION_MEMORY_SIZE);
	{
        extern uint16_T Debug_LoadCalibrationError;
        Debug_LoadCalibrationError = (uint16_T) (readError & ERROR_CODE_MASK);
    }
}

void SaveCalibration(void)
{

    NativeError_S writeError = SUCCESS_OK;
	

    /* Only attempt to save the calibration if it is different to what already exists */
    if (memcmp((void *)FLASH_CALIBRATION_START_ADDRESS, (void *)RAM_CALIBRATION_START_ADDRESS, CALIBRATION_MEMORY_SIZE) != 0)
    {
        /* Disable cache and pipelining, and open flash memory for write */
        MPC55xxFlash_Open();
        
        /* Setup region of writable space */
        MPC55xxFlash_Protection_Set(
            (void*)FLASH_CALIBRATION_START_ADDRESS,
            CALIBRATION_MEMORY_SIZE,
            FLASH_MEM_UNPROTECTED);
            
        /* Copy calibration section from from RAM to FLASH */
        writeError = Memory_WriteSynch((void *) FLASH_CALIBRATION_START_ADDRESS, (void *) RAM_CALIBRATION_START_ADDRESS, CALIBRATION_MEMORY_SIZE);
            
        /* Re-enable flash cache and pipelining */
        MPC55xxFlash_Close();
    }
    {
        extern uint16_T Debug_SaveCalibrationError;
        Debug_SaveCalibrationError = (uint16_T) (writeError & ERROR_CODE_MASK);
    }
}

void OpenMemory(void)
{
    /* Register the Flash Memory for Read/Write operations */
    ModuleSupReg_Memory_Register(&Flash_Memory);
       
    LoadCalibration();
}


/*:::: eQADC IRQs :::::::::::::::::::*/

S_eQADC_ISRObj const g_eQADC_ISRObj =
{
    NULL,
    NULL,
};



/*---- TASKS AND TRIGGERS --------------------------------------------------------------------------------*/

#define NUM_TASKS (5)	
#define INTERRUPT_STACK_SIZE_IN_BYTES (1536)

InstantiateGlobalTaskingInfo(NUM_TASKS,INTERRUPT_STACK_SIZE_IN_BYTES);

/* Periodic Timer Setup */
uint16_T const g_uRTIPeriodInMicroSecs = 5000;

/* Allowed execution starvation time, before watchdog reset will occur */
uint32_T const g_u32ExecutionStarvationTime_us = 500000;

/* Required main task, which always uses the lowest priority 0, and always uses the variable g_AppTask */
NativeVar_S MainAppTask(void*);
InstantiateTask(g_AppTask, 0, MainAppTask, "MainAppTask", NULL, 1024);

/* Name: IdleStackMinBytesFree ClassID:VAR StorageID:RAM Access:RO4+RO3+RO2+RO1 TypeID:UINT2 CType:S_TaskCtrlBlock Struct:g_AppTaskTCB.uBytesFreeOnStackMin
Mask:FFFFFFFF Gain:1.0 Offset:0.0 Exp:1.0 Min:0.000000 Max:65535.000000 Format:5.0 UpdateID:BACKGND
Group:"System | Memory" Help:"Remaining bytes available on the Idle stack" Unit:bytes */

/* Name: KernelStackMinBytesFree ClassID:VAR StorageID:RAM Access:RO4+RO3+RO2+RO1 TypeID:UINT2 CType:S_TaskCtrlBlock Struct:g_IdleTaskTCB.uBytesFreeOnStackMin
Mask:FFFFFFFF Gain:1.0 Offset:0.0 Exp:1.0 Min:0 Max:65535 Format:5.0 UpdateID:BACKGND
Group:"System | Memory" Help:"Remaining bytes available on the Kernel stack" Unit:bytes */

/* Name: InterruptStackMinBytesFree ClassID:VAR StorageID:RAM Access:RO4+RO3+RO2+RO1 TypeID:UINT2 CType:uint2 Struct:g_u16InterruptStackMinBytesFree
Mask:FFFFFFFF Gain:1.0 Offset:0.0 Exp:1.0 Min:0 Max:65535 Format:5.0 UpdateID:BACKGND
Group:"System | Memory" Help:"Remaining bytes available on the interrupt stack" Unit:bytes */



/* Name: E_PowerUpStatus ClassID:ENUMDEC EnumDflt:"Undefined" */
typedef enum E_PowerUpStatus
{
    COLD_POWERUP = 0, /* EnumTxt:"Cold Powerup" */
    WARM_POWERUP = 1, /* EnumTxt:"Warm Powerup" */
} E_PowerUpStatus;

/* Name: PowerUpStatus CType:uint8_T ClassID:ENUMVAR StorageID:RAM Access:RO4+RO3+RO2+RO1 TypeID:UINT1 Gain:1 
   Min:0 Max:1 Format:1.0 UpdateID:SECOND Struct:g_bWasPowerUpStatusWarm EnumDec:E_PowerUpStatus
   Group:"System | Status" Help:"This indicates the power-up state of the system." */
uint8_T g_bWasPowerUpStatusWarm;

/* Instantiate User Tasks */
NativeVar_S MotoCoder_TaskEventQueue_Execute(void *mailBox);

InstantiateMailBox_SingleSemaphore(g_BGNDTask_MailBox);
InstantiateTask(g_BGNDTask, 1, MotoCoder_TaskEventQueue_Execute, "BGNDTask", &g_BGNDTask_MailBox, 2048);
	
/* Name: BGNDTaskStackMinBytesFree ClassID:VAR StorageID:RAM Access:RO4+RO3+RO2+RO1 TypeID:UINT2 CType:S_TaskCtrlBlock Struct:g_BGNDTaskTCB.uBytesFreeOnStackMin
Mask:FFFFFFFF Gain:1.0 Offset:0.0 Exp:1.0 Min:0.000000 Max:65535.000000 Format:8.0 UpdateID:BACKGND
Group:"System | Memory" Help:"Remaining bytes available on the BGNDTask stack" Unit:bytes */

/* Name: BGNDTaskCPU ClassID:VAR StorageID:RAM Access:RO4+RO3+RO2+RO1 TypeID:UINT2 CType:S_TaskCtrlBlock Struct:g_BGNDTaskTCB.u16TimerValue
Mask:FFFFFFFF Gain:0.0015259 Offset:0.0 Exp:1.0 Min:0.000000 Max:100.000000 Format:4.2 UpdateID:BACKGND
Group:"System | Performance" Help:"Percentage of CPU spent on BGNDTask task" Unit:% */
	
InstantiateMailBox_SingleSemaphore(g_FGNDTask_MailBox);
InstantiateTask(g_FGNDTask, 2, MotoCoder_TaskEventQueue_Execute, "FGNDTask", &g_FGNDTask_MailBox, 3072);
	
/* Name: FGNDTaskStackMinBytesFree ClassID:VAR StorageID:RAM Access:RO4+RO3+RO2+RO1 TypeID:UINT2 CType:S_TaskCtrlBlock Struct:g_FGNDTaskTCB.uBytesFreeOnStackMin
Mask:FFFFFFFF Gain:1.0 Offset:0.0 Exp:1.0 Min:0.000000 Max:65535.000000 Format:8.0 UpdateID:BACKGND
Group:"System | Memory" Help:"Remaining bytes available on the FGNDTask stack" Unit:bytes */

/* Name: FGNDTaskCPU ClassID:VAR StorageID:RAM Access:RO4+RO3+RO2+RO1 TypeID:UINT2 CType:S_TaskCtrlBlock Struct:g_FGNDTaskTCB.u16TimerValue
Mask:FFFFFFFF Gain:0.0015259 Offset:0.0 Exp:1.0 Min:0.000000 Max:100.000000 Format:4.2 UpdateID:BACKGND
Group:"System | Performance" Help:"Percentage of CPU spent on FGNDTask task" Unit:% */
	
InstantiateMailBox_SingleSemaphore(g_SHUTDOWNTask_MailBox);
InstantiateTask(g_SHUTDOWNTask, 3, MotoCoder_TaskEventQueue_Execute, "SHUTDOWNTask", &g_SHUTDOWNTask_MailBox, 1024);
	
/* Name: SHUTDOWNTaskStackMinBytesFree ClassID:VAR StorageID:RAM Access:RO4+RO3+RO2+RO1 TypeID:UINT2 CType:S_TaskCtrlBlock Struct:g_SHUTDOWNTaskTCB.uBytesFreeOnStackMin
Mask:FFFFFFFF Gain:1.0 Offset:0.0 Exp:1.0 Min:0.000000 Max:65535.000000 Format:8.0 UpdateID:BACKGND
Group:"System | Memory" Help:"Remaining bytes available on the SHUTDOWNTask stack" Unit:bytes */

/* Name: SHUTDOWNTaskCPU ClassID:VAR StorageID:RAM Access:RO4+RO3+RO2+RO1 TypeID:UINT2 CType:S_TaskCtrlBlock Struct:g_SHUTDOWNTaskTCB.u16TimerValue
Mask:FFFFFFFF Gain:0.0015259 Offset:0.0 Exp:1.0 Min:0.000000 Max:100.000000 Format:4.2 UpdateID:BACKGND
Group:"System | Performance" Help:"Percentage of CPU spent on SHUTDOWNTask task" Unit:% */
	
InstantiateMailBox_SingleSemaphore(g_ApplicationInterruptTask_MailBox);
InstantiateTask(g_ApplicationInterruptTask, 4, MotoCoder_TaskEventQueue_Execute, "ApplicationInterruptTask", &g_ApplicationInterruptTask_MailBox, 1024);
	
/* Name: ApplicationInterruptTaskStackMinBytesFree ClassID:VAR StorageID:RAM Access:RO4+RO3+RO2+RO1 TypeID:UINT2 CType:S_TaskCtrlBlock Struct:g_ApplicationInterruptTaskTCB.uBytesFreeOnStackMin
Mask:FFFFFFFF Gain:1.0 Offset:0.0 Exp:1.0 Min:0.000000 Max:65535.000000 Format:8.0 UpdateID:BACKGND
Group:"System | Memory" Help:"Remaining bytes available on the ApplicationInterruptTask stack" Unit:bytes */

/* Name: ApplicationInterruptTaskCPU ClassID:VAR StorageID:RAM Access:RO4+RO3+RO2+RO1 TypeID:UINT2 CType:S_TaskCtrlBlock Struct:g_ApplicationInterruptTaskTCB.u16TimerValue
Mask:FFFFFFFF Gain:0.0015259 Offset:0.0 Exp:1.0 Min:0.000000 Max:100.000000 Format:4.2 UpdateID:BACKGND
Group:"System | Performance" Help:"Percentage of CPU spent on ApplicationInterruptTask task" Unit:% */
	

/* Variables used by scheduler */
uint8_T g_bAppOpen;
static uint32_T RTICounter_1000000 = 0;
static uint32_T RTICounter_50000 = 0;


/*---- FUNCTION CODE --------------------------------------------------------------------------------------*/

#define AppMonitor_IsAppRunning()  (1)        
    

void ApplicationInit(void)
{
    
    
        /* Application Startup */
    {extern void OpenApplication(void);
        OpenApplication();
    }
}

/* Application Startup */
void ApplicationOpen(void)
{

    /* Boot Status */
    g_bWasPowerUpStatusWarm = (uint8_T)ControlCore_PowerUpStatus_Query_WasWarm();
    
    
    /* Create Other User Tasks */
    MailBox_CreateStatic(&g_ApplicationInterruptTask_MailBox, 0);
    Task_CreateStatic(&g_ApplicationInterruptTask, TASK_CREATE_STATE_SUSPENDED);
    
    MailBox_CreateStatic(&g_SHUTDOWNTask_MailBox, 0);
    Task_CreateStatic(&g_SHUTDOWNTask, TASK_CREATE_STATE_SUSPENDED);
    
    MailBox_CreateStatic(&g_FGNDTask_MailBox, 0);
    Task_CreateStatic(&g_FGNDTask, TASK_CREATE_STATE_SUSPENDED);
    
    MailBox_CreateStatic(&g_BGNDTask_MailBox, 0);
    Task_CreateStatic(&g_BGNDTask, TASK_CREATE_STATE_SUSPENDED);
    
    
    /* Application Startup */
    {extern void ReadModuleConfig(void);
        ReadModuleConfig();
    }
    {extern void OpenMemory(void);
        OpenMemory();
    }
    {extern void Timer_FreeRunningCounter_ResetTime(void);
        Timer_FreeRunningCounter_ResetTime();
    }
    {extern void IO_Create(void);
        IO_Create();
    }
    {extern void NonVolatile_OpenDataStore(void);
        NonVolatile_OpenDataStore();
    }
    {extern void ApplicationInit(void);
        ApplicationInit();
    }
    {extern void KeySuite_Create(void);
        KeySuite_Create();
    }
    /* Start Other User Tasks */
    Task_Activate(&g_ApplicationInterruptTask);
    
    Task_Activate(&g_SHUTDOWNTask);
    
    Task_Activate(&g_FGNDTask);
    
    Task_Activate(&g_BGNDTask);
    
}

/* Main entry point at reset */
NativeVar_S MainAppTask(void* in_pAppTaskInfo)
{
	ApplicationOpen();
	g_bAppOpen = 1;

    /* Application's idle loop. This loop will execute with more priority than TRUE idle while ensuring that
       it does yield to ControlCore idle. Yielding to ControlCore idle ensures that operating properly metrics
       like starvation are handled. Unless otherwise configured, ControlCore assumes that 100% CPU utilization
       does not occur for extended periods of time. This premise would be broken if the application never yielded
       its Idle loop */
    {
        S_AppTaskParamInfo* const pAppTaskInfo = in_pAppTaskInfo;
        do
        {
            /* Application's Idle Loop Work */
			
    {extern void KeySuite_MessageHandler(void);
        KeySuite_MessageHandler();
    }
    {extern void KeySuite_RefreshPeriodicTimer(void);
        KeySuite_RefreshPeriodicTimer();
    }
          /* Waiting on IdleLoopCompleteEvent allows Control Core to perform idle tasks
		      such as calculation of stack metrics and management of the task starvation timer */
        } while(SUCCESS(SyncObj_WaitOn(pAppTaskInfo->hIdleLoopCompleteEvent, WAIT_INDEFINITELY)));
    }
	
	return 0;
}


/* Periodic Tasks */

void FGNDTask_5000(void)
{

    {extern void Trigger_FGND_RTI_PERIODIC_5730p0001(void);
        Trigger_FGND_RTI_PERIODIC_5730p0001();
    }
}

void BGNDTask_1000000(void)
{

    {extern void FaultManagerPeriodicTick(void);
        FaultManagerPeriodicTick();
    }
    {extern void MotoHawkModelSecondsInUseTick(void);
        MotoHawkModelSecondsInUseTick();
    }
}

void BGNDTask_50000(void)
{

    {extern void Trigger_BGND_BASE_PERIODIC_5721p0001(void);
        Trigger_BGND_BASE_PERIODIC_5721p0001();
    }
}

/* SHUTDOWN  triggers */
void SHUTDOWNTask_SendEvent(void)
{
    
}

/* SHUTDOWN Task */
void SHUTDOWNTask_PostEvent(void)
{
{
    extern void MotoCoder_TaskEvent_Post(S_MessageBoxDefn const* const in_pMailBox, void (*FuncPtr)(void));
	extern void SHUTDOWNTask_SendEvent(void);
	extern const S_MessageBoxDefn g_SHUTDOWNTask_MailBox;
	MotoCoder_TaskEvent_Post(&g_SHUTDOWNTask_MailBox, SHUTDOWNTask_SendEvent);
}
}

/* Name: CPUIdlePcnt ClassID:VAR StorageID:RAM Access:RO4+RO3+RO2+RO1 TypeID:UINT2 CType:uint16_T Struct:g_u16CPUIdlePcnt
Mask:FFFFFFFF Gain:0.0015259 Offset:0.0 Exp:1.0 Min:0.000000 Max:100.000000 Format:4.2 UpdateID:BACKGND
Group:"System | Performance" Help:"Percentage of CPU spent executing idle activity" Unit:% */
uint16_T g_u16CPUIdlePcnt;
void App_RTITimer_OnTick(void)
{
    /* Calculate CPUIdlePcnt */
    {
         /* CPUIdlePcnt for the ComponentControlCore Tasking system can be determined by summing the time spent executing
           the ComponentControlCore Kernel's Idle task with the Application Task. As the Application Task is also used for
           the execution of open activities, its data will be slightly skewed during start-up. */
        extern S_TaskCtrlBlock g_IdleTaskTCB;
        g_u16CPUIdlePcnt = g_IdleTaskTCB.u16TimerValue + g_AppTaskTCB.u16TimerValue;
    }
	if (g_bAppOpen)
	{{
    extern void MotoCoder_TaskEvent_Post(S_MessageBoxDefn const* const in_pMailBox, void (*FuncPtr)(void));
	extern void FGNDTask_5000(void);
	extern const S_MessageBoxDefn g_FGNDTask_MailBox;
	MotoCoder_TaskEvent_Post(&g_FGNDTask_MailBox, FGNDTask_5000);
}
		RTICounter_50000++;
		if (RTICounter_50000 >= 10)
		{
			RTICounter_50000 = 0;
		 {
    extern void MotoCoder_TaskEvent_Post(S_MessageBoxDefn const* const in_pMailBox, void (*FuncPtr)(void));
	extern void BGNDTask_50000(void);
	extern const S_MessageBoxDefn g_BGNDTask_MailBox;
	MotoCoder_TaskEvent_Post(&g_BGNDTask_MailBox, BGNDTask_50000);
}
		}
		RTICounter_1000000++;
		if (RTICounter_1000000 >= 200)
		{
			RTICounter_1000000 = 0;
		 {
    extern void MotoCoder_TaskEvent_Post(S_MessageBoxDefn const* const in_pMailBox, void (*FuncPtr)(void));
	extern void BGNDTask_1000000(void);
	extern const S_MessageBoxDefn g_BGNDTask_MailBox;
	MotoCoder_TaskEvent_Post(&g_BGNDTask_MailBox, BGNDTask_1000000);
}
		}
	}
}

NativeVar_S MotoCoder_TaskEventQueue_Execute(void *mailBox)
{
	void (*fcnPtr)(void);
	MailBoxHandle hHandle;
	NativeError_S sError;
	
	hHandle = (MailBoxHandle) mailBox;
	if (hHandle)
	{
		do
		{
			sError = MailBox_FetchFrom(hHandle, (void**)&fcnPtr, WAIT_INDEFINITELY);
			if (SUCCESS(sError))
			{
				if( (fcnPtr) && (g_bAppOpen != 0) )
				{
					(*fcnPtr)();
				}
			}
		} while(SUCCESS(sError));
    }

	return (0);
}

void MotoCoder_TaskEvent_Post(S_MessageBoxDefn const* const in_pMailBox, void (*FuncPtr)(void))
{
    extern boolean_T g_bAppOpen;
    
    if(g_bAppOpen != 0)
    {
        MailBox_PostTo(in_pMailBox, FuncPtr, 0);
    }
}




/*---- eTPU SETUP --------------------------------------------------------------------------------*/

/* eTPU setup */

E_FPSCK const g_eTPUFilterPreScale = FPSCK_SYS_CLK_DIV_2;
E_CDFC const g_eTPUDigitalFilterCtrl = CDFC_CONTINUOUS_SAMPLE_MODE;
E_TCRCF const g_eTPUTCRCLKFilter = TCRCF_2SAMPLE_SYSCLK_DIV2;
	
		
/* Set to TRUE when eTPU_Open() is called */
bool1 const g_bIsAppUsingETPU = TRUE;

void eTPU_Startup(void)
{
	eTPU_Open(ETPU_0, &g_TPUMaskDefn_EngineBasic);
}



S_eTPU_ISR_Defn const g_eTPU_ISRArr[NUM_ETPU_CHANNELS] = 
{
/* { CPU Behavior ISR, Device Specific Context} */
	/* ETPU_A0 */ {NULL, NULL },
	/* ETPU_A1 */ {NULL, NULL },
	/* ETPU_A2 */ {NULL, NULL },
	/* ETPU_A3 */ {NULL, NULL },
	/* ETPU_A4 */ {NULL, NULL },
	/* ETPU_A5 */ {NULL, NULL },
	/* ETPU_A6 */ {NULL, NULL },
	/* ETPU_A7 */ {NULL, NULL },
	/* ETPU_A8 */ {NULL, NULL },
	/* ETPU_A9 */ {NULL, NULL },
	/* ETPU_A10 */ {NULL, NULL },
	/* ETPU_A11 */ {NULL, NULL },
	/* ETPU_A12 */ {NULL, NULL },
	/* ETPU_A13 */ {NULL, NULL },
	/* ETPU_A14 */ {NULL, NULL },
	/* ETPU_A15 */ {NULL, NULL },
	/* ETPU_A16 */ {NULL, NULL },
	/* ETPU_A17 */ {NULL, NULL },
	/* ETPU_A18 */ {NULL, NULL },
	/* ETPU_A19 */ {NULL, NULL },
	/* ETPU_A20 */ {NULL, NULL },
	/* ETPU_A21 */ {NULL, NULL },
	/* ETPU_A22 */ {NULL, NULL },
	/* ETPU_A23 */ {NULL, NULL },
	/* ETPU_A24 */ {NULL, NULL },
	/* ETPU_A25 */ {NULL, NULL },
	/* ETPU_A26 */ {NULL, NULL },
	/* ETPU_A27 */ {NULL, NULL },
	/* ETPU_A28 */ {NULL, NULL },
	/* ETPU_A29 */ {NULL, NULL },
	/* ETPU_A30 */ {NULL, NULL },
	/* ETPU_A31 */ {NULL, NULL },
	/* ETPU_B0 */ {NULL, NULL },
	/* ETPU_B1 */ {NULL, NULL },
	/* ETPU_B2 */ {NULL, NULL },
	/* ETPU_B3 */ {NULL, NULL },
	/* ETPU_B4 */ {NULL, NULL },
	/* ETPU_B5 */ {NULL, NULL },
	/* ETPU_B6 */ {NULL, NULL },
	/* ETPU_B7 */ {NULL, NULL },
	/* ETPU_B8 */ {NULL, NULL },
	/* ETPU_B9 */ {NULL, NULL },
	/* ETPU_B10 */ {NULL, NULL },
	/* ETPU_B11 */ {NULL, NULL },
	/* ETPU_B12 */ {NULL, NULL },
	/* ETPU_B13 */ {NULL, NULL },
	/* ETPU_B14 */ {NULL, NULL },
	/* ETPU_B15 */ {NULL, NULL },
	/* ETPU_B16 */ {NULL, NULL },
	/* ETPU_B17 */ {NULL, NULL },
	/* ETPU_B18 */ {NULL, NULL },
	/* ETPU_B19 */ {NULL, NULL },
	/* ETPU_B20 */ {NULL, NULL },
	/* ETPU_B21 */ {NULL, NULL },
	/* ETPU_B22 */ {NULL, NULL },
	/* ETPU_B23 */ {NULL, NULL },
	/* ETPU_B24 */ {NULL, NULL },
	/* ETPU_B25 */ {NULL, NULL },
	/* ETPU_B26 */ {NULL, NULL },
	/* ETPU_B27 */ {NULL, NULL },
	/* ETPU_B28 */ {NULL, NULL },
	/* ETPU_B29 */ {NULL, NULL },
	/* ETPU_B30 */ {NULL, NULL },
	/* ETPU_B31 */ {NULL, NULL },

};

S_eTPU_ISRObj const g_eTPU_ISRObj =
{
	g_eTPU_ISRArr,
};





/*---- eMIOS SETUP --------------------------------------------------------------------------------*/


/* Request that the TickTimer employ eMIOS_1 as its timer resource */
E_eMIOSUnifiedChannel const g_eMIOSTickTimerChannel = eMIOS_1;

/* Request that the TickTimer, when implemented using the eMIOS subsystem, employ a INTCPRIORITY_5. */
E_INTCPriority const g_eMIOSTickTimerISRPriority = INTCPRIORITY_5;

/* Specify that the TickTimer mode shall be implemented using the eMIOS method */
E_TickTimerMode const g_eTickTimerMode = TICK_TIMER_MODE_EMIOS;
    

S_eMIOS_ISR_Defn const g_eMIOS_ISRArr[NUM_EMIOS_CHANNELS] = 
{
	/* EMIOS_0 */ {NULL, NULL },
	/* EMIOS_1 */ {eMIOS_TickTimer_ISR, NULL },
	/* EMIOS_2 */ {NULL, NULL },
	/* EMIOS_3 */ {NULL, NULL },
	/* EMIOS_4 */ {NULL, NULL },
	/* EMIOS_5 */ {NULL, NULL },
	/* EMIOS_6 */ {NULL, NULL },
	/* EMIOS_7 */ {NULL, NULL },
	/* EMIOS_8 */ {NULL, NULL },
	/* EMIOS_9 */ {NULL, NULL },
	/* EMIOS_10 */ {NULL, NULL },
	/* EMIOS_11 */ {NULL, NULL },
	/* EMIOS_12 */ {NULL, NULL },
	/* EMIOS_13 */ {NULL, NULL },
	/* EMIOS_14 */ {NULL, NULL },
	/* EMIOS_15 */ {NULL, NULL },
	/* EMIOS_16 */ {NULL, NULL },
	/* EMIOS_17 */ {NULL, NULL },
	/* EMIOS_18 */ {NULL, NULL },
	/* EMIOS_19 */ {NULL, NULL },
	/* EMIOS_20 */ {NULL, NULL },
	/* EMIOS_21 */ {NULL, NULL },
	/* EMIOS_22 */ {NULL, NULL },
	/* EMIOS_23 */ {NULL, NULL },

};



/*---- eSCI SETUP -----------------------------------------------------------------------------------------*/

S_SCIModuleDefn const* const g_SCIModuleDefnArr[NUM_ESCI_MODULES] = 
{
    /* ESCI_A */   NULL,
    /* ESCI_B */   NULL,

};



