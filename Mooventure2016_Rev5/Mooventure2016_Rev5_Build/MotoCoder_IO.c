
/* MotoCoder_IO.c */
/* Generated by MotoCoder */
/* Version: 0.12.4 */
/* At: 2017-11-29 16:59:11 */
/* Copyright: 2017 Woodward. */


#include <MotoCoder_IO.h>
#include <MC33800.h>
#include <MC33800Output_DD_API.h>
#include <Module.h>
#include <Processor.h>
#include <Processor_Generic.h>
#include <DeviceDrivers_Generic.h>

void ESTOP2_DigitalInput_Create(void);

void SPI_C_Create(void);

extern const S_BasicOut_Defn_DiscreteOut ODRC;
	

void S_SHRC_3_Create(void);

void DOut5146p0001_DiscreteOutput_Create(void);
void DOut5146p0001_DiscreteOutput_Stop(void);

void DOut5147p0001_DiscreteOutput_Create(void);
void DOut5147p0001_DiscreteOutput_Stop(void);

void S_SHRC_4_Create(void);

void MC33800_INJ8_DiscreteOutput_Create(void);

extern const S_BasicOut_Defn_DiscreteOut DOut5148p0001;
	

void MC33800_INJ6_DiscreteOutput_Create(void);

extern const S_BasicOut_Defn_DiscreteOut DOut5149p0001;
	

void MC33800_INJ7_DiscreteOutput_Create(void);

extern const S_BasicOut_Defn_DiscreteOut DOut5150p0001;
	

void MC33800_INJ5_DiscreteOutput_Create(void);

extern const S_BasicOut_Defn_DiscreteOut DOut5151p0001;
	

void MC33800_LSO2_DiscreteOutput_Create(void);

extern const S_BasicOut_Defn_DiscreteOut DOut5152p0001;
	

void MC33800_INJ4_DiscreteOutput_Create(void);

extern const S_BasicOut_Defn_DiscreteOut DOut5153p0001;
	

void MC33800_INJ3_DiscreteOutput_Create(void);

extern const S_BasicOut_Defn_DiscreteOut DOut5154p0001;
	

void MC33800_INJ2_DiscreteOutput_Create(void);

extern const S_BasicOut_Defn_DiscreteOut DOut5155p0001;
	

void DOut5156p0001_DiscreteOutput_Create(void);
void DOut5156p0001_DiscreteOutput_Stop(void);

void DOut5157p0001_DiscreteOutput_Create(void);
void DOut5157p0001_DiscreteOutput_Stop(void);

void DOut5158p0001_DiscreteOutput_Create(void);
void DOut5158p0001_DiscreteOutput_Stop(void);

void MC33800_LSO9_DiscreteOutput_Create(void);

extern const S_BasicOut_Defn_DiscreteOut DOut5384p0001;
	

void DOut5385p0001_DiscreteOutput_Create(void);
void DOut5385p0001_DiscreteOutput_Stop(void);

void DOut5386p0001_DiscreteOutput_Create(void);
void DOut5386p0001_DiscreteOutput_Stop(void);

void MC33800_LSO10_DiscreteOutput_Create(void);

extern const S_BasicOut_Defn_DiscreteOut DOut5387p0001;
	

void MC33800_LSO8_DiscreteOutput_Create(void);

extern const S_BasicOut_Defn_DiscreteOut DOut5388p0001;
	

void DOut5389p0001_DiscreteOutput_Create(void);
void DOut5389p0001_DiscreteOutput_Stop(void);

void MC33800_MPRD_DiscreteOutput_Create(void);

extern const S_BasicOut_Defn_DiscreteOut DOut6546p0005;
	

void SPI_B_Create(void);

void VISTA_1_Create(void);

void DRVP_Create(void);

void ContinuousScan_eQADCQueue_Create(void);

extern const S_AnalogQueueDefn ContinuousScan_eQADCQueue;
	

void H1m_PWMOutput_Stop(void);

extern const S_BasicOut_Defn_DiscreteOut H1_InhibitB;
	

void H1m_PWMOutput_PWMOutput_Stop(void);

void SPI_D_Create(void);

void EEPROM_1_Create(void);

void MotoCoder_DiscreteOutput_UpdateOnChange_Create(S_BasicOut_Defn_DiscreteOut const* const in_pDefn, E_ResourceState* const in_peState, E_ResourceState in_eInitialState);
void MotoCoder_DiscreteOutput_UpdateOnChange_Set(S_BasicOut_Defn_DiscreteOut const* const in_pDefn, E_ResourceState* const in_peState, boolean_T value);
void MotoCoder_DiscreteOutput_UpdateOnChange_Stop(S_BasicOut_Defn_DiscreteOut const* const in_pDefn, E_ResourceState* const in_peState);
void DOut5148p0001_DiscreteOutput_Create(void);
void DOut5148p0001_DiscreteOutput_Stop(void);
void DOut5149p0001_DiscreteOutput_Create(void);
void DOut5149p0001_DiscreteOutput_Stop(void);
void DOut5150p0001_DiscreteOutput_Create(void);
void DOut5150p0001_DiscreteOutput_Stop(void);
void DOut5151p0001_DiscreteOutput_Create(void);
void DOut5151p0001_DiscreteOutput_Stop(void);
void DOut5152p0001_DiscreteOutput_Create(void);
void DOut5152p0001_DiscreteOutput_Stop(void);
void DOut5153p0001_DiscreteOutput_Create(void);
void DOut5153p0001_DiscreteOutput_Stop(void);
void DOut5154p0001_DiscreteOutput_Create(void);
void DOut5154p0001_DiscreteOutput_Stop(void);
void DOut5155p0001_DiscreteOutput_Create(void);
void DOut5155p0001_DiscreteOutput_Stop(void);
void DOut5384p0001_DiscreteOutput_Create(void);
void DOut5384p0001_DiscreteOutput_Stop(void);
void DOut5387p0001_DiscreteOutput_Create(void);
void DOut5387p0001_DiscreteOutput_Stop(void);
void DOut5388p0001_DiscreteOutput_Create(void);
void DOut5388p0001_DiscreteOutput_Stop(void);
void DOut6546p0005_DiscreteOutput_Create(void);
void DOut6546p0005_DiscreteOutput_Stop(void);
void H1_InhibitB_DiscreteOutput_Create(void);
void H1_InhibitB_DiscreteOutput_Stop(void);
void MotoCoder_DiscreteOutput_UpdateAlways_Create(S_BasicOut_Defn_DiscreteOut const* const in_pDefn, E_ResourceState in_eInitialState);
void ODRC_DiscreteOutput_Create(void);

INSTANTIATE_DGIn_DigitalIn(ESTOP2,
    CPUCore_0, CPU, GPIO_180_AE15, GPIO,
    INPUT_IS_INVERTING);
void ESTOP2_DigitalInput_Create(void)
{
    S_DGIn_Create_DigitalIn CreateObj;
    
    CreateObj.DGIn_Create.uValidAttributesMask = DGIN_USE_DEFAULTS;
    DGIn_DigitalInput_Create(&ESTOP2, &CreateObj);
}
boolean_T ESTOP2_DigitalInput_Get(void)
{
    S_DigitalInputRuntimedata RuntimeObj;
    DGIn_DigitalInput_GetAttributes(&ESTOP2, &RuntimeObj);
    return (RuntimeObj.eState == RES_PINSTATE_HIGH);
}

INSTANTIATE_SPI_MODULE_DEFN(
		SPI_C,
		DSPI_C,
        1);
void SPI_C_Create(void)
{
	INSTANTIATE_SPI_MODULE_ATTRIBUTES(SPI_C_,
		DSPI_C,
		1,
		0,
		USE_SPI_CS0 | USE_SPI_CS1 | USE_SPI_CS2);

	SPI_C.pMethods->pfnCreate(&SPI_C, &SPI_C_Attrib);
}

INSTANTIATE_MC33800_Hardware(
		S_SHRC_3,
		SPI_C,
		USE_SPI_CS0,
        NULL,
		0,
		20000,
		1000000,
        1);
void S_SHRC_3_Create(void)
{
	S_MC33800CreateAttributes CreateObj;
	CreateObj.uValidAttributesMask = USE_MC33800_DEFAULTS;
	MC33800_Hardware_Create(&S_SHRC_3, &CreateObj);
}

INSTANTIATE_MC33800Output_DiscreteOut(DOut5146p0001,
	MC33800_CCD1,
	CCD,
	RES_POL_ACTIVE_LOW,
	OUTPUT_IS_INVERTING,
	S_SHRC_3);



#include <Pragma_Section_Start_SDA.h>
E_ResourceState DOut5146p0001_State;
#include <Pragma_Section_End_SDA.h>
void DOut5146p0001_DiscreteOutput_Create(void)
{
	S_MC33800Output_Create_DiscreteOut CreateObj;
	
	CreateObj.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	
	CreateObj.DiscreteOutCreateAttribs.eInitialState = RES_OFF;

    /* Cache state because UseUpdateOnlyOnChange was true */
    DOut5146p0001_State = CreateObj.DiscreteOutCreateAttribs.eInitialState;


	CreateObj.DiagnosticsCreateAttribs.uValidAttributesMask =
		  USE_DIAGNOSTICS_OPEN_LOAD_CURRENT
		| USE_DIAGNOSTICS_OVER_VOLATGE_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_TIMER
		| USE_DIAGNOSTICS_TEMPERATURE_PROTECTION;
	
	CreateObj.DiagnosticsCreateAttribs.OverVoltageAction = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.ShortFaultAction  = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.u32ShortFaultTimer_uSec = 120;
	CreateObj.DiagnosticsCreateAttribs.u32VoltageThreshold_mVolt = 2000;

	CreateObj.CircuitCreate.uValidAttributesMask = USE_MC33800OUTPUT_DEFAULTS;
	
	MC33800_DiscreteOut_Create(&DOut5146p0001, &CreateObj);
}
void DOut5146p0001_DiscreteOutput_Set(boolean_T value)
{
    E_ResourceState eState;

    eState = value ? RES_ON : RES_OFF;

    Interrupt_DisableApp();
    if ((DOut5146p0001_State & 0x80) == 0)
    {   /* Object is not currently undergoing modification */
        if (DOut5146p0001_State != eState)
        {
            DOut5146p0001_State = eState | 0x80;
            Interrupt_EnableApp();
            MC33800_DiscreteOut_State_Set(&DOut5146p0001, eState);
            Interrupt_DisableApp();
            DOut5146p0001_State = DOut5146p0001_State & 0x7F;
        }
    }
    else
    {
        /* Another thread is already modifying this object so ignore this request */
    }
    Interrupt_EnableApp();

}
void DOut5146p0001_DiscreteOutput_Stop(void)
{

    /* IO Stop is called on shutdown. It should override the state being set by another thread.
       The expectation is that normal operation shall not resume without effectively restarting the code */
    DOut5146p0001_State = RES_OFF;

	MC33800_DiscreteOut_State_Set(&DOut5146p0001, RES_OFF);
}

INSTANTIATE_MC33800Output_DiscreteOut(DOut5147p0001,
	MC33800_OUT1,
	OSS,
	RES_POL_ACTIVE_LOW,
	OUTPUT_IS_INVERTING,
	S_SHRC_3);



#include <Pragma_Section_Start_SDA.h>
E_ResourceState DOut5147p0001_State;
#include <Pragma_Section_End_SDA.h>
void DOut5147p0001_DiscreteOutput_Create(void)
{
	S_MC33800Output_Create_DiscreteOut CreateObj;
	
	CreateObj.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	
	CreateObj.DiscreteOutCreateAttribs.eInitialState = RES_OFF;

    /* Cache state because UseUpdateOnlyOnChange was true */
    DOut5147p0001_State = CreateObj.DiscreteOutCreateAttribs.eInitialState;


	CreateObj.DiagnosticsCreateAttribs.uValidAttributesMask =
		  USE_DIAGNOSTICS_OPEN_LOAD_CURRENT
		| USE_DIAGNOSTICS_OVER_VOLATGE_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_TIMER
		| USE_DIAGNOSTICS_TEMPERATURE_PROTECTION;
	
	CreateObj.DiagnosticsCreateAttribs.OverVoltageAction = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.ShortFaultAction  = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.u32ShortFaultTimer_uSec = 120;
	CreateObj.DiagnosticsCreateAttribs.u32VoltageThreshold_mVolt = 2000;

	CreateObj.CircuitCreate.uValidAttributesMask = USE_MC33800OUTPUT_PARALLEL_OUTPUT;
	
	MC33800_DiscreteOut_Create(&DOut5147p0001, &CreateObj);
}
void DOut5147p0001_DiscreteOutput_Set(boolean_T value)
{
    E_ResourceState eState;

    eState = value ? RES_ON : RES_OFF;

    Interrupt_DisableApp();
    if ((DOut5147p0001_State & 0x80) == 0)
    {   /* Object is not currently undergoing modification */
        if (DOut5147p0001_State != eState)
        {
            DOut5147p0001_State = eState | 0x80;
            Interrupt_EnableApp();
            MC33800_DiscreteOut_State_Set(&DOut5147p0001, eState);
            Interrupt_DisableApp();
            DOut5147p0001_State = DOut5147p0001_State & 0x7F;
        }
    }
    else
    {
        /* Another thread is already modifying this object so ignore this request */
    }
    Interrupt_EnableApp();

}
void DOut5147p0001_DiscreteOutput_Stop(void)
{

    /* IO Stop is called on shutdown. It should override the state being set by another thread.
       The expectation is that normal operation shall not resume without effectively restarting the code */
    DOut5147p0001_State = RES_OFF;

	MC33800_DiscreteOut_State_Set(&DOut5147p0001, RES_OFF);
}

INSTANTIATE_MC33800_Hardware(
		S_SHRC_4,
		SPI_C,
		USE_SPI_CS1,
        NULL,
		1,
		20000,
		1000000,
        1);
void S_SHRC_4_Create(void)
{
	S_MC33800CreateAttributes CreateObj;
	CreateObj.uValidAttributesMask = USE_MC33800_DEFAULTS;
	MC33800_Hardware_Create(&S_SHRC_4, &CreateObj);
}

INSTANTIATE_MC33800Output_DiscreteOut(MC33800_INJ8,
	MC33800_PWM4,
	PWM,
	RES_POL_ACTIVE_LOW,
	OUTPUT_IS_INVERTING,
	S_SHRC_4);
void MC33800_INJ8_DiscreteOutput_Create(void)
{
	S_MC33800Output_Create_DiscreteOut CreateObj;
	
	CreateObj.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	
	CreateObj.DiscreteOutCreateAttribs.eInitialState = RES_OFF;


	CreateObj.DiagnosticsCreateAttribs.uValidAttributesMask =
		  USE_DIAGNOSTICS_OPEN_LOAD_CURRENT
		| USE_DIAGNOSTICS_OVER_VOLATGE_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_TIMER
		| USE_DIAGNOSTICS_TEMPERATURE_PROTECTION;
	
	CreateObj.DiagnosticsCreateAttribs.OverVoltageAction = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.ShortFaultAction  = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.u32ShortFaultTimer_uSec = 120;
	CreateObj.DiagnosticsCreateAttribs.u32VoltageThreshold_mVolt = 2000;

	CreateObj.CircuitCreate.uValidAttributesMask = USE_MC33800OUTPUT_PARALLEL_INPUT;
	
	MC33800_DiscreteOut_Create(&MC33800_INJ8, &CreateObj);
}

INSTANTIATE_MC33800Output_DiscreteOut(MC33800_INJ6,
	MC33800_PWM2,
	PWM,
	RES_POL_ACTIVE_LOW,
	OUTPUT_IS_INVERTING,
	S_SHRC_4);
void MC33800_INJ6_DiscreteOutput_Create(void)
{
	S_MC33800Output_Create_DiscreteOut CreateObj;
	
	CreateObj.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	
	CreateObj.DiscreteOutCreateAttribs.eInitialState = RES_OFF;


	CreateObj.DiagnosticsCreateAttribs.uValidAttributesMask =
		  USE_DIAGNOSTICS_OPEN_LOAD_CURRENT
		| USE_DIAGNOSTICS_OVER_VOLATGE_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_TIMER
		| USE_DIAGNOSTICS_TEMPERATURE_PROTECTION;
	
	CreateObj.DiagnosticsCreateAttribs.OverVoltageAction = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.ShortFaultAction  = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.u32ShortFaultTimer_uSec = 120;
	CreateObj.DiagnosticsCreateAttribs.u32VoltageThreshold_mVolt = 2000;

	CreateObj.CircuitCreate.uValidAttributesMask = USE_MC33800OUTPUT_PARALLEL_INPUT;
	
	MC33800_DiscreteOut_Create(&MC33800_INJ6, &CreateObj);
}

INSTANTIATE_MC33800Output_DiscreteOut(MC33800_INJ7,
	MC33800_PWM3,
	PWM,
	RES_POL_ACTIVE_LOW,
	OUTPUT_IS_INVERTING,
	S_SHRC_4);
void MC33800_INJ7_DiscreteOutput_Create(void)
{
	S_MC33800Output_Create_DiscreteOut CreateObj;
	
	CreateObj.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	
	CreateObj.DiscreteOutCreateAttribs.eInitialState = RES_OFF;


	CreateObj.DiagnosticsCreateAttribs.uValidAttributesMask =
		  USE_DIAGNOSTICS_OPEN_LOAD_CURRENT
		| USE_DIAGNOSTICS_OVER_VOLATGE_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_TIMER
		| USE_DIAGNOSTICS_TEMPERATURE_PROTECTION;
	
	CreateObj.DiagnosticsCreateAttribs.OverVoltageAction = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.ShortFaultAction  = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.u32ShortFaultTimer_uSec = 120;
	CreateObj.DiagnosticsCreateAttribs.u32VoltageThreshold_mVolt = 2000;

	CreateObj.CircuitCreate.uValidAttributesMask = USE_MC33800OUTPUT_PARALLEL_INPUT;
	
	MC33800_DiscreteOut_Create(&MC33800_INJ7, &CreateObj);
}

INSTANTIATE_MC33800Output_DiscreteOut(MC33800_INJ5,
	MC33800_PWM1,
	PWM,
	RES_POL_ACTIVE_LOW,
	OUTPUT_IS_INVERTING,
	S_SHRC_4);
void MC33800_INJ5_DiscreteOutput_Create(void)
{
	S_MC33800Output_Create_DiscreteOut CreateObj;
	
	CreateObj.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	
	CreateObj.DiscreteOutCreateAttribs.eInitialState = RES_OFF;


	CreateObj.DiagnosticsCreateAttribs.uValidAttributesMask =
		  USE_DIAGNOSTICS_OPEN_LOAD_CURRENT
		| USE_DIAGNOSTICS_OVER_VOLATGE_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_TIMER
		| USE_DIAGNOSTICS_TEMPERATURE_PROTECTION;
	
	CreateObj.DiagnosticsCreateAttribs.OverVoltageAction = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.ShortFaultAction  = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.u32ShortFaultTimer_uSec = 120;
	CreateObj.DiagnosticsCreateAttribs.u32VoltageThreshold_mVolt = 2000;

	CreateObj.CircuitCreate.uValidAttributesMask = USE_MC33800OUTPUT_PARALLEL_INPUT;
	
	MC33800_DiscreteOut_Create(&MC33800_INJ5, &CreateObj);
}

INSTANTIATE_MC33800Output_DiscreteOut(MC33800_LSO2,
	MC33800_OUT3,
	OSS,
	RES_POL_ACTIVE_LOW,
	OUTPUT_IS_INVERTING,
	S_SHRC_3);
void MC33800_LSO2_DiscreteOutput_Create(void)
{
	S_MC33800Output_Create_DiscreteOut CreateObj;
	
	CreateObj.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	
	CreateObj.DiscreteOutCreateAttribs.eInitialState = RES_OFF;


	CreateObj.DiagnosticsCreateAttribs.uValidAttributesMask =
		  USE_DIAGNOSTICS_OPEN_LOAD_CURRENT
		| USE_DIAGNOSTICS_OVER_VOLATGE_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_TIMER
		| USE_DIAGNOSTICS_TEMPERATURE_PROTECTION;
	
	CreateObj.DiagnosticsCreateAttribs.OverVoltageAction = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.ShortFaultAction  = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.u32ShortFaultTimer_uSec = 120;
	CreateObj.DiagnosticsCreateAttribs.u32VoltageThreshold_mVolt = 2000;

	CreateObj.CircuitCreate.uValidAttributesMask = USE_MC33800OUTPUT_PARALLEL_INPUT | USE_MC33800OUTPUT_PARALLEL_OUTPUT;
	
	MC33800_DiscreteOut_Create(&MC33800_LSO2, &CreateObj);
}

INSTANTIATE_MC33800Output_DiscreteOut(MC33800_INJ4,
	MC33800_PWM4,
	PWM,
	RES_POL_ACTIVE_LOW,
	OUTPUT_IS_INVERTING,
	S_SHRC_3);
void MC33800_INJ4_DiscreteOutput_Create(void)
{
	S_MC33800Output_Create_DiscreteOut CreateObj;
	
	CreateObj.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	
	CreateObj.DiscreteOutCreateAttribs.eInitialState = RES_OFF;


	CreateObj.DiagnosticsCreateAttribs.uValidAttributesMask =
		  USE_DIAGNOSTICS_OPEN_LOAD_CURRENT
		| USE_DIAGNOSTICS_OVER_VOLATGE_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_TIMER
		| USE_DIAGNOSTICS_TEMPERATURE_PROTECTION;
	
	CreateObj.DiagnosticsCreateAttribs.OverVoltageAction = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.ShortFaultAction  = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.u32ShortFaultTimer_uSec = 120;
	CreateObj.DiagnosticsCreateAttribs.u32VoltageThreshold_mVolt = 2000;

	CreateObj.CircuitCreate.uValidAttributesMask = USE_MC33800OUTPUT_PARALLEL_INPUT;
	
	MC33800_DiscreteOut_Create(&MC33800_INJ4, &CreateObj);
}

INSTANTIATE_MC33800Output_DiscreteOut(MC33800_INJ3,
	MC33800_PWM3,
	PWM,
	RES_POL_ACTIVE_LOW,
	OUTPUT_IS_INVERTING,
	S_SHRC_3);
void MC33800_INJ3_DiscreteOutput_Create(void)
{
	S_MC33800Output_Create_DiscreteOut CreateObj;
	
	CreateObj.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	
	CreateObj.DiscreteOutCreateAttribs.eInitialState = RES_OFF;


	CreateObj.DiagnosticsCreateAttribs.uValidAttributesMask =
		  USE_DIAGNOSTICS_OPEN_LOAD_CURRENT
		| USE_DIAGNOSTICS_OVER_VOLATGE_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_TIMER
		| USE_DIAGNOSTICS_TEMPERATURE_PROTECTION;
	
	CreateObj.DiagnosticsCreateAttribs.OverVoltageAction = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.ShortFaultAction  = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.u32ShortFaultTimer_uSec = 120;
	CreateObj.DiagnosticsCreateAttribs.u32VoltageThreshold_mVolt = 2000;

	CreateObj.CircuitCreate.uValidAttributesMask = USE_MC33800OUTPUT_PARALLEL_INPUT;
	
	MC33800_DiscreteOut_Create(&MC33800_INJ3, &CreateObj);
}

INSTANTIATE_MC33800Output_DiscreteOut(MC33800_INJ2,
	MC33800_PWM2,
	PWM,
	RES_POL_ACTIVE_LOW,
	OUTPUT_IS_INVERTING,
	S_SHRC_3);
void MC33800_INJ2_DiscreteOutput_Create(void)
{
	S_MC33800Output_Create_DiscreteOut CreateObj;
	
	CreateObj.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	
	CreateObj.DiscreteOutCreateAttribs.eInitialState = RES_OFF;


	CreateObj.DiagnosticsCreateAttribs.uValidAttributesMask =
		  USE_DIAGNOSTICS_OPEN_LOAD_CURRENT
		| USE_DIAGNOSTICS_OVER_VOLATGE_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_TIMER
		| USE_DIAGNOSTICS_TEMPERATURE_PROTECTION;
	
	CreateObj.DiagnosticsCreateAttribs.OverVoltageAction = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.ShortFaultAction  = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.u32ShortFaultTimer_uSec = 120;
	CreateObj.DiagnosticsCreateAttribs.u32VoltageThreshold_mVolt = 2000;

	CreateObj.CircuitCreate.uValidAttributesMask = USE_MC33800OUTPUT_PARALLEL_INPUT;
	
	MC33800_DiscreteOut_Create(&MC33800_INJ2, &CreateObj);
}

INSTANTIATE_MC33800Output_DiscreteOut(DOut5156p0001,
	MC33800_OUT2,
	OSS,
	RES_POL_ACTIVE_LOW,
	OUTPUT_IS_INVERTING,
	S_SHRC_4);



#include <Pragma_Section_Start_SDA.h>
E_ResourceState DOut5156p0001_State;
#include <Pragma_Section_End_SDA.h>
void DOut5156p0001_DiscreteOutput_Create(void)
{
	S_MC33800Output_Create_DiscreteOut CreateObj;
	
	CreateObj.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	
	CreateObj.DiscreteOutCreateAttribs.eInitialState = RES_OFF;

    /* Cache state because UseUpdateOnlyOnChange was true */
    DOut5156p0001_State = CreateObj.DiscreteOutCreateAttribs.eInitialState;


	CreateObj.DiagnosticsCreateAttribs.uValidAttributesMask =
		  USE_DIAGNOSTICS_OPEN_LOAD_CURRENT
		| USE_DIAGNOSTICS_OVER_VOLATGE_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_TIMER
		| USE_DIAGNOSTICS_TEMPERATURE_PROTECTION;
	
	CreateObj.DiagnosticsCreateAttribs.OverVoltageAction = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.ShortFaultAction  = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.u32ShortFaultTimer_uSec = 120;
	CreateObj.DiagnosticsCreateAttribs.u32VoltageThreshold_mVolt = 2000;

	CreateObj.CircuitCreate.uValidAttributesMask = USE_MC33800OUTPUT_DEFAULTS;
	
	MC33800_DiscreteOut_Create(&DOut5156p0001, &CreateObj);
}
void DOut5156p0001_DiscreteOutput_Set(boolean_T value)
{
    E_ResourceState eState;

    eState = value ? RES_ON : RES_OFF;

    Interrupt_DisableApp();
    if ((DOut5156p0001_State & 0x80) == 0)
    {   /* Object is not currently undergoing modification */
        if (DOut5156p0001_State != eState)
        {
            DOut5156p0001_State = eState | 0x80;
            Interrupt_EnableApp();
            MC33800_DiscreteOut_State_Set(&DOut5156p0001, eState);
            Interrupt_DisableApp();
            DOut5156p0001_State = DOut5156p0001_State & 0x7F;
        }
    }
    else
    {
        /* Another thread is already modifying this object so ignore this request */
    }
    Interrupt_EnableApp();

}
void DOut5156p0001_DiscreteOutput_Stop(void)
{

    /* IO Stop is called on shutdown. It should override the state being set by another thread.
       The expectation is that normal operation shall not resume without effectively restarting the code */
    DOut5156p0001_State = RES_OFF;

	MC33800_DiscreteOut_State_Set(&DOut5156p0001, RES_OFF);
}

INSTANTIATE_MC33800Output_DiscreteOut(DOut5157p0001,
	MC33800_OUT1,
	OSS,
	RES_POL_ACTIVE_LOW,
	OUTPUT_IS_INVERTING,
	S_SHRC_4);



#include <Pragma_Section_Start_SDA.h>
E_ResourceState DOut5157p0001_State;
#include <Pragma_Section_End_SDA.h>
void DOut5157p0001_DiscreteOutput_Create(void)
{
	S_MC33800Output_Create_DiscreteOut CreateObj;
	
	CreateObj.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	
	CreateObj.DiscreteOutCreateAttribs.eInitialState = RES_OFF;

    /* Cache state because UseUpdateOnlyOnChange was true */
    DOut5157p0001_State = CreateObj.DiscreteOutCreateAttribs.eInitialState;


	CreateObj.DiagnosticsCreateAttribs.uValidAttributesMask =
		  USE_DIAGNOSTICS_OPEN_LOAD_CURRENT
		| USE_DIAGNOSTICS_OVER_VOLATGE_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_TIMER
		| USE_DIAGNOSTICS_TEMPERATURE_PROTECTION;
	
	CreateObj.DiagnosticsCreateAttribs.OverVoltageAction = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.ShortFaultAction  = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.u32ShortFaultTimer_uSec = 120;
	CreateObj.DiagnosticsCreateAttribs.u32VoltageThreshold_mVolt = 2000;

	CreateObj.CircuitCreate.uValidAttributesMask = USE_MC33800OUTPUT_DEFAULTS;
	
	MC33800_DiscreteOut_Create(&DOut5157p0001, &CreateObj);
}
void DOut5157p0001_DiscreteOutput_Set(boolean_T value)
{
    E_ResourceState eState;

    eState = value ? RES_ON : RES_OFF;

    Interrupt_DisableApp();
    if ((DOut5157p0001_State & 0x80) == 0)
    {   /* Object is not currently undergoing modification */
        if (DOut5157p0001_State != eState)
        {
            DOut5157p0001_State = eState | 0x80;
            Interrupt_EnableApp();
            MC33800_DiscreteOut_State_Set(&DOut5157p0001, eState);
            Interrupt_DisableApp();
            DOut5157p0001_State = DOut5157p0001_State & 0x7F;
        }
    }
    else
    {
        /* Another thread is already modifying this object so ignore this request */
    }
    Interrupt_EnableApp();

}
void DOut5157p0001_DiscreteOutput_Stop(void)
{

    /* IO Stop is called on shutdown. It should override the state being set by another thread.
       The expectation is that normal operation shall not resume without effectively restarting the code */
    DOut5157p0001_State = RES_OFF;

	MC33800_DiscreteOut_State_Set(&DOut5157p0001, RES_OFF);
}

INSTANTIATE_MC33800Output_DiscreteOut(DOut5158p0001,
	MC33800_PWM6,
	PWM,
	RES_POL_ACTIVE_LOW,
	OUTPUT_IS_INVERTING,
	S_SHRC_3);



#include <Pragma_Section_Start_SDA.h>
E_ResourceState DOut5158p0001_State;
#include <Pragma_Section_End_SDA.h>
void DOut5158p0001_DiscreteOutput_Create(void)
{
	S_MC33800Output_Create_DiscreteOut CreateObj;
	
	CreateObj.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	
	CreateObj.DiscreteOutCreateAttribs.eInitialState = RES_OFF;

    /* Cache state because UseUpdateOnlyOnChange was true */
    DOut5158p0001_State = CreateObj.DiscreteOutCreateAttribs.eInitialState;


	CreateObj.DiagnosticsCreateAttribs.uValidAttributesMask =
		  USE_DIAGNOSTICS_OPEN_LOAD_CURRENT
		| USE_DIAGNOSTICS_OVER_VOLATGE_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_TIMER
		| USE_DIAGNOSTICS_TEMPERATURE_PROTECTION;
	
	CreateObj.DiagnosticsCreateAttribs.OverVoltageAction = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.ShortFaultAction  = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.u32ShortFaultTimer_uSec = 120;
	CreateObj.DiagnosticsCreateAttribs.u32VoltageThreshold_mVolt = 2000;

	CreateObj.CircuitCreate.uValidAttributesMask = USE_MC33800OUTPUT_DEFAULTS;
	
	MC33800_DiscreteOut_Create(&DOut5158p0001, &CreateObj);
}
void DOut5158p0001_DiscreteOutput_Set(boolean_T value)
{
    E_ResourceState eState;

    eState = value ? RES_ON : RES_OFF;

    Interrupt_DisableApp();
    if ((DOut5158p0001_State & 0x80) == 0)
    {   /* Object is not currently undergoing modification */
        if (DOut5158p0001_State != eState)
        {
            DOut5158p0001_State = eState | 0x80;
            Interrupt_EnableApp();
            MC33800_DiscreteOut_State_Set(&DOut5158p0001, eState);
            Interrupt_DisableApp();
            DOut5158p0001_State = DOut5158p0001_State & 0x7F;
        }
    }
    else
    {
        /* Another thread is already modifying this object so ignore this request */
    }
    Interrupt_EnableApp();

}
void DOut5158p0001_DiscreteOutput_Stop(void)
{

    /* IO Stop is called on shutdown. It should override the state being set by another thread.
       The expectation is that normal operation shall not resume without effectively restarting the code */
    DOut5158p0001_State = RES_OFF;

	MC33800_DiscreteOut_State_Set(&DOut5158p0001, RES_OFF);
}

INSTANTIATE_MC33800Output_DiscreteOut(MC33800_LSO9,
	MC33800_OUT5,
	OSS,
	RES_POL_ACTIVE_LOW,
	OUTPUT_IS_INVERTING,
	S_SHRC_4);
void MC33800_LSO9_DiscreteOutput_Create(void)
{
	S_MC33800Output_Create_DiscreteOut CreateObj;
	
	CreateObj.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	
	CreateObj.DiscreteOutCreateAttribs.eInitialState = RES_OFF;


	CreateObj.DiagnosticsCreateAttribs.uValidAttributesMask =
		  USE_DIAGNOSTICS_OPEN_LOAD_CURRENT
		| USE_DIAGNOSTICS_OVER_VOLATGE_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_TIMER
		| USE_DIAGNOSTICS_TEMPERATURE_PROTECTION;
	
	CreateObj.DiagnosticsCreateAttribs.OverVoltageAction = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.ShortFaultAction  = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.u32ShortFaultTimer_uSec = 120;
	CreateObj.DiagnosticsCreateAttribs.u32VoltageThreshold_mVolt = 2000;

	CreateObj.CircuitCreate.uValidAttributesMask = USE_MC33800OUTPUT_PARALLEL_INPUT | USE_MC33800OUTPUT_PARALLEL_OUTPUT;
	
	MC33800_DiscreteOut_Create(&MC33800_LSO9, &CreateObj);
}

INSTANTIATE_MC33800Output_DiscreteOut(DOut5385p0001,
	MC33800_PWM6,
	PWM,
	RES_POL_ACTIVE_LOW,
	OUTPUT_IS_INVERTING,
	S_SHRC_4);



#include <Pragma_Section_Start_SDA.h>
E_ResourceState DOut5385p0001_State;
#include <Pragma_Section_End_SDA.h>
void DOut5385p0001_DiscreteOutput_Create(void)
{
	S_MC33800Output_Create_DiscreteOut CreateObj;
	
	CreateObj.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	
	CreateObj.DiscreteOutCreateAttribs.eInitialState = RES_OFF;

    /* Cache state because UseUpdateOnlyOnChange was true */
    DOut5385p0001_State = CreateObj.DiscreteOutCreateAttribs.eInitialState;


	CreateObj.DiagnosticsCreateAttribs.uValidAttributesMask =
		  USE_DIAGNOSTICS_OPEN_LOAD_CURRENT
		| USE_DIAGNOSTICS_OVER_VOLATGE_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_TIMER
		| USE_DIAGNOSTICS_TEMPERATURE_PROTECTION;
	
	CreateObj.DiagnosticsCreateAttribs.OverVoltageAction = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.ShortFaultAction  = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.u32ShortFaultTimer_uSec = 120;
	CreateObj.DiagnosticsCreateAttribs.u32VoltageThreshold_mVolt = 2000;

	CreateObj.CircuitCreate.uValidAttributesMask = USE_MC33800OUTPUT_DEFAULTS;
	
	MC33800_DiscreteOut_Create(&DOut5385p0001, &CreateObj);
}
void DOut5385p0001_DiscreteOutput_Set(boolean_T value)
{
    E_ResourceState eState;

    eState = value ? RES_ON : RES_OFF;

    Interrupt_DisableApp();
    if ((DOut5385p0001_State & 0x80) == 0)
    {   /* Object is not currently undergoing modification */
        if (DOut5385p0001_State != eState)
        {
            DOut5385p0001_State = eState | 0x80;
            Interrupt_EnableApp();
            MC33800_DiscreteOut_State_Set(&DOut5385p0001, eState);
            Interrupt_DisableApp();
            DOut5385p0001_State = DOut5385p0001_State & 0x7F;
        }
    }
    else
    {
        /* Another thread is already modifying this object so ignore this request */
    }
    Interrupt_EnableApp();

}
void DOut5385p0001_DiscreteOutput_Stop(void)
{

    /* IO Stop is called on shutdown. It should override the state being set by another thread.
       The expectation is that normal operation shall not resume without effectively restarting the code */
    DOut5385p0001_State = RES_OFF;

	MC33800_DiscreteOut_State_Set(&DOut5385p0001, RES_OFF);
}

INSTANTIATE_MC33800Output_DiscreteOut(DOut5386p0001,
	MC33800_PWM5,
	PWM,
	RES_POL_ACTIVE_LOW,
	OUTPUT_IS_INVERTING,
	S_SHRC_3);



#include <Pragma_Section_Start_SDA.h>
E_ResourceState DOut5386p0001_State;
#include <Pragma_Section_End_SDA.h>
void DOut5386p0001_DiscreteOutput_Create(void)
{
	S_MC33800Output_Create_DiscreteOut CreateObj;
	
	CreateObj.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	
	CreateObj.DiscreteOutCreateAttribs.eInitialState = RES_OFF;

    /* Cache state because UseUpdateOnlyOnChange was true */
    DOut5386p0001_State = CreateObj.DiscreteOutCreateAttribs.eInitialState;


	CreateObj.DiagnosticsCreateAttribs.uValidAttributesMask =
		  USE_DIAGNOSTICS_OPEN_LOAD_CURRENT
		| USE_DIAGNOSTICS_OVER_VOLATGE_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_TIMER
		| USE_DIAGNOSTICS_TEMPERATURE_PROTECTION;
	
	CreateObj.DiagnosticsCreateAttribs.OverVoltageAction = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.ShortFaultAction  = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.u32ShortFaultTimer_uSec = 120;
	CreateObj.DiagnosticsCreateAttribs.u32VoltageThreshold_mVolt = 2000;

	CreateObj.CircuitCreate.uValidAttributesMask = USE_MC33800OUTPUT_DEFAULTS;
	
	MC33800_DiscreteOut_Create(&DOut5386p0001, &CreateObj);
}
void DOut5386p0001_DiscreteOutput_Set(boolean_T value)
{
    E_ResourceState eState;

    eState = value ? RES_ON : RES_OFF;

    Interrupt_DisableApp();
    if ((DOut5386p0001_State & 0x80) == 0)
    {   /* Object is not currently undergoing modification */
        if (DOut5386p0001_State != eState)
        {
            DOut5386p0001_State = eState | 0x80;
            Interrupt_EnableApp();
            MC33800_DiscreteOut_State_Set(&DOut5386p0001, eState);
            Interrupt_DisableApp();
            DOut5386p0001_State = DOut5386p0001_State & 0x7F;
        }
    }
    else
    {
        /* Another thread is already modifying this object so ignore this request */
    }
    Interrupt_EnableApp();

}
void DOut5386p0001_DiscreteOutput_Stop(void)
{

    /* IO Stop is called on shutdown. It should override the state being set by another thread.
       The expectation is that normal operation shall not resume without effectively restarting the code */
    DOut5386p0001_State = RES_OFF;

	MC33800_DiscreteOut_State_Set(&DOut5386p0001, RES_OFF);
}

INSTANTIATE_MC33800Output_DiscreteOut(MC33800_LSO10,
	MC33800_OUT7,
	OSS,
	RES_POL_ACTIVE_LOW,
	OUTPUT_IS_INVERTING,
	S_SHRC_4);
void MC33800_LSO10_DiscreteOutput_Create(void)
{
	S_MC33800Output_Create_DiscreteOut CreateObj;
	
	CreateObj.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	
	CreateObj.DiscreteOutCreateAttribs.eInitialState = RES_OFF;


	CreateObj.DiagnosticsCreateAttribs.uValidAttributesMask =
		  USE_DIAGNOSTICS_OPEN_LOAD_CURRENT
		| USE_DIAGNOSTICS_OVER_VOLATGE_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_TIMER
		| USE_DIAGNOSTICS_TEMPERATURE_PROTECTION;
	
	CreateObj.DiagnosticsCreateAttribs.OverVoltageAction = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.ShortFaultAction  = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.u32ShortFaultTimer_uSec = 120;
	CreateObj.DiagnosticsCreateAttribs.u32VoltageThreshold_mVolt = 2000;

	CreateObj.CircuitCreate.uValidAttributesMask = USE_MC33800OUTPUT_PARALLEL_INPUT | USE_MC33800OUTPUT_PARALLEL_OUTPUT;
	
	MC33800_DiscreteOut_Create(&MC33800_LSO10, &CreateObj);
}

INSTANTIATE_MC33800Output_DiscreteOut(MC33800_LSO8,
	MC33800_OUT3,
	OSS,
	RES_POL_ACTIVE_LOW,
	OUTPUT_IS_INVERTING,
	S_SHRC_4);
void MC33800_LSO8_DiscreteOutput_Create(void)
{
	S_MC33800Output_Create_DiscreteOut CreateObj;
	
	CreateObj.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	
	CreateObj.DiscreteOutCreateAttribs.eInitialState = RES_OFF;


	CreateObj.DiagnosticsCreateAttribs.uValidAttributesMask =
		  USE_DIAGNOSTICS_OPEN_LOAD_CURRENT
		| USE_DIAGNOSTICS_OVER_VOLATGE_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_TIMER
		| USE_DIAGNOSTICS_TEMPERATURE_PROTECTION;
	
	CreateObj.DiagnosticsCreateAttribs.OverVoltageAction = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.ShortFaultAction  = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.u32ShortFaultTimer_uSec = 120;
	CreateObj.DiagnosticsCreateAttribs.u32VoltageThreshold_mVolt = 2000;

	CreateObj.CircuitCreate.uValidAttributesMask = USE_MC33800OUTPUT_PARALLEL_INPUT | USE_MC33800OUTPUT_PARALLEL_OUTPUT;
	
	MC33800_DiscreteOut_Create(&MC33800_LSO8, &CreateObj);
}

INSTANTIATE_MC33800Output_DiscreteOut(DOut5389p0001,
	MC33800_PWM5,
	PWM,
	RES_POL_ACTIVE_LOW,
	OUTPUT_IS_INVERTING,
	S_SHRC_4);



#include <Pragma_Section_Start_SDA.h>
E_ResourceState DOut5389p0001_State;
#include <Pragma_Section_End_SDA.h>
void DOut5389p0001_DiscreteOutput_Create(void)
{
	S_MC33800Output_Create_DiscreteOut CreateObj;
	
	CreateObj.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	
	CreateObj.DiscreteOutCreateAttribs.eInitialState = RES_OFF;

    /* Cache state because UseUpdateOnlyOnChange was true */
    DOut5389p0001_State = CreateObj.DiscreteOutCreateAttribs.eInitialState;


	CreateObj.DiagnosticsCreateAttribs.uValidAttributesMask =
		  USE_DIAGNOSTICS_OPEN_LOAD_CURRENT
		| USE_DIAGNOSTICS_OVER_VOLATGE_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_TIMER
		| USE_DIAGNOSTICS_TEMPERATURE_PROTECTION;
	
	CreateObj.DiagnosticsCreateAttribs.OverVoltageAction = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.ShortFaultAction  = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.u32ShortFaultTimer_uSec = 120;
	CreateObj.DiagnosticsCreateAttribs.u32VoltageThreshold_mVolt = 2000;

	CreateObj.CircuitCreate.uValidAttributesMask = USE_MC33800OUTPUT_DEFAULTS;
	
	MC33800_DiscreteOut_Create(&DOut5389p0001, &CreateObj);
}
void DOut5389p0001_DiscreteOutput_Set(boolean_T value)
{
    E_ResourceState eState;

    eState = value ? RES_ON : RES_OFF;

    Interrupt_DisableApp();
    if ((DOut5389p0001_State & 0x80) == 0)
    {   /* Object is not currently undergoing modification */
        if (DOut5389p0001_State != eState)
        {
            DOut5389p0001_State = eState | 0x80;
            Interrupt_EnableApp();
            MC33800_DiscreteOut_State_Set(&DOut5389p0001, eState);
            Interrupt_DisableApp();
            DOut5389p0001_State = DOut5389p0001_State & 0x7F;
        }
    }
    else
    {
        /* Another thread is already modifying this object so ignore this request */
    }
    Interrupt_EnableApp();

}
void DOut5389p0001_DiscreteOutput_Stop(void)
{

    /* IO Stop is called on shutdown. It should override the state being set by another thread.
       The expectation is that normal operation shall not resume without effectively restarting the code */
    DOut5389p0001_State = RES_OFF;

	MC33800_DiscreteOut_State_Set(&DOut5389p0001, RES_OFF);
}

INSTANTIATE_MC33800Output_DiscreteOut(MC33800_MPRD,
	MC33800_OUT7,
	OSS,
	RES_POL_ACTIVE_LOW,
	OUTPUT_IS_INVERTING,
	S_SHRC_3);
void MC33800_MPRD_DiscreteOutput_Create(void)
{
	S_MC33800Output_Create_DiscreteOut CreateObj;
	
	CreateObj.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	
	CreateObj.DiscreteOutCreateAttribs.eInitialState = RES_OFF;


	CreateObj.DiagnosticsCreateAttribs.uValidAttributesMask =
		  USE_DIAGNOSTICS_OPEN_LOAD_CURRENT
		| USE_DIAGNOSTICS_OVER_VOLATGE_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_ACTION
		| USE_DIAGNOSTICS_SHORT_FAULT_TIMER
		| USE_DIAGNOSTICS_TEMPERATURE_PROTECTION;
	
	CreateObj.DiagnosticsCreateAttribs.OverVoltageAction = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.ShortFaultAction  = RES_RETRY;
	CreateObj.DiagnosticsCreateAttribs.u32ShortFaultTimer_uSec = 120;
	CreateObj.DiagnosticsCreateAttribs.u32VoltageThreshold_mVolt = 2000;

	CreateObj.CircuitCreate.uValidAttributesMask = USE_MC33800OUTPUT_PARALLEL_INPUT | USE_MC33800OUTPUT_PARALLEL_OUTPUT;
	
	MC33800_DiscreteOut_Create(&MC33800_MPRD, &CreateObj);
}

INSTANTIATE_SPI_MODULE_DEFN(
		SPI_B,
		DSPI_B,
        1);
void SPI_B_Create(void)
{
	INSTANTIATE_SPI_MODULE_ATTRIBUTES(SPI_B_,
		DSPI_B,
		1,
		0,
		USE_SPI_CS0);

	SPI_B.pMethods->pfnCreate(&SPI_B, &SPI_B_Attrib);
}

/* --- VISTA SPI configuration ----------------------------------------------------------------------------*/

#ifndef FREQ_1MHZ
    #define FREQ_1MHz 1000000UL
#endif

/* in_uInputPeriodMult_Tcsc setting definition and verification 
   PCS-to-SCK input period multiplier
   VISTA: 1 ns minimum
   TARGET: 2 ns */
#define VISTA_PCS_TO_SCK_DELAY_FREQ        (500 * FREQ_1MHz)
/* Conversion rounds up always to ensure that the minimum multipler is sufficiently large enough to ensure that the
   timing will always meet the minimum target*/
#define VISTA_INPUT_PCS_TO_SCK_PERIOD_MULT ((__SYSTEM_CLOCK_FREQ_IN_HZ / VISTA_PCS_TO_SCK_DELAY_FREQ) + 1)
#define VISTA_INPUT_PCS_TO_SCK_PERIOD_MULT_UNLOCKPLL VISTA_INPUT_PCS_TO_SCK_PERIOD_MULT

/* in_uInputPeriodMult_Tasc setting definition and verification 
   After SCK delay input period multiplier
   VISTA: 1 ns minimum
   TARGET: 2 ns */
#define VISTA_AFTER_SCK_DELAY_FREQ         (500 * FREQ_1MHz)

/* in_uInputPeriodMult_Tasc setting definition and verification 
   After SCK delay input period multiplier
   VISTA: 2555 ns minimum */
#define VISTA_AFTER_SCK_DELAY_FREQ_UNLOCKPLL (391000)

/* Conversion rounds up always to ensure that the minimum multipler is sufficiently large enough to ensure that the
   timing will always meet the minimum target*/
#define VISTA_INPUT_AFTER_SCK_PERIOD_MULT  ((__SYSTEM_CLOCK_FREQ_IN_HZ / VISTA_AFTER_SCK_DELAY_FREQ) + 1)
#define VISTA_INPUT_AFTER_SCK_PERIOD_MULT_UNLOCKPLL ((__SYSTEM_CLOCK_FREQ_IN_HZ / VISTA_AFTER_SCK_DELAY_FREQ_UNLOCKPLL) + 1)

/* in_uInputPeriodMult_Tdt setting definition and verification 
   After transfer delay input period multiplier
   VISTA: 2 ns minimum
   IMPLEMENTED: 2 ns */
#define VISTA_AFTER_XFER_DELAY_FREQ        (500 * FREQ_1MHz)
#define VISTA_INPUT_AFTER_XFER_PERIOD_MULT ((__SYSTEM_CLOCK_FREQ_IN_HZ / VISTA_AFTER_XFER_DELAY_FREQ) + 1)
#define VISTA_INPUT_AFTER_XFER_PERIOD_MULT_UNLOCKPLL  VISTA_INPUT_AFTER_XFER_PERIOD_MULT

INSTANTIATE_VISTA_HW_DEFN(VISTA_1,
                          SPI_B,
                          USE_SPI_CS0,
                          NULL,
                          0,
                          1,
                          1,
                          VISTA_INPUT_PCS_TO_SCK_PERIOD_MULT,
                          VISTA_INPUT_AFTER_SCK_PERIOD_MULT,
                          VISTA_INPUT_AFTER_XFER_PERIOD_MULT,
                          VISTA_INPUT_PCS_TO_SCK_PERIOD_MULT_UNLOCKPLL,
                          VISTA_INPUT_AFTER_SCK_PERIOD_MULT_UNLOCKPLL,
                          VISTA_INPUT_AFTER_XFER_PERIOD_MULT_UNLOCKPLL,
                          8000000,
                          1);
void VISTA_1_Create(void)
{
    INSTANTIATE_VISTA_HW_ATTRIBUTES(CreateObj,                             /* Name */ 
                                                                                
/* in_eOscFreqBiasCurrent */                     SU1_OSCFRQ_188uA,                      
/* in_KDIV    */                                 VISTA_KDIV_4MHZ_INPUT_SOURCE,
/* in_NMUL    */                                 VISTA_NMUL_4MHZ_INPUT_SOURCE,
/* in_PDIV    */                                 VISTA_PDIV_4MHZ_INPUT_SOURCE,
/* in_eVS_D1  VRS 1 is CNKDG and VRS 4 
     (the diff channel) is CAM */                SU2_VS_D_SINGLE_ENDED_MODE,
/* in_eVS_D2  VRS 2 is connected to SPD2 VR +/- 
    (HACK: Single-Ended due to VISTA bug) */     SU2_VS_D_SINGLE_ENDED_MODE,
/* in_eVS_D3  VRS 3 is connected to SPD1 DG */   SU2_VS_D_SINGLE_ENDED_MODE,
/* in_eV_H1   VRS 1 is connected to CNK DG */    SU2_V_H_HALL_SENSOR,
/* in_eV_H2   VRS 2 is connected to SPD2 DG */   SU2_V_H_HALL_SENSOR,
/* in_eV_H3   VRS 3 is connected to SPD1 DG */   SU2_V_H_HALL_SENSOR,
/* in_eV_H4   VRS 4 is connected to CAM DG */    SU2_V_H_HALL_SENSOR,
/* in_eV_H5   VRS 5 is connected to SPD3 */      SU2_V_H_HALL_SENSOR,
/* in_eV_H6   VRS 6 is unused */                 SU2_V_H_HALL_SENSOR,
/* in_eTPT1   Trip point settings on VRS 
    signals will eventually come from the */     SU2_TPT_SYMMETRICAL_THRESHOLDS,
/* in_eTPT2   mask of the respective block.  
     Just use defaults for now */                SU2_TPT_SYMMETRICAL_THRESHOLDS,
/* in_eTPT3   */                                 SU2_TPT_SYMMETRICAL_THRESHOLDS,
/* in_eTPT4   */                                 SU2_TPT_SYMMETRICAL_THRESHOLDS,
/* in_eTPT5   */                                 SU2_TPT_SYMMETRICAL_THRESHOLDS,        
/* in_eTPT6   */                                 SU2_TPT_SYMMETRICAL_THRESHOLDS,
/* in_eSCTL   SPI output drive strength/slew 
     rate.  Use defaults for now */              SU3_SCTL_STRONG_DRIVER_FAST_EDGE,      


/* in_eA_MAF  MAFI/AD17 and MAFMI/AD18 pins 
     not connected. Use defaults. */             VISTA_SELECT_ADC_RESOURCE,            
/* in_eA_KP2  Select knock sensor input */       VISTA_SELECT_ADC_ALTERNATE,
/* in_eA_H3   Select HEGO3 */                    VISTA_SELECT_ADC_ALTERNATE,
/* in_eA_H4   Select HEGO4 */                    VISTA_SELECT_ADC_ALTERNATE,
/* in_eA_H5   Select HEGO5 */                    VISTA_SELECT_ADC_ALTERNATE,
/* in_eA_H6   Select HEGO6 */                    VISTA_SELECT_ADC_ALTERNATE,
/* in_eA_V4   Select VRS4 */                     VISTA_SELECT_ADC_ALTERNATE,
/* in_eA_V5   Select VRS5 */                     VISTA_SELECT_ADC_ALTERNATE,            
/* in_eA_V6   Select VRS6 */                     VISTA_SELECT_ADC_ALTERNATE,
/* in_eKSD    Select differential mode */        SU3_KSD_DIFFERENTIAL_MODE,
/* in_ePADPDM SPI output drive strength/slew 
    rate.  Use defaults for now */               SU3_SCTL_STRONG_DRIVER_FAST_EDGE,
                                    
/* in_eMAFD   */                                 SU4_MAFD_USE_DEFAULT_COEF_VALUES,
/* in_eKNKD   Assigns the coeffs for use by 
    knock subsystem (note this prevents use by 
	HEGO)*/                                      SU4_KNKD_USE_COEF_REG,                 
/* in_eHEG1D  */                                 SU4_HEGD_3_6_USE_DEFAULT_COEF_VALUES,
/* in_eHEG2D  */                                 SU4_HEGD_3_6_USE_DEFAULT_COEF_VALUES,
/* in_eHEG3D  */                                 SU4_HEGD_3_6_USE_DEFAULT_COEF_VALUES,
/* in_eHEG4D  */                                 SU4_HEGD_3_6_USE_DEFAULT_COEF_VALUES,
/* in_eHEG5D  */                                 SU4_HEGD_3_6_USE_DEFAULT_COEF_VALUES,
/* in_eHEG6D  */                                 SU4_HEGD_3_6_USE_DEFAULT_COEF_VALUES,
/* in_eHEG1V  */                                 SU4_HEGV_160HZ_SP_LOWPASS,
/* in_eHEG2V  */                                 SU4_HEGV_160HZ_SP_LOWPASS);            
                                    

    VISTA_HW_Create(&VISTA_1, &CreateObj);

}           



/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: VISTA_1_Register_Write
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
NativeError_S VISTA_1_Register_Write(NativeVar_U eReg, void const* pData, NativeVar_U uNumRegs)
{
    return(VISTA_Register_WriteBlock(&VISTA_1, (E_VISTA_Registers)eReg, pData, uNumRegs)); 
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: VISTA_1_Register_Read
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
NativeError_S VISTA_1_Register_Read(NativeVar_U eReg, void* out_pBuffer, NativeVar_U uNumRegs)
{
    return(VISTA_Register_ReadBlock(&VISTA_1, (E_VISTA_Registers)eReg, out_pBuffer, uNumRegs)); 
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: VISTA_1_Knock_IIR_Coefficient_Convert_FixedPtToReal
::
:: Converts the fixed point representation of a knock coefficient into a real
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
real32_T VISTA_1_Knock_IIR_Coefficient_Convert_FixedPtToReal(uint16_T u16Coeff)
{
    uint16_T u16Positive;
    real32_T r32Coeff;

    /* Drop the MSBit, which is the sign */
    u16Positive = u16Coeff & 0x7FFF;

    r32Coeff = (real32_T)u16Positive / 8192.0;
    if (u16Positive == u16Coeff)
    {
        /* Positive is the same as the passed in value so the passed in value is positive */
    }
    else
    {   /* Positive is different to the passed in value. Passed in is -ve */
        r32Coeff = r32Coeff * -1.0;
    }
    return(r32Coeff);
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: VISTA_1_Knock_IIR_Coefficient_Convert_RealToFixedPt
::
:: Converts the real number representation of a knock coefficient into a Fixed point value
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
uint16_T VISTA_1_Knock_IIR_Coefficient_Convert_RealToFixedPt(real32_T r32Coeff)
{
    uint16_T u16Output;
    uint32_T uFixedPtValue;

    if (r32Coeff < 0)
    {   /* Is -ve so capture the sign and make the real positive */
        r32Coeff = -1*r32Coeff;
        u16Output = 0x8000;
    }
    else
    {
        u16Output = 0;
    }

    r32Coeff = r32Coeff * 8192.0;
    uFixedPtValue = (uint32_T)r32Coeff;
    if (uFixedPtValue > 0x7FFF)
    {   /* Clip the value to the maximum */
        uFixedPtValue = 0x7FFF;
    }
    u16Output = (u16Output) | (uFixedPtValue);
    return(u16Output);
}

INSTANTIATE_VISTA_ADC(AnalogInput_VISTA_1_AD0, ADC_VISTA_AD0I_GPI0);


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: DRVP_Create
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void DRVP_Create(void)
{
    S_VISTA_ADC_CreateAttrib CreateObj;
    CreateObj.uFlags = VISTA_ADC_USE_ROUND_ROBIN;
    VISTA_ADC_Create(&VISTA_1, &AnalogInput_VISTA_1_AD0, &CreateObj);
}



/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: DRVP_AnalogInput_Get
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
uint16_T  DRVP_AnalogInput_Get(void)
{
    S_VISTA_ADC_ConversionAttrib DynamicObj;
    uint16_T Result;
    int16_T  Reading;
    
    DynamicObj.uFlags = VISTA_ADC_USE_ROUND_ROBIN;
    VISTA_ADC_GetConversion(&VISTA_1, &AnalogInput_VISTA_1_AD0, &DynamicObj);
    Reading = DynamicObj.s16ADCValue;


    if (Reading > 0)
    {
        /* Effectively an 11-bit native resolution */
        Result = (uint16_T)(Reading & 0x07FF) >> 1;
        return (uint16_T)Result;
    }
    else
    {
        return (uint16_T)0;
    }
    
}

static void eQADC_A_B_eQADCModule_Create(void)
{
    S_eQADCCreate ADCCreateObj;
    NativeError_S CreateResult;

    
    ADCCreateObj.uValidAttributesMask = USE_ANALOG_DEFAULTS | USE_ANALOG_TIME_STAMP;
        
    ADCCreateObj.eConversionTimePreScalar = ADC_CR_CLK_PS_12;
    ADCCreateObj.TimeStampPreScalar = ADC_TB_CLK_PS_1;
    ADCCreateObj.eBuffer = eQADC_BN_ADC1;
    CreateResult = eQADC_Create(&ADCCreateObj);
    
    if (SUCCESS(CreateResult))
    {
        
        ADCCreateObj.uValidAttributesMask = USE_ANALOG_DEFAULTS | USE_ANALOG_TIME_STAMP;
            
        ADCCreateObj.eBuffer = eQADC_BN_ADC0;
        eQADC_Create(&ADCCreateObj);
    }
}

uint32_T const g_eQADCCommandQueueBuffer5[] =
{ADD_ANALOG_RESOURCE_TO_QUEUE(ADC_AN39_B4, RFIFO_5, eQADC_CAL_CALIBRATE_RESULT, eQADC_LST_SAMPLING_CYCLE_2, eQADC_BN_ADC1), /* QADC_AN14 */
ADD_ANALOG_RESOURCE_TO_QUEUE(ADC_AN36_B3, RFIFO_5, eQADC_CAL_CALIBRATE_RESULT, eQADC_LST_SAMPLING_CYCLE_2, eQADC_BN_ADC1), /* QADC_AN2 */
ADD_ANALOG_RESOURCE_TO_QUEUE(ADC_AN11_A4, RFIFO_5, eQADC_CAL_CALIBRATE_RESULT, eQADC_LST_SAMPLING_CYCLE_2, eQADC_BN_ADC1), /* QADC_AN3 */
ADD_ANALOG_RESOURCE_TO_QUEUE(ADC_AN9_D6, RFIFO_5, eQADC_CAL_CALIBRATE_RESULT, eQADC_LST_SAMPLING_CYCLE_2, eQADC_BN_ADC1), /* QADC_AN22 */
ADD_ANALOG_RESOURCE_TO_QUEUE(ADC_AN21_C7, RFIFO_5, eQADC_CAL_CALIBRATE_RESULT, eQADC_LST_SAMPLING_CYCLE_2, eQADC_BN_ADC1), /* QADC_AN23 */
ADD_ANALOG_RESOURCE_TO_QUEUE(ADC_AN16_A6, RFIFO_5, eQADC_CAL_CALIBRATE_RESULT, eQADC_LST_SAMPLING_CYCLE_2, eQADC_BN_ADC1), /* QADC_AN15 */
ADD_ANALOG_RESOURCE_TO_END_OF_QUEUE(ADC_AN5_A8, RFIFO_5, eQADC_CAL_CALIBRATE_RESULT, eQADC_LST_SAMPLING_CYCLE_2, eQADC_BN_ADC1), /* QADC_ECUP */

};



uint16_T g_eQADCResultQueueBuffer5[7];


INSTANTIATEMETHOD_QADC_QUEUE(ContinuousScan_eQADCQueue_QueueMethod,
        /*        CPUType */ CPU,
        /*     Queue Type */ SW_TRIG_CONT_SCAN,
        /*   Result Style */ STANDARD_RESULT);

INSTANTIATE_QADC_QUEUE(ContinuousScan_eQADCQueue,
  /*    Processor Name */ CPUCore_0,
  /*    Main Processor */ CPU,
  /* Queue Method Name */ ContinuousScan_eQADCQueue_QueueMethod,
  /*        Queue Type */ SW_TRIG_CONT_SCAN,
  /*       Queue Index */ eQADC_QUEUE_5,
  /*  Ptr to Command Q */ g_eQADCCommandQueueBuffer5,
  /*   Ptr to Result Q */ g_eQADCResultQueueBuffer5,
  /*   Command Q Depth */ 7,
  /*    Result Q Depth */ 7,
  /*      ISR Priority */ INTCPRIORITY_NONE,
  /*  Snooper Func Ptr */ NULL,
  /*       This Device */ ContinuousScan_eQADCQueue,
  /* Depth of the Trigger Request Queue */
0,
 /* Desired Queue Conversion Resolution */
12 

);
void ContinuousScan_eQADCQueue_Create(void)
{
    S_AnalogQueueAttributes Attributes;

    /*============================================================================*/
    /* The buffer should have been created by an earlier dependancy               */
    /*============================================================================*/

    /*========================================================================*/
    /* Now we can create the Queue.                                           */
    /*========================================================================*/
    /* eQADCQueue ContinuousScan_eQADCQueue */
    
    Attributes.uValidAttributesMask = USE_ANALOG_DEFAULTS;
    
    {

        ContinuousScan_eQADCQueue.pMethods->pfnCreate(&ContinuousScan_eQADCQueue, &Attributes);
    }
}
uint16_T  Heater_Core_Blend_Position_AnalogInput_Get(void)
{
	NativeADC_U uResult;
	S_AnalogSingleResultGet GetAttrib;

	GetAttrib.uValidAttributesMask = ANALOG_SINGLE_GET_USE_BIT_TREATMENT;
	GetAttrib.uBitTreatment = 8; /* Result representation in number of bits */

	ContinuousScan_eQADCQueue.pMethods->pfnGetScaledResult(&ContinuousScan_eQADCQueue, /* Queue Oject */
	0,    /* Channel Index into the Queue */
    &GetAttrib,							                   /* Get attributes */
	&uResult);                                             /* Pointer to the result */
	
	return (uint16_T)uResult; /* new cast */
}
uint16_T  Radiator_Blend_Position_AnalogInput_Get(void)
{
	NativeADC_U uResult;
	S_AnalogSingleResultGet GetAttrib;

	GetAttrib.uValidAttributesMask = ANALOG_SINGLE_GET_USE_BIT_TREATMENT;
	GetAttrib.uBitTreatment = 8; /* Result representation in number of bits */

	ContinuousScan_eQADCQueue.pMethods->pfnGetScaledResult(&ContinuousScan_eQADCQueue, /* Queue Oject */
	1,    /* Channel Index into the Queue */
    &GetAttrib,							                   /* Get attributes */
	&uResult);                                             /* Pointer to the result */
	
	return (uint16_T)uResult; /* new cast */
}
uint16_T  Heater_Temp_AnalogInput_Get(void)
{
	NativeADC_U uResult;
	S_AnalogSingleResultGet GetAttrib;

	GetAttrib.uValidAttributesMask = ANALOG_SINGLE_GET_USE_BIT_TREATMENT;
	GetAttrib.uBitTreatment = 8; /* Result representation in number of bits */

	ContinuousScan_eQADCQueue.pMethods->pfnGetScaledResult(&ContinuousScan_eQADCQueue, /* Queue Oject */
	2,    /* Channel Index into the Queue */
    &GetAttrib,							                   /* Get attributes */
	&uResult);                                             /* Pointer to the result */
	
	return (uint16_T)uResult; /* new cast */
}
uint16_T  DCDC_Conveter_AnalogInput_Get(void)
{
	NativeADC_U uResult;
	S_AnalogSingleResultGet GetAttrib;

	GetAttrib.uValidAttributesMask = ANALOG_SINGLE_GET_USE_BIT_TREATMENT;
	GetAttrib.uBitTreatment = 8; /* Result representation in number of bits */

	ContinuousScan_eQADCQueue.pMethods->pfnGetScaledResult(&ContinuousScan_eQADCQueue, /* Queue Oject */
	3,    /* Channel Index into the Queue */
    &GetAttrib,							                   /* Get attributes */
	&uResult);                                             /* Pointer to the result */
	
	return (uint16_T)uResult; /* new cast */
}
uint16_T  Cruise_Control_AnalogInput_Get(void)
{
	NativeADC_U uResult;
	S_AnalogSingleResultGet GetAttrib;

	GetAttrib.uValidAttributesMask = ANALOG_SINGLE_GET_USE_BIT_TREATMENT;
	GetAttrib.uBitTreatment = 12; /* Result representation in number of bits */

	ContinuousScan_eQADCQueue.pMethods->pfnGetScaledResult(&ContinuousScan_eQADCQueue, /* Queue Oject */
	4,    /* Channel Index into the Queue */
    &GetAttrib,							                   /* Get attributes */
	&uResult);                                             /* Pointer to the result */
	
	return (uint16_T)uResult; /* new cast */
}
uint16_T  Throttle_Position_AnalogInput_Get(void)
{
	NativeADC_U uResult;
	S_AnalogSingleResultGet GetAttrib;

	GetAttrib.uValidAttributesMask = ANALOG_SINGLE_GET_USE_BIT_TREATMENT;
	GetAttrib.uBitTreatment = 8; /* Result representation in number of bits */

	ContinuousScan_eQADCQueue.pMethods->pfnGetScaledResult(&ContinuousScan_eQADCQueue, /* Queue Oject */
	5,    /* Channel Index into the Queue */
    &GetAttrib,							                   /* Get attributes */
	&uResult);                                             /* Pointer to the result */
	
	return (uint16_T)uResult; /* new cast */
}
uint16_T  ECUP_AnalogInput_Get(void)
{
	NativeADC_U uResult;
	S_AnalogSingleResultGet GetAttrib;

	GetAttrib.uValidAttributesMask = ANALOG_SINGLE_GET_USE_BIT_TREATMENT;
	GetAttrib.uBitTreatment = 10; /* Result representation in number of bits */

	ContinuousScan_eQADCQueue.pMethods->pfnGetScaledResult(&ContinuousScan_eQADCQueue, /* Queue Oject */
	6,    /* Channel Index into the Queue */
    &GetAttrib,							                   /* Get attributes */
	&uResult);                                             /* Pointer to the result */
	
	return (uint16_T)uResult; /* new cast */
}

INSTANTIATEMETHOD_CPU_PWM_ETPU(H1m_Methods);
	
	
    INSTANTIATE_CPU_PWM_ETPU(H1m,
        /* Method */ H1m_Methods,
      /* ProcName */ CPUCore_0,
     /* CPUOutPin */ ETPU_B10_K23,
  /* MyDeviceName */ H1m);
void H1m_PWMOutput_Create(void)
{
    S_PWMCreateAttribs CreateObj;



    CreateObj.uValidAttributesMask = USE_PWM_DEFAULTS;
    CreateObj.eJustification = PWM_LEFT_JUSTIFIED;

    CreateObj.uValidAttributesMask |= USE_PWM_MIN_EXPECTED_FREQ;
    CreateObj.uMinExpectedFrequency = GET_FIXEDPT_PWM_FREQUENCY(2.00);    

    PWM_GenAPI_Create(&H1m, &CreateObj);
}


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: H1m_PWMOutput_Set
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
boolean_T H1m_PWMOutput_Set(uint32_T frequency, int16_T dutyCycle, boolean_T brake, boolean_T enable)
{
    if (enable)
	{
	    return(SUCCESS(PWM_GenAPI_FrequencyDutyCycle_Set(&H1m, frequency, dutyCycle)));
    }
	else
	{
	    return(SUCCESS(PWM_GenAPI_FrequencyDutyCycle_Set(&H1m, 0, 0)));
    }
}
void H1m_PWMOutput_Stop(void)
{
	PWM_GenAPI_FrequencyDutyCycle_Set(&H1m, 0, 0);
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
            :: H1m_PWMOutput_PWMOutput_Set
            :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
boolean_T H1m_PWMOutput_PWMOutput_Set(uint32_T frequency, int16_T dutyCycle, boolean_T brake, boolean_T enable)
{

                if (enable)
                {
                    H1_InhibitB_DiscreteOutput_Set(enable);
                    return(SUCCESS(H1m_PWMOutput_Set(frequency, dutyCycle, brake, enable)));
                }
                else
                {
                    H1m_PWMOutput_PWMOutput_Stop();
                }
            }
void H1m_PWMOutput_PWMOutput_Stop(void)
{
            H1_InhibitB_DiscreteOutput_Set(0);
            H1m_PWMOutput_Set(0, 0, 0, 0);
        }

INSTANTIATE_SPI_MODULE_DEFN(
		SPI_D,
		DSPI_D,
        1);
void SPI_D_Create(void)
{
	INSTANTIATE_SPI_MODULE_ATTRIBUTES(SPI_D_,
		DSPI_D,
		1,
		0,
		USE_SPI_CS0 | USE_SPI_CS2);

	SPI_D.pMethods->pfnCreate(&SPI_D, &SPI_D_Attrib);
}

INSTANTIATE_SerialEE(EEPROM_1,
                     M95256,
                     0xFF000000,
                     SPI_D,
                     USE_SPI_CS0,
                     NULL,
                     0,
                     2000000,
                     SERIAL_EE_INTERFACE_SYNCHONLY,
                     1,
                     0);
void EEPROM_1_Create(void)
{
	SerialEE_Create(&EEPROM_1);
}

void MotoCoder_DiscreteOutput_UpdateOnChange_Create(S_BasicOut_Defn_DiscreteOut const* const in_pDefn, E_ResourceState* const in_peState, E_ResourceState in_eInitialState)
{
	S_BasicOut_Create_DiscreteOut CreateObj;
	
	CreateObj.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	CreateObj.Create.uValidAttributesMask = BASICOUT_USE_DEFAULTS;
	CreateObj.DiscreteOutCreateAttribs.eInitialState = in_eInitialState;

    /* Cache state because UseUpdateOnlyOnChange was true */
    *in_peState = CreateObj.DiscreteOutCreateAttribs.eInitialState;
	BasicOut_DiscreteOut_Create(in_pDefn, &CreateObj);
}
void MotoCoder_DiscreteOutput_UpdateOnChange_Set(S_BasicOut_Defn_DiscreteOut const* const in_pDefn, 
                                                         E_ResourceState* const in_peState,
                                                         boolean_T value)
{
    E_ResourceState eState;

	eState = value ? RES_ON : RES_OFF;
    Interrupt_DisableApp();
    if ((*in_peState & 0x80) == 0)
    {   /* Object is not currently undergoing modification */
        if (*in_peState != eState)
        {
            *in_peState = eState | 0x80;
            Interrupt_EnableApp();
            BasicOut_DiscreteOut_State_Set(in_pDefn, eState);
            Interrupt_DisableApp();
            *in_peState = *in_peState & 0x7F;
        }
    }
    else
    {
        /* Another thread is already modifying this object so ignore this request */
    }
    Interrupt_EnableApp();
}
void MotoCoder_DiscreteOutput_UpdateOnChange_Stop(S_BasicOut_Defn_DiscreteOut const* const in_pDefn, E_ResourceState* const in_peState)
{
    /* IO Stop is called on shutdown. It should override the state being set by another thread.
       The expectation is that normal operation shall not resume without effectively restarting the code */
    *in_peState = RES_OFF;
	BasicOut_DiscreteOut_State_Set(in_pDefn, RES_OFF);
}

    
    

#include <Pragma_Section_Start_SDA.h>
E_ResourceState DOut5148p0001_State;
#include <Pragma_Section_End_SDA.h>
NativeError_S DOut5148p0001_DiscreteOutput_Get(boolean_T* const out_pValue)
{
    if (FALSE == RES_OFF)
    {   /* Optimized return function can be used because enum states match with boolean*/
        *out_pValue = (boolean_T)DOut5148p0001_State;
    }
    else if (DOut5148p0001_State == RES_OFF)
    {
        *out_pValue = FALSE;
    }
    else /* if (DOut5148p0001_State == RES_ON) */
    {
        *out_pValue = TRUE;
    }
    return(SUCCESS_OK);
}


INSTANTIATE_BasicOut_DiscreteOut(DOut5148p0001,
                                 CPUCore_0, 
                                 CPU, 
                                 GPIO_137_G1, 
                                 GPIO,
                                 RES_POL_ACTIVE_HIGH,
                                 OUTPUT_IS_NON_INVERTING);
void DOut5148p0001_DiscreteOutput_Create(void)
{
	MotoCoder_DiscreteOutput_UpdateOnChange_Create(&DOut5148p0001, &DOut5148p0001_State, RES_OFF);
}
void DOut5148p0001_DiscreteOutput_Set(boolean_T value)
{
    MotoCoder_DiscreteOutput_UpdateOnChange_Set(&DOut5148p0001,
                                                &DOut5148p0001_State,
                                                value);
}
void DOut5148p0001_DiscreteOutput_Stop(void)
{
    MotoCoder_DiscreteOutput_UpdateOnChange_Stop(&DOut5148p0001, &DOut5148p0001_State);
}
    
    

#include <Pragma_Section_Start_SDA.h>
E_ResourceState DOut5149p0001_State;
#include <Pragma_Section_End_SDA.h>
NativeError_S DOut5149p0001_DiscreteOutput_Get(boolean_T* const out_pValue)
{
    if (FALSE == RES_OFF)
    {   /* Optimized return function can be used because enum states match with boolean*/
        *out_pValue = (boolean_T)DOut5149p0001_State;
    }
    else if (DOut5149p0001_State == RES_OFF)
    {
        *out_pValue = FALSE;
    }
    else /* if (DOut5149p0001_State == RES_ON) */
    {
        *out_pValue = TRUE;
    }
    return(SUCCESS_OK);
}


INSTANTIATE_BasicOut_DiscreteOut(DOut5149p0001,
                                 CPUCore_0, 
                                 CPU, 
                                 GPIO_135_G4, 
                                 GPIO,
                                 RES_POL_ACTIVE_HIGH,
                                 OUTPUT_IS_NON_INVERTING);
void DOut5149p0001_DiscreteOutput_Create(void)
{
	MotoCoder_DiscreteOutput_UpdateOnChange_Create(&DOut5149p0001, &DOut5149p0001_State, RES_OFF);
}
void DOut5149p0001_DiscreteOutput_Set(boolean_T value)
{
    MotoCoder_DiscreteOutput_UpdateOnChange_Set(&DOut5149p0001,
                                                &DOut5149p0001_State,
                                                value);
}
void DOut5149p0001_DiscreteOutput_Stop(void)
{
    MotoCoder_DiscreteOutput_UpdateOnChange_Stop(&DOut5149p0001, &DOut5149p0001_State);
}
    
    

#include <Pragma_Section_Start_SDA.h>
E_ResourceState DOut5150p0001_State;
#include <Pragma_Section_End_SDA.h>
NativeError_S DOut5150p0001_DiscreteOutput_Get(boolean_T* const out_pValue)
{
    if (FALSE == RES_OFF)
    {   /* Optimized return function can be used because enum states match with boolean*/
        *out_pValue = (boolean_T)DOut5150p0001_State;
    }
    else if (DOut5150p0001_State == RES_OFF)
    {
        *out_pValue = FALSE;
    }
    else /* if (DOut5150p0001_State == RES_ON) */
    {
        *out_pValue = TRUE;
    }
    return(SUCCESS_OK);
}


INSTANTIATE_BasicOut_DiscreteOut(DOut5150p0001,
                                 CPUCore_0, 
                                 CPU, 
                                 GPIO_136_G2, 
                                 GPIO,
                                 RES_POL_ACTIVE_HIGH,
                                 OUTPUT_IS_NON_INVERTING);
void DOut5150p0001_DiscreteOutput_Create(void)
{
	MotoCoder_DiscreteOutput_UpdateOnChange_Create(&DOut5150p0001, &DOut5150p0001_State, RES_OFF);
}
void DOut5150p0001_DiscreteOutput_Set(boolean_T value)
{
    MotoCoder_DiscreteOutput_UpdateOnChange_Set(&DOut5150p0001,
                                                &DOut5150p0001_State,
                                                value);
}
void DOut5150p0001_DiscreteOutput_Stop(void)
{
    MotoCoder_DiscreteOutput_UpdateOnChange_Stop(&DOut5150p0001, &DOut5150p0001_State);
}
    
    

#include <Pragma_Section_Start_SDA.h>
E_ResourceState DOut5151p0001_State;
#include <Pragma_Section_End_SDA.h>
NativeError_S DOut5151p0001_DiscreteOutput_Get(boolean_T* const out_pValue)
{
    if (FALSE == RES_OFF)
    {   /* Optimized return function can be used because enum states match with boolean*/
        *out_pValue = (boolean_T)DOut5151p0001_State;
    }
    else if (DOut5151p0001_State == RES_OFF)
    {
        *out_pValue = FALSE;
    }
    else /* if (DOut5151p0001_State == RES_ON) */
    {
        *out_pValue = TRUE;
    }
    return(SUCCESS_OK);
}


INSTANTIATE_BasicOut_DiscreteOut(DOut5151p0001,
                                 CPUCore_0, 
                                 CPU, 
                                 GPIO_134_H1, 
                                 GPIO,
                                 RES_POL_ACTIVE_HIGH,
                                 OUTPUT_IS_NON_INVERTING);
void DOut5151p0001_DiscreteOutput_Create(void)
{
	MotoCoder_DiscreteOutput_UpdateOnChange_Create(&DOut5151p0001, &DOut5151p0001_State, RES_OFF);
}
void DOut5151p0001_DiscreteOutput_Set(boolean_T value)
{
    MotoCoder_DiscreteOutput_UpdateOnChange_Set(&DOut5151p0001,
                                                &DOut5151p0001_State,
                                                value);
}
void DOut5151p0001_DiscreteOutput_Stop(void)
{
    MotoCoder_DiscreteOutput_UpdateOnChange_Stop(&DOut5151p0001, &DOut5151p0001_State);
}
    
    

#include <Pragma_Section_Start_SDA.h>
E_ResourceState DOut5152p0001_State;
#include <Pragma_Section_End_SDA.h>
NativeError_S DOut5152p0001_DiscreteOutput_Get(boolean_T* const out_pValue)
{
    if (FALSE == RES_OFF)
    {   /* Optimized return function can be used because enum states match with boolean*/
        *out_pValue = (boolean_T)DOut5152p0001_State;
    }
    else if (DOut5152p0001_State == RES_OFF)
    {
        *out_pValue = FALSE;
    }
    else /* if (DOut5152p0001_State == RES_ON) */
    {
        *out_pValue = TRUE;
    }
    return(SUCCESS_OK);
}


INSTANTIATE_BasicOut_DiscreteOut(DOut5152p0001,
                                 CPUCore_0, 
                                 CPU, 
                                 GPIO_138_F1, 
                                 GPIO,
                                 RES_POL_ACTIVE_HIGH,
                                 OUTPUT_IS_NON_INVERTING);
void DOut5152p0001_DiscreteOutput_Create(void)
{
	MotoCoder_DiscreteOutput_UpdateOnChange_Create(&DOut5152p0001, &DOut5152p0001_State, RES_OFF);
}
void DOut5152p0001_DiscreteOutput_Set(boolean_T value)
{
    MotoCoder_DiscreteOutput_UpdateOnChange_Set(&DOut5152p0001,
                                                &DOut5152p0001_State,
                                                value);
}
void DOut5152p0001_DiscreteOutput_Stop(void)
{
    MotoCoder_DiscreteOutput_UpdateOnChange_Stop(&DOut5152p0001, &DOut5152p0001_State);
}
    
    

#include <Pragma_Section_Start_SDA.h>
E_ResourceState DOut5153p0001_State;
#include <Pragma_Section_End_SDA.h>
NativeError_S DOut5153p0001_DiscreteOutput_Get(boolean_T* const out_pValue)
{
    if (FALSE == RES_OFF)
    {   /* Optimized return function can be used because enum states match with boolean*/
        *out_pValue = (boolean_T)DOut5153p0001_State;
    }
    else if (DOut5153p0001_State == RES_OFF)
    {
        *out_pValue = FALSE;
    }
    else /* if (DOut5153p0001_State == RES_ON) */
    {
        *out_pValue = TRUE;
    }
    return(SUCCESS_OK);
}


INSTANTIATE_BasicOut_DiscreteOut(DOut5153p0001,
                                 CPUCore_0, 
                                 CPU, 
                                 GPIO_133_H2, 
                                 GPIO,
                                 RES_POL_ACTIVE_HIGH,
                                 OUTPUT_IS_NON_INVERTING);
void DOut5153p0001_DiscreteOutput_Create(void)
{
	MotoCoder_DiscreteOutput_UpdateOnChange_Create(&DOut5153p0001, &DOut5153p0001_State, RES_OFF);
}
void DOut5153p0001_DiscreteOutput_Set(boolean_T value)
{
    MotoCoder_DiscreteOutput_UpdateOnChange_Set(&DOut5153p0001,
                                                &DOut5153p0001_State,
                                                value);
}
void DOut5153p0001_DiscreteOutput_Stop(void)
{
    MotoCoder_DiscreteOutput_UpdateOnChange_Stop(&DOut5153p0001, &DOut5153p0001_State);
}
    
    

#include <Pragma_Section_Start_SDA.h>
E_ResourceState DOut5154p0001_State;
#include <Pragma_Section_End_SDA.h>
NativeError_S DOut5154p0001_DiscreteOutput_Get(boolean_T* const out_pValue)
{
    if (FALSE == RES_OFF)
    {   /* Optimized return function can be used because enum states match with boolean*/
        *out_pValue = (boolean_T)DOut5154p0001_State;
    }
    else if (DOut5154p0001_State == RES_OFF)
    {
        *out_pValue = FALSE;
    }
    else /* if (DOut5154p0001_State == RES_ON) */
    {
        *out_pValue = TRUE;
    }
    return(SUCCESS_OK);
}


INSTANTIATE_BasicOut_DiscreteOut(DOut5154p0001,
                                 CPUCore_0, 
                                 CPU, 
                                 GPIO_132_H3, 
                                 GPIO,
                                 RES_POL_ACTIVE_HIGH,
                                 OUTPUT_IS_NON_INVERTING);
void DOut5154p0001_DiscreteOutput_Create(void)
{
	MotoCoder_DiscreteOutput_UpdateOnChange_Create(&DOut5154p0001, &DOut5154p0001_State, RES_OFF);
}
void DOut5154p0001_DiscreteOutput_Set(boolean_T value)
{
    MotoCoder_DiscreteOutput_UpdateOnChange_Set(&DOut5154p0001,
                                                &DOut5154p0001_State,
                                                value);
}
void DOut5154p0001_DiscreteOutput_Stop(void)
{
    MotoCoder_DiscreteOutput_UpdateOnChange_Stop(&DOut5154p0001, &DOut5154p0001_State);
}
    
    

#include <Pragma_Section_Start_SDA.h>
E_ResourceState DOut5155p0001_State;
#include <Pragma_Section_End_SDA.h>
NativeError_S DOut5155p0001_DiscreteOutput_Get(boolean_T* const out_pValue)
{
    if (FALSE == RES_OFF)
    {   /* Optimized return function can be used because enum states match with boolean*/
        *out_pValue = (boolean_T)DOut5155p0001_State;
    }
    else if (DOut5155p0001_State == RES_OFF)
    {
        *out_pValue = FALSE;
    }
    else /* if (DOut5155p0001_State == RES_ON) */
    {
        *out_pValue = TRUE;
    }
    return(SUCCESS_OK);
}


INSTANTIATE_BasicOut_DiscreteOut(DOut5155p0001,
                                 CPUCore_0, 
                                 CPU, 
                                 GPIO_131_H4, 
                                 GPIO,
                                 RES_POL_ACTIVE_HIGH,
                                 OUTPUT_IS_NON_INVERTING);
void DOut5155p0001_DiscreteOutput_Create(void)
{
	MotoCoder_DiscreteOutput_UpdateOnChange_Create(&DOut5155p0001, &DOut5155p0001_State, RES_OFF);
}
void DOut5155p0001_DiscreteOutput_Set(boolean_T value)
{
    MotoCoder_DiscreteOutput_UpdateOnChange_Set(&DOut5155p0001,
                                                &DOut5155p0001_State,
                                                value);
}
void DOut5155p0001_DiscreteOutput_Stop(void)
{
    MotoCoder_DiscreteOutput_UpdateOnChange_Stop(&DOut5155p0001, &DOut5155p0001_State);
}
    
    

#include <Pragma_Section_Start_SDA.h>
E_ResourceState DOut5384p0001_State;
#include <Pragma_Section_End_SDA.h>
NativeError_S DOut5384p0001_DiscreteOutput_Get(boolean_T* const out_pValue)
{
    if (FALSE == RES_OFF)
    {   /* Optimized return function can be used because enum states match with boolean*/
        *out_pValue = (boolean_T)DOut5384p0001_State;
    }
    else if (DOut5384p0001_State == RES_OFF)
    {
        *out_pValue = FALSE;
    }
    else /* if (DOut5384p0001_State == RES_ON) */
    {
        *out_pValue = TRUE;
    }
    return(SUCCESS_OK);
}


INSTANTIATE_BasicOut_DiscreteOut(DOut5384p0001,
                                 CPUCore_0, 
                                 CPU, 
                                 GPIO_159_J24, 
                                 GPIO,
                                 RES_POL_ACTIVE_HIGH,
                                 OUTPUT_IS_NON_INVERTING);
void DOut5384p0001_DiscreteOutput_Create(void)
{
	MotoCoder_DiscreteOutput_UpdateOnChange_Create(&DOut5384p0001, &DOut5384p0001_State, RES_OFF);
}
void DOut5384p0001_DiscreteOutput_Set(boolean_T value)
{
    MotoCoder_DiscreteOutput_UpdateOnChange_Set(&DOut5384p0001,
                                                &DOut5384p0001_State,
                                                value);
}
void DOut5384p0001_DiscreteOutput_Stop(void)
{
    MotoCoder_DiscreteOutput_UpdateOnChange_Stop(&DOut5384p0001, &DOut5384p0001_State);
}
    
    

#include <Pragma_Section_Start_SDA.h>
E_ResourceState DOut5387p0001_State;
#include <Pragma_Section_End_SDA.h>
NativeError_S DOut5387p0001_DiscreteOutput_Get(boolean_T* const out_pValue)
{
    if (FALSE == RES_OFF)
    {   /* Optimized return function can be used because enum states match with boolean*/
        *out_pValue = (boolean_T)DOut5387p0001_State;
    }
    else if (DOut5387p0001_State == RES_OFF)
    {
        *out_pValue = FALSE;
    }
    else /* if (DOut5387p0001_State == RES_ON) */
    {
        *out_pValue = TRUE;
    }
    return(SUCCESS_OK);
}


INSTANTIATE_BasicOut_DiscreteOut(DOut5387p0001,
                                 CPUCore_0, 
                                 CPU, 
                                 GPIO_158_J25, 
                                 GPIO,
                                 RES_POL_ACTIVE_HIGH,
                                 OUTPUT_IS_NON_INVERTING);
void DOut5387p0001_DiscreteOutput_Create(void)
{
	MotoCoder_DiscreteOutput_UpdateOnChange_Create(&DOut5387p0001, &DOut5387p0001_State, RES_OFF);
}
void DOut5387p0001_DiscreteOutput_Set(boolean_T value)
{
    MotoCoder_DiscreteOutput_UpdateOnChange_Set(&DOut5387p0001,
                                                &DOut5387p0001_State,
                                                value);
}
void DOut5387p0001_DiscreteOutput_Stop(void)
{
    MotoCoder_DiscreteOutput_UpdateOnChange_Stop(&DOut5387p0001, &DOut5387p0001_State);
}
    
    

#include <Pragma_Section_Start_SDA.h>
E_ResourceState DOut5388p0001_State;
#include <Pragma_Section_End_SDA.h>
NativeError_S DOut5388p0001_DiscreteOutput_Get(boolean_T* const out_pValue)
{
    if (FALSE == RES_OFF)
    {   /* Optimized return function can be used because enum states match with boolean*/
        *out_pValue = (boolean_T)DOut5388p0001_State;
    }
    else if (DOut5388p0001_State == RES_OFF)
    {
        *out_pValue = FALSE;
    }
    else /* if (DOut5388p0001_State == RES_ON) */
    {
        *out_pValue = TRUE;
    }
    return(SUCCESS_OK);
}


INSTANTIATE_BasicOut_DiscreteOut(DOut5388p0001,
                                 CPUCore_0, 
                                 CPU, 
                                 GPIO_202_AE21, 
                                 GPIO,
                                 RES_POL_ACTIVE_LOW,
                                 OUTPUT_IS_INVERTING);
void DOut5388p0001_DiscreteOutput_Create(void)
{
	MotoCoder_DiscreteOutput_UpdateOnChange_Create(&DOut5388p0001, &DOut5388p0001_State, RES_OFF);
}
void DOut5388p0001_DiscreteOutput_Set(boolean_T value)
{
    MotoCoder_DiscreteOutput_UpdateOnChange_Set(&DOut5388p0001,
                                                &DOut5388p0001_State,
                                                value);
}
void DOut5388p0001_DiscreteOutput_Stop(void)
{
    MotoCoder_DiscreteOutput_UpdateOnChange_Stop(&DOut5388p0001, &DOut5388p0001_State);
}
    
    

#include <Pragma_Section_Start_SDA.h>
E_ResourceState DOut6546p0005_State;
#include <Pragma_Section_End_SDA.h>
NativeError_S DOut6546p0005_DiscreteOutput_Get(boolean_T* const out_pValue)
{
    if (FALSE == RES_OFF)
    {   /* Optimized return function can be used because enum states match with boolean*/
        *out_pValue = (boolean_T)DOut6546p0005_State;
    }
    else if (DOut6546p0005_State == RES_OFF)
    {
        *out_pValue = FALSE;
    }
    else /* if (DOut6546p0005_State == RES_ON) */
    {
        *out_pValue = TRUE;
    }
    return(SUCCESS_OK);
}


INSTANTIATE_BasicOut_DiscreteOut(DOut6546p0005,
                                 CPUCore_0, 
                                 CPU, 
                                 GPIO_198_AE20, 
                                 GPIO,
                                 RES_POL_ACTIVE_HIGH,
                                 OUTPUT_IS_NON_INVERTING);
void DOut6546p0005_DiscreteOutput_Create(void)
{
	MotoCoder_DiscreteOutput_UpdateOnChange_Create(&DOut6546p0005, &DOut6546p0005_State, RES_OFF);
}
void DOut6546p0005_DiscreteOutput_Set(boolean_T value)
{
    MotoCoder_DiscreteOutput_UpdateOnChange_Set(&DOut6546p0005,
                                                &DOut6546p0005_State,
                                                value);
}
void DOut6546p0005_DiscreteOutput_Stop(void)
{
    MotoCoder_DiscreteOutput_UpdateOnChange_Stop(&DOut6546p0005, &DOut6546p0005_State);
}
    
    

#include <Pragma_Section_Start_SDA.h>
E_ResourceState H1_InhibitB_State;
#include <Pragma_Section_End_SDA.h>
NativeError_S H1_InhibitB_DiscreteOutput_Get(boolean_T* const out_pValue)
{
    if (FALSE == RES_OFF)
    {   /* Optimized return function can be used because enum states match with boolean*/
        *out_pValue = (boolean_T)H1_InhibitB_State;
    }
    else if (H1_InhibitB_State == RES_OFF)
    {
        *out_pValue = FALSE;
    }
    else /* if (H1_InhibitB_State == RES_ON) */
    {
        *out_pValue = TRUE;
    }
    return(SUCCESS_OK);
}


INSTANTIATE_BasicOut_DiscreteOut(H1_InhibitB,
                                 CPUCore_0, 
                                 CPU, 
                                 GPIO_164_D17, 
                                 GPIO,
                                 RES_POL_ACTIVE_HIGH,
                                 OUTPUT_IS_NON_INVERTING);
void H1_InhibitB_DiscreteOutput_Create(void)
{
	MotoCoder_DiscreteOutput_UpdateOnChange_Create(&H1_InhibitB, &H1_InhibitB_State, RES_OFF);
}
void H1_InhibitB_DiscreteOutput_Set(boolean_T value)
{
    MotoCoder_DiscreteOutput_UpdateOnChange_Set(&H1_InhibitB,
                                                &H1_InhibitB_State,
                                                value);
}
void H1_InhibitB_DiscreteOutput_Stop(void)
{
    MotoCoder_DiscreteOutput_UpdateOnChange_Stop(&H1_InhibitB, &H1_InhibitB_State);
}
void MotoCoder_DiscreteOutput_UpdateAlways_Create(S_BasicOut_Defn_DiscreteOut const* const in_pDefn, E_ResourceState in_eInitialState)
{
	S_BasicOut_Create_DiscreteOut CreateObj;
	
	CreateObj.DiscreteOutCreateAttribs.uValidAttributesMask = USE_DISCRETEOUT_DEFAULTS;
	CreateObj.Create.uValidAttributesMask = BASICOUT_USE_DEFAULTS;
	CreateObj.DiscreteOutCreateAttribs.eInitialState = in_eInitialState;
	BasicOut_DiscreteOut_Create(in_pDefn, &CreateObj);
}
    
    

INSTANTIATE_BasicOut_DiscreteOut(ODRC,
                                 CPUCore_0, 
                                 CPU, 
                                 GPIO_208_AB25, 
                                 GPIO,
                                 RES_POL_ACTIVE_LOW,
                                 OUTPUT_IS_NON_INVERTING);
void ODRC_DiscreteOutput_Create(void)
{
	MotoCoder_DiscreteOutput_UpdateAlways_Create(&ODRC, RES_ON);
}
NativeError_S ODRC_DiscreteOutput_Get(boolean_T* const out_pValue)
{
    NativeError_S sError;
    E_ResourceState eState = RES_OFF;

    sError = BasicOut_DiscreteOut_State_Get(&ODRC, &eState);
    if (RES_OFF == FALSE)
    {   /* Optimized return function can be used because enum states match with boolean */
        *out_pValue = (boolean_T)eState;
    }
    else if (eState == RES_OFF)
    {
        *out_pValue = FALSE;
    }
    else
    {   /* RES_ON */
        *out_pValue = TRUE;
    }
    return(sError);
}

/* Create all I/O resources */
void IO_Create(void)
{

    {extern void eTPU_Startup(void);
        eTPU_Startup();
    }
    {extern void CAN_1_Create(void);
        CAN_1_Create();
    }
    {extern void CAN_2_Create(void);
        CAN_2_Create();
    }
    {extern void CAN_3_Create(void);
        CAN_3_Create();
    }
    {extern void ESTOP2_DigitalInput_Create(void);
        ESTOP2_DigitalInput_Create();
    }
    {extern void SPI_C_Create(void);
        SPI_C_Create();
    }
    {extern void ODRC_DiscreteOutput_Create(void);
        ODRC_DiscreteOutput_Create();
    }
    {extern void S_SHRC_3_Create(void);
        S_SHRC_3_Create();
    }
    {extern void DOut5146p0001_DiscreteOutput_Create(void);
        DOut5146p0001_DiscreteOutput_Create();
    }
    {extern void DOut5147p0001_DiscreteOutput_Create(void);
        DOut5147p0001_DiscreteOutput_Create();
    }
    {extern void S_SHRC_4_Create(void);
        S_SHRC_4_Create();
    }
    {extern void MC33800_INJ8_DiscreteOutput_Create(void);
        MC33800_INJ8_DiscreteOutput_Create();
    }
    {extern void DOut5148p0001_DiscreteOutput_Create(void);
        DOut5148p0001_DiscreteOutput_Create();
    }
    {extern void MC33800_INJ6_DiscreteOutput_Create(void);
        MC33800_INJ6_DiscreteOutput_Create();
    }
    {extern void DOut5149p0001_DiscreteOutput_Create(void);
        DOut5149p0001_DiscreteOutput_Create();
    }
    {extern void MC33800_INJ7_DiscreteOutput_Create(void);
        MC33800_INJ7_DiscreteOutput_Create();
    }
    {extern void DOut5150p0001_DiscreteOutput_Create(void);
        DOut5150p0001_DiscreteOutput_Create();
    }
    {extern void MC33800_INJ5_DiscreteOutput_Create(void);
        MC33800_INJ5_DiscreteOutput_Create();
    }
    {extern void DOut5151p0001_DiscreteOutput_Create(void);
        DOut5151p0001_DiscreteOutput_Create();
    }
    {extern void MC33800_LSO2_DiscreteOutput_Create(void);
        MC33800_LSO2_DiscreteOutput_Create();
    }
    {extern void DOut5152p0001_DiscreteOutput_Create(void);
        DOut5152p0001_DiscreteOutput_Create();
    }
    {extern void MC33800_INJ4_DiscreteOutput_Create(void);
        MC33800_INJ4_DiscreteOutput_Create();
    }
    {extern void DOut5153p0001_DiscreteOutput_Create(void);
        DOut5153p0001_DiscreteOutput_Create();
    }
    {extern void MC33800_INJ3_DiscreteOutput_Create(void);
        MC33800_INJ3_DiscreteOutput_Create();
    }
    {extern void DOut5154p0001_DiscreteOutput_Create(void);
        DOut5154p0001_DiscreteOutput_Create();
    }
    {extern void MC33800_INJ2_DiscreteOutput_Create(void);
        MC33800_INJ2_DiscreteOutput_Create();
    }
    {extern void DOut5155p0001_DiscreteOutput_Create(void);
        DOut5155p0001_DiscreteOutput_Create();
    }
    {extern void DOut5156p0001_DiscreteOutput_Create(void);
        DOut5156p0001_DiscreteOutput_Create();
    }
    {extern void DOut5157p0001_DiscreteOutput_Create(void);
        DOut5157p0001_DiscreteOutput_Create();
    }
    {extern void DOut5158p0001_DiscreteOutput_Create(void);
        DOut5158p0001_DiscreteOutput_Create();
    }
    {extern void MC33800_LSO9_DiscreteOutput_Create(void);
        MC33800_LSO9_DiscreteOutput_Create();
    }
    {extern void DOut5384p0001_DiscreteOutput_Create(void);
        DOut5384p0001_DiscreteOutput_Create();
    }
    {extern void DOut5385p0001_DiscreteOutput_Create(void);
        DOut5385p0001_DiscreteOutput_Create();
    }
    {extern void DOut5386p0001_DiscreteOutput_Create(void);
        DOut5386p0001_DiscreteOutput_Create();
    }
    {extern void MC33800_LSO10_DiscreteOutput_Create(void);
        MC33800_LSO10_DiscreteOutput_Create();
    }
    {extern void DOut5387p0001_DiscreteOutput_Create(void);
        DOut5387p0001_DiscreteOutput_Create();
    }
    {extern void MC33800_LSO8_DiscreteOutput_Create(void);
        MC33800_LSO8_DiscreteOutput_Create();
    }
    {extern void DOut5388p0001_DiscreteOutput_Create(void);
        DOut5388p0001_DiscreteOutput_Create();
    }
    {extern void DOut5389p0001_DiscreteOutput_Create(void);
        DOut5389p0001_DiscreteOutput_Create();
    }
    {extern void MC33800_MPRD_DiscreteOutput_Create(void);
        MC33800_MPRD_DiscreteOutput_Create();
    }
    {extern void DOut6546p0005_DiscreteOutput_Create(void);
        DOut6546p0005_DiscreteOutput_Create();
    }
    {extern void SPI_B_Create(void);
        SPI_B_Create();
    }
    {extern void VISTA_1_Create(void);
        VISTA_1_Create();
    }
    {extern void DRVP_Create(void);
        DRVP_Create();
    }
    {extern void eQADC_A_B_eQADCModule_Create(void);
        eQADC_A_B_eQADCModule_Create();
    }
    {extern void ContinuousScan_eQADCQueue_Create(void);
        ContinuousScan_eQADCQueue_Create();
    }
    {extern void H1m_PWMOutput_Create(void);
        H1m_PWMOutput_Create();
    }
    {extern void H1_InhibitB_DiscreteOutput_Create(void);
        H1_InhibitB_DiscreteOutput_Create();
    }
    {extern void SPI_D_Create(void);
        SPI_D_Create();
    }
    {extern void EEPROM_1_Create(void);
        EEPROM_1_Create();
    }
}

/* Stop all I/O by putting each resource into a safe state */
void IO_Stop(void)
{
	
    {extern void DOut5146p0001_DiscreteOutput_Stop(void);
        DOut5146p0001_DiscreteOutput_Stop();
    }
    {extern void DOut5147p0001_DiscreteOutput_Stop(void);
        DOut5147p0001_DiscreteOutput_Stop();
    }
    {extern void DOut5148p0001_DiscreteOutput_Stop(void);
        DOut5148p0001_DiscreteOutput_Stop();
    }
    {extern void DOut5149p0001_DiscreteOutput_Stop(void);
        DOut5149p0001_DiscreteOutput_Stop();
    }
    {extern void DOut5150p0001_DiscreteOutput_Stop(void);
        DOut5150p0001_DiscreteOutput_Stop();
    }
    {extern void DOut5151p0001_DiscreteOutput_Stop(void);
        DOut5151p0001_DiscreteOutput_Stop();
    }
    {extern void DOut5152p0001_DiscreteOutput_Stop(void);
        DOut5152p0001_DiscreteOutput_Stop();
    }
    {extern void DOut5153p0001_DiscreteOutput_Stop(void);
        DOut5153p0001_DiscreteOutput_Stop();
    }
    {extern void DOut5154p0001_DiscreteOutput_Stop(void);
        DOut5154p0001_DiscreteOutput_Stop();
    }
    {extern void DOut5155p0001_DiscreteOutput_Stop(void);
        DOut5155p0001_DiscreteOutput_Stop();
    }
    {extern void DOut5156p0001_DiscreteOutput_Stop(void);
        DOut5156p0001_DiscreteOutput_Stop();
    }
    {extern void DOut5157p0001_DiscreteOutput_Stop(void);
        DOut5157p0001_DiscreteOutput_Stop();
    }
    {extern void DOut5158p0001_DiscreteOutput_Stop(void);
        DOut5158p0001_DiscreteOutput_Stop();
    }
    {extern void DOut5384p0001_DiscreteOutput_Stop(void);
        DOut5384p0001_DiscreteOutput_Stop();
    }
    {extern void DOut5385p0001_DiscreteOutput_Stop(void);
        DOut5385p0001_DiscreteOutput_Stop();
    }
    {extern void DOut5386p0001_DiscreteOutput_Stop(void);
        DOut5386p0001_DiscreteOutput_Stop();
    }
    {extern void DOut5387p0001_DiscreteOutput_Stop(void);
        DOut5387p0001_DiscreteOutput_Stop();
    }
    {extern void DOut5388p0001_DiscreteOutput_Stop(void);
        DOut5388p0001_DiscreteOutput_Stop();
    }
    {extern void DOut5389p0001_DiscreteOutput_Stop(void);
        DOut5389p0001_DiscreteOutput_Stop();
    }
    {extern void DOut6546p0005_DiscreteOutput_Stop(void);
        DOut6546p0005_DiscreteOutput_Stop();
    }
    {extern void H1m_PWMOutput_Stop(void);
        H1m_PWMOutput_Stop();
    }
    {extern void H1_InhibitB_DiscreteOutput_Stop(void);
        H1_InhibitB_DiscreteOutput_Stop();
    }
    {extern void H1m_PWMOutput_PWMOutput_Stop(void);
        H1m_PWMOutput_PWMOutput_Stop();
    }
}

