
/* MotoCoder_Services_CRC.c */
/* Generated by MotoCoder */
/* Version: 0.12.4 */
/* At: 2018-09-04 13:38:00 */
/* Copyright: 2018 Woodward. */


#include <MotoCoder_Services_CRC.h>
#include <BootInterface.h>
#include <ModuleDefn.h>

/* CRCService */
/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! 
           CRC32 implementation
           Ported from CRC32.c, extended to use __FAR_POINTERS.  
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

/*---- LOCAL FUNCTIONS ------------------------------------------------------------------------------------*/

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: CRC32_Initialise
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \brief Initialise a CRC32 value so it is ready to accumulate.
    \param out_pCRC pointer to CRC to initialise
    \remarks Pointer to out_pCRC is type NEAR
*/
static void CRC32_Initialise(uint32_T* const out_pCRC)
{
    *out_pCRC = 0xFFFFFFFFL;
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: CRC32_Accumulate
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \brief Accumulates to a CRC32 variable
    \param in_out_pCRCValue pointer to CRC to accumulate on
    \param in_pLookupTableArr CRC look up table
    \param in_Address FAR pointer to start address of memory to CRC
    \param in_uNumBytes number of bytes to CRC starting from in_Address
    \remarks Pointer to in_out_pCRCValue is type NEAR
*/
static void CRC32_Accumulate(uint32_T* const in_out_pCRCValue, uint32_T const* __FAR_POINTER in_pLookupTableArr, void const* __FAR_POINTER in_Address, uint32_T in_uNumBytes)
{
    uint8_T u8Data;
    uint8_T const* __FAR_POINTER pu8Value;

    for (pu8Value = (uint8_T* __FAR_POINTER)in_Address; in_uNumBytes != 0; in_uNumBytes--, pu8Value++)
    {
        /* The pu8Value used to be dereferenced directly.  This does not work for S12, so the less efficient Memory_ReadSynch is being called.
			A performance optimization here will likely be necessary. */
		Memory_ReadSynch(&u8Data, pu8Value, 1);

        *in_out_pCRCValue = ((*in_out_pCRCValue >> 8) & 0x00FFFFFFL) ^ in_pLookupTableArr[(uint8_T)(*in_out_pCRCValue ^ u8Data)];
    }
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: CRC32_ReturnValue
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \internal
    \brief  Return the normalised CRC32 value from the CRC32 variable.
    \param in_pCRCValue pointer to CRC obtain result from
    \returns Result CRC32
    \remarks Pointer to in_pCRC is type NEAR
*/
static uint32_T CRC32_ReturnValue(uint32_T const* const in_pCRC)
{
    return(~(*in_pCRC));
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: CRC32_VerifyCalc
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \internal
    \brief Test verify of the CRC32 calculation for the test "123456789"
    \returns Boolean. True if the CRC is correct (0xCBF43926L).
    \remarks Use to confirm correct implementation of the CRC. */
static bool1 CRC32_VerifyCalc(uint32_T const* __FAR_POINTER in_pLookupTableArr)
{
    uint32_T temp_crc;
    uint8_T temp_chk[] = "123456789";

    CRC32_Initialise(&temp_crc);
    CRC32_Accumulate(&temp_crc, in_pLookupTableArr, &temp_chk, 9);
    if (CRC32_ReturnValue(&temp_crc) != 0xCBF43926L)
    {
        return (FALSE);
    }
    else
    {
        return (TRUE);
    }
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: CheckSum_Init
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \internal
    \brief Initialize for CheckSum via pointer
    \returns None
*/
static void CheckSum_Init(uint32_T* const out_pu32CheckSum)
{
    /* Init the CRC to zero */
    *out_pu32CheckSum = 0;
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: CheckSum_Accumulate
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \internal
    \brief Accumulate CheckSum by adding all bytes in address range
    \returns None
*/
static void CheckSum_Accumulate(uint32_T* const inout_pu32CheckSumValue, void const* __FAR_POINTER in_pAddress, uint32_T in_u32NumBytes)
{
    NativeVar_U uByte;
    uint8_T* __FAR_POINTER pu8CheckSumData;
    uint32_T u32CheckSum;
    
    pu8CheckSumData = (uint8_T* __FAR_POINTER) in_pAddress;
    u32CheckSum = *inout_pu32CheckSumValue;
    
    for(uByte = 0; uByte < in_u32NumBytes; uByte++, pu8CheckSumData++)
    {
        /* Simply sum the data. We could refresh the watchdog, but it was done by the 
        calling function. And since this function is static, no need to worry about
        outside usage. */
        u32CheckSum += *pu8CheckSumData;
    }
    
    *inout_pu32CheckSumValue = u32CheckSum;
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: CheckSum_ReturnValue
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \internal
    \brief Return CheckSum result given an accumulated value
    \returns None
*/
static uint32_T CheckSum_ReturnValue(uint32_T const* const in_pu32CheckSum)
{
    /* Do nothing. Return the calculated value */
    return(*in_pu32CheckSum);
}

/*----- END OF LOCAL FUNCTIONS -------------------------------------------------------------------------*/

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: MC_Services_AdditiveCRC_Perform_Sync
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \internal
    \brief API function, performs CheckSum on given range Start to End INCLUSIVE.
    \returns TRUE if calculation succesful
    \remarks Result written by pointer
*/
NativeBool MC_Services_AdditiveCRC_Perform_Sync(void* __FAR_POINTER in_pStartAddress, void* __FAR_POINTER in_pEndAddress, uint32_T* const out_p32CRC)
{
    /* Validate parameters */
    if(in_pStartAddress > in_pEndAddress)
    {
        return FALSE;
    }
    else
    { 
        uint32_T uNumBytes;
        uint32_T u32CRC;

        /* Calculate the number of bytes to CRC - EndAddress INCLUSIVE */
        uNumBytes = (uint32_T)((uint8_T* __FAR_POINTER)in_pEndAddress - (uint8_T* __FAR_POINTER)in_pStartAddress + 1);
        
        /* Initialize the CRC */
        CheckSum_Init(&u32CRC);                
    
        CheckSum_Accumulate(&u32CRC, in_pStartAddress, uNumBytes);

        *out_p32CRC = CheckSum_ReturnValue(&u32CRC);

        return TRUE;
    }
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: MC_Services_CRC32_Perform_Sync
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \internal
    \brief API function, performs CRC32 on given range Start to End INCLUSIVE.
    \returns TRUE if calculation succesful
    \remarks Result written by pointer
*/
NativeBool MC_Services_CRC32_Perform_Sync(void* __FAR_POINTER in_pStartAddress, void* __FAR_POINTER in_pEndAddress, uint32_T* const out_p32CRC)
{
    BASEPTRARR pvPointerArr = GetModuleConfigPointerArr();
    /* Table revision is ALWAYS entry zero and points to an int. */
    int32_T const* __FAR_POINTER ps32Version = (int32_T const* __FAR_POINTER) pvPointerArr[0]; 
        
    /* Ensure that the version pointer points to an actual version */
    if (((uint32_T)ps32Version) != 0xFFFFFFFFL) 
    {
        if(*ps32Version == PV1)
        {   
            /* Validate parameters */
            if(in_pStartAddress > in_pEndAddress)
            {
                return FALSE;
            }
            else
            { 
                uint32_T uNumBytes;
                uint32_T u32CRC;

                /* Calculate the number of bytes to CRC */
                uNumBytes = (uint32_T)((uint8_T* __FAR_POINTER)in_pEndAddress - (uint8_T* __FAR_POINTER)in_pStartAddress + 1);
                
                /* Initialize the CRC */
                CRC32_Initialise(&u32CRC);                
            
                CRC32_Accumulate(&u32CRC, pvPointerArr[MC_PV1_UI4ARR_CRCLOOKUPTABLE], in_pStartAddress, uNumBytes);

                *out_p32CRC = CRC32_ReturnValue(&u32CRC);

                return TRUE;
            }
        
        }
    }
    
    /* CRC32 was specifically asked for. It is not available. Return error. */
    return FALSE;
}


/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: MC_Services_CRC32_Verify
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \internal
    \brief Allows system to check if CRC32 is available and operational.
    \returns TRUE if calculation possible
*/
NativeBool MC_Services_CRC32_Verify(void)
{
    BASEPTRARR pvPointerArr = GetModuleConfigPointerArr();
    /* Table revision is ALWAYS entry zero and points to an int. */
    int32_T const* __FAR_POINTER ps32Version = (int32_T const* __FAR_POINTER) pvPointerArr[0]; 
        
    /* Ensure that the version pointer points to an actual version */
    if (((uint32_T)ps32Version) != 0xFFFFFFFFL) 
    {
        if(*ps32Version == PV1)
        {   
            return(CRC32_VerifyCalc(pvPointerArr[MC_PV1_UI4ARR_CRCLOOKUPTABLE]));
        }
    }
    return (FALSE);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: MC_Services_CRC32_Init
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \internal
    \brief API function, initialise CRC32 prior to commencing calculation.
    \param out_p32CRC Pointer to CRC to initialise
    \returns TRUE if calculation possible
    \remarks Initialised CRC written by pointer
*/
NativeBool MC_Services_CRC32_Init(uint32_T* const out_p32CRC)
{
    BASEPTRARR pvPointerArr = GetModuleConfigPointerArr();
    /* Table revision is ALWAYS entry zero and points to an int. */
    int32_T const* __FAR_POINTER ps32Version = (int32_T const* __FAR_POINTER) pvPointerArr[0]; 
        
    /* Ensure that the version pointer points to an actual version */
    if (((uint32_T)ps32Version) != 0xFFFFFFFFL) 
    {
        if(*ps32Version == PV1)
        {   
            /* Initialize the CRC */
            CRC32_Initialise(out_p32CRC); 
            return(CRC32_VerifyCalc(pvPointerArr[MC_PV1_UI4ARR_CRCLOOKUPTABLE]));               
        }
    }
    
    /* CRC32 was specifically asked for. It is not available. Return error. */
    return FALSE;
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: MC_Services_CRC32_Accumulate
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \internal
    \brief API function, Accumulate CRC32 over given range starting with given CRC value.
    \param in_pStartAddress FAR Pointer to StartAddress of region to calc CRC over
    \param in_NumBytes bumber of bytes to include in CRC
    \param in_out_p32CRC Pointer to CRC to accumulate on
    \returns TRUE if calculation possible
    \remarks CRC32 is read and written by pointer
*/
NativeBool MC_Services_CRC32_Accumulate(void* __FAR_POINTER in_pStartAddress, uint32_T in_NumBytes, uint32_T* const in_out_p32CRC)
{
    BASEPTRARR pvPointerArr = GetModuleConfigPointerArr();
    /* Table revision is ALWAYS entry zero and points to an int. */
    int32_T const* __FAR_POINTER ps32Version = (int32_T const* __FAR_POINTER) pvPointerArr[0]; 
        
    /* Ensure that the version pointer points to an actual version */
    if (((uint32_T)ps32Version) != 0xFFFFFFFFL) 
    {
        if(*ps32Version == PV1)
        {   
            /* Table is a revision one. Use CRC32 functions. */   
            CRC32_Accumulate(in_out_p32CRC, pvPointerArr[MC_PV1_UI4ARR_CRCLOOKUPTABLE], in_pStartAddress, in_NumBytes);
            return(TRUE);
        }
    }
    
    /* CRC32 was specifically asked for. It is not available. Return error. */
    return FALSE;
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: MC_Services_CRC32_Accumulate
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*! \internal
    \brief  Return the normalised CRC32 value from the CRC32 variable.
    \param in_pCRCValue pointer to CRC obtain result from
    \returns Result CRC32
    \remarks Pointer to in_pCRCValue is type NEAR
*/
uint32_T MC_Services_CRC32_ReturnValue(uint32_T const* const in_pCRCValue)
{
    return(CRC32_ReturnValue(in_pCRCValue));
}

